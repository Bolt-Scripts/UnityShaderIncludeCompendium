cgincData = {
  "files": [
    {
      "file": "Lighting.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define LIGHTING_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 19,
          "code": "#define USING_DIRECTIONAL_LIGHT"
        },
        {
          "comment": "",
          "lineNum": 24,
          "code": "    #define UNITY_LIGHT_FUNCTION_APPLY_INDIRECT"
        },
        {
          "comment": "// Deprecated, kept around for existing user shaders.",
          "lineNum": 162,
          "code": "#define UNITY_DIRBASIS \\\nconst half3x3 unity_DirBasis = half3x3( \\\n  half3( 0.81649658,  0.0,        0.57735027), \\\n  half3(-0.40824830,  0.70710678, 0.57735027), \\\n  half3(-0.40824830, -0.70710678, 0.57735027) \\\n);"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 27,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, UnityLight light",
          "type": "fixed4",
          "name": "UnityLambertLight",
          "code": "inline fixed4 UnityLambertLight (SurfaceOutput s, UnityLight light)\n{\n    fixed diff = max (0, dot (s.Normal, light.dir));\n\n    fixed4 c;\n    c.rgb = s.Albedo * light.color * diff;\n    c.a = s.Alpha;\n    return c;\n}"
        },
        {
          "comment": "",
          "lineNum": 37,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, UnityGI gi",
          "type": "fixed4",
          "name": "LightingLambert",
          "code": "inline fixed4 LightingLambert (SurfaceOutput s, UnityGI gi)\n{\n    fixed4 c;\n    c = UnityLambertLight (s, gi.light);\n\n    #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT\n        c.rgb += s.Albedo * gi.indirect.diffuse;\n    #endif\n\n    return c;\n}"
        },
        {
          "comment": "",
          "lineNum": 49,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2",
          "type": "half4",
          "name": "LightingLambert_Deferred",
          "code": "inline half4 LightingLambert_Deferred (SurfaceOutput s, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2)\n{\n    UnityStandardData data;\n    data.diffuseColor   = s.Albedo;\n    data.occlusion      = 1;\n    data.specularColor  = 0;\n    data.smoothness     = 0;\n    data.normalWorld    = s.Normal;\n\n    UnityStandardDataToGbuffer(data, outGBuffer0, outGBuffer1, outGBuffer2);\n\n    half4 emission = half4(s.Emission, 1);\n\n    #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT\n        emission.rgb += s.Albedo * gi.indirect.diffuse;\n    #endif\n\n    return emission;\n}"
        },
        {
          "comment": "",
          "lineNum": 69,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s,    UnityGIInput data,    inout UnityGI gi",
          "type": "void",
          "name": "LightingLambert_GI",
          "code": "inline void LightingLambert_GI (\n    SurfaceOutput s,\n    UnityGIInput data,\n    inout UnityGI gi)\n{\n    gi = UnityGlobalIllumination (data, 1.0, s.Normal);\n}"
        },
        {
          "comment": "",
          "lineNum": 77,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, half4 light",
          "type": "fixed4",
          "name": "LightingLambert_PrePass",
          "code": "inline fixed4 LightingLambert_PrePass (SurfaceOutput s, half4 light)\n{\n    fixed4 c;\n    c.rgb = s.Albedo * light.rgb;\n    c.a = s.Alpha;\n    return c;\n}"
        },
        {
          "comment": "// NOTE: some intricacy in shader compiler on some GLES2.0 platforms (iOS) needs 'viewDir' & 'h'\n// to be mediump instead of lowp, otherwise specular highlight becomes too bright.",
          "lineNum": 87,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, half3 viewDir, UnityLight light",
          "type": "fixed4",
          "name": "UnityBlinnPhongLight",
          "code": "inline fixed4 UnityBlinnPhongLight (SurfaceOutput s, half3 viewDir, UnityLight light)\n{\n    half3 h = normalize (light.dir + viewDir);\n\n    fixed diff = max (0, dot (s.Normal, light.dir));\n\n    float nh = max (0, dot (s.Normal, h));\n    float spec = pow (nh, s.Specular*128.0) * s.Gloss;\n\n    fixed4 c;\n    c.rgb = s.Albedo * light.color * diff + light.color * _SpecColor.rgb * spec;\n    c.a = s.Alpha;\n\n    return c;\n}"
        },
        {
          "comment": "",
          "lineNum": 103,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, half3 viewDir, UnityGI gi",
          "type": "fixed4",
          "name": "LightingBlinnPhong",
          "code": "inline fixed4 LightingBlinnPhong (SurfaceOutput s, half3 viewDir, UnityGI gi)\n{\n    fixed4 c;\n    c = UnityBlinnPhongLight (s, viewDir, gi.light);\n\n    #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT\n        c.rgb += s.Albedo * gi.indirect.diffuse;\n    #endif\n\n    return c;\n}"
        },
        {
          "comment": "",
          "lineNum": 115,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, half3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2",
          "type": "half4",
          "name": "LightingBlinnPhong_Deferred",
          "code": "inline half4 LightingBlinnPhong_Deferred (SurfaceOutput s, half3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2)\n{\n    UnityStandardData data;\n    data.diffuseColor   = s.Albedo;\n    data.occlusion      = 1;\n    // PI factor come from StandardBDRF (UnityStandardBRDF.cginc:351 for explanation)\n    data.specularColor  = _SpecColor.rgb * s.Gloss * (1/UNITY_PI);\n    data.smoothness     = s.Specular;\n    data.normalWorld    = s.Normal;\n\n    UnityStandardDataToGbuffer(data, outGBuffer0, outGBuffer1, outGBuffer2);\n\n    half4 emission = half4(s.Emission, 1);\n\n    #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT\n        emission.rgb += s.Albedo * gi.indirect.diffuse;\n    #endif\n\n    return emission;\n}"
        },
        {
          "comment": "",
          "lineNum": 136,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s,    UnityGIInput data,    inout UnityGI gi",
          "type": "void",
          "name": "LightingBlinnPhong_GI",
          "code": "inline void LightingBlinnPhong_GI (\n    SurfaceOutput s,\n    UnityGIInput data,\n    inout UnityGI gi)\n{\n    gi = UnityGlobalIllumination (data, 1.0, s.Normal);\n}"
        },
        {
          "comment": "",
          "lineNum": 144,
          "modifiers": "inline",
          "parameters": "SurfaceOutput s, half4 light",
          "type": "fixed4",
          "name": "LightingBlinnPhong_PrePass",
          "code": "inline fixed4 LightingBlinnPhong_PrePass (SurfaceOutput s, half4 light)\n{\n    fixed spec = light.a * s.Gloss;\n\n    fixed4 c;\n    c.rgb = (s.Albedo * light.rgb + light.rgb * _SpecColor.rgb * spec);\n    c.a = s.Alpha;\n    return c;\n}"
        },
        {
          "comment": "// Deprecated, kept around for existing user shaders. Only sampling the flat lightmap now.",
          "lineNum": 170,
          "modifiers": "",
          "parameters": "in half3x3 dirBasis, fixed4 color, fixed4 scale, half3 normal, bool surfFuncWritesNormal, out half3 scalePerBasisVector",
          "type": "half3",
          "name": "DirLightmapDiffuse",
          "code": "half3 DirLightmapDiffuse(in half3x3 dirBasis, fixed4 color, fixed4 scale, half3 normal, bool surfFuncWritesNormal, out half3 scalePerBasisVector)\n{\n    scalePerBasisVector = 1;\n    return DecodeLightmap (color);\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 8,
          "type": "struct",
          "name": "SurfaceOutput",
          "modifiers": "",
          "code": "struct SurfaceOutput {\n    fixed3 Albedo;\n    fixed3 Normal;\n    fixed3 Emission;\n    half Specular;\n    fixed Gloss;\n    fixed Alpha;\n};"
        },
        {
          "comment": "",
          "lineNum": 155,
          "type": "struct",
          "name": "UnityTessellationFactors",
          "modifiers": "",
          "code": "struct UnityTessellationFactors {\n    float edge[3] : SV_TessFactor;\n    float inside : SV_InsideTessFactor;\n};"
        }
      ],
      "variables": []
    },
    {
      "file": "SpeedTree8Common.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 5,
          "code": "#define SPEEDTREE8_COMMON_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 11,
          "code": "    #define SPEEDTREE_Y_UP"
        },
        {
          "comment": "",
          "lineNum": 58,
          "code": "#define GEOM_TYPE_BRANCH 0"
        },
        {
          "comment": "",
          "lineNum": 59,
          "code": "#define GEOM_TYPE_FROND 1"
        },
        {
          "comment": "",
          "lineNum": 60,
          "code": "#define GEOM_TYPE_LEAF 2"
        },
        {
          "comment": "",
          "lineNum": 61,
          "code": "#define GEOM_TYPE_FACINGLEAF 3"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 67,
          "modifiers": "",
          "parameters": "inout appdata_full data, float lodValue",
          "type": "void",
          "name": "OffsetSpeedTreeVertex",
          "code": "void OffsetSpeedTreeVertex(inout appdata_full data, float lodValue)\n{\n    // smooth LOD\n    #if defined(LOD_FADE_PERCENTAGE) && !defined(EFFECT_BILLBOARD)\n        data.vertex.xyz = lerp(data.vertex.xyz, data.texcoord2.xyz, lodValue);\n    #endif\n\n    // wind\n    #if defined(ENABLE_WIND) && !defined(_WINDQUALITY_NONE)\n        if (_WindEnabled > 0)\n        {\n            float3 rotatedWindVector = mul(_ST_WindVector.xyz, (float3x3)unity_ObjectToWorld);\n            float windLength = length(rotatedWindVector);\n            if (windLength < 1e-5)\n            {\n                // sanity check that wind data is available\n                return;\n            }\n            rotatedWindVector /= windLength;\n\n            float3 treePos = float3(unity_ObjectToWorld[0].w, unity_ObjectToWorld[1].w, unity_ObjectToWorld[2].w);\n            float3 windyPosition = data.vertex.xyz;\n\n            #ifndef EFFECT_BILLBOARD\n                // geometry type\n                float geometryType = (int)(data.texcoord3.w + 0.25);\n                bool leafTwo = false;\n                if (geometryType > GEOM_TYPE_FACINGLEAF)\n                {\n                    geometryType -= 2;\n                    leafTwo = true;\n                }\n\n                // leaves\n                if (geometryType > GEOM_TYPE_FROND)\n                {\n                    // remove anchor position\n                    float3 anchor = float3(data.texcoord1.zw, data.texcoord2.w);\n                    windyPosition -= anchor;\n\n                    if (geometryType == GEOM_TYPE_FACINGLEAF)\n                    {\n                        // face camera-facing leaf to camera\n                        float offsetLen = length(windyPosition);\n                        windyPosition = mul(windyPosition.xyz, (float3x3)UNITY_MATRIX_IT_MV); // inv(MV) * windyPosition\n                        windyPosition = normalize(windyPosition) * offsetLen; // make sure the offset vector is still scaled\n                    }\n\n                    // leaf wind\n                    #if defined(_WINDQUALITY_FAST) || defined(_WINDQUALITY_BETTER) || defined(_WINDQUALITY_BEST)\n                        #ifdef _WINDQUALITY_BEST\n                            bool bBestWind = true;\n                        #else\n                            bool bBestWind = false;\n                        #endif\n                        float leafWindTrigOffset = anchor.x + anchor.y;\n                        windyPosition = LeafWind(bBestWind, leafTwo, windyPosition, data.normal, data.texcoord3.x, float3(0,0,0), data.texcoord3.y, data.texcoord3.z, leafWindTrigOffset, rotatedWindVector);\n                    #endif\n\n                    // move back out to anchor\n                    windyPosition += anchor;\n                }\n\n                // frond wind\n                bool bPalmWind = false;\n                #ifdef _WINDQUALITY_PALM\n                    bPalmWind = true;\n                    if (geometryType == GEOM_TYPE_FROND)\n                    {\n                        windyPosition = RippleFrond(windyPosition, data.normal, data.texcoord.x, data.texcoord.y, data.texcoord3.x, data.texcoord3.y, data.texcoord3.z);\n                    }\n                #endif\n\n                // branch wind (applies to all 3D geometry)\n                #if defined(_WINDQUALITY_BETTER) || defined(_WINDQUALITY_BEST) || defined(_WINDQUALITY_PALM)\n                    float3 rotatedBranchAnchor = normalize(mul(_ST_WindBranchAnchor.xyz, (float3x3)unity_ObjectToWorld)) * _ST_WindBranchAnchor.w;\n                    windyPosition = BranchWind(bPalmWind, windyPosition, treePos, float4(data.texcoord.zw, 0, 0), rotatedWindVector, rotatedBranchAnchor);\n                #endif\n\n            #endif // !EFFECT_BILLBOARD\n\n            // global wind\n            float globalWindTime = _ST_WindGlobal.x;\n            #if defined(EFFECT_BILLBOARD) && defined(UNITY_INSTANCING_ENABLED)\n                globalWindTime += UNITY_ACCESS_INSTANCED_PROP(STWind, _GlobalWindTime);\n            #endif\n            windyPosition = GlobalWind(windyPosition, treePos, true, rotatedWindVector, globalWindTime);\n            data.vertex.xyz = windyPosition;\n        }\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 163,
          "modifiers": "",
          "parameters": "inout appdata_full v",
          "type": "void",
          "name": "SpeedTreeVert",
          "code": "void SpeedTreeVert(inout appdata_full v)\n{\n    // handle speedtree wind and lod\n    OffsetSpeedTreeVertex(v, unity_LODFade.x);\n\n    float3 treePos = float3(unity_ObjectToWorld[0].w, unity_ObjectToWorld[1].w, unity_ObjectToWorld[2].w);\n\n    #if defined(EFFECT_BILLBOARD)\n\n        // crossfade faces\n        bool topDown = (v.texcoord.z > 0.5);\n        float3 viewDir = UNITY_MATRIX_IT_MV[2].xyz;\n        float3 cameraDir = normalize(mul((float3x3)unity_WorldToObject, _WorldSpaceCameraPos - treePos));\n        float viewDot = max(dot(viewDir, v.normal), dot(cameraDir, v.normal));\n        viewDot *= viewDot;\n        viewDot *= viewDot;\n        viewDot += topDown ? 0.38 : 0.18; // different scales for horz and vert billboards to fix transition zone\n        v.color = float4(1, 1, 1, clamp(viewDot, 0, 1));\n\n        // if invisible, avoid overdraw\n        if (viewDot < 0.3333)\n        {\n            v.vertex.xyz = float3(0,0,0);\n        }\n\n        // adjust lighting on billboards to prevent seams between the different faces\n        if (topDown)\n        {\n            v.normal += cameraDir;\n        }\n        else\n        {\n            half3 binormal = cross(v.normal, v.tangent.xyz) * v.tangent.w;\n            float3 right = cross(cameraDir, binormal);\n            v.normal = cross(binormal, right);\n        }\n        v.normal = normalize(v.normal);\n\n    #endif\n\n    // color already contains (ao, ao, ao, blend)\n    // put hue variation amount in there\n    #ifdef EFFECT_HUE_VARIATION\n        float hueVariationAmount = frac(treePos.x + treePos.y + treePos.z);\n        v.color.g = saturate(hueVariationAmount * _HueVariationColor.a);\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 215,
          "modifiers": "",
          "parameters": "inout SurfaceOutputStandard s, half3 viewDir, UnityGI gi",
          "type": "half4",
          "name": "LightingSpeedTreeSubsurface",
          "code": "half4 LightingSpeedTreeSubsurface(inout SurfaceOutputStandard s, half3 viewDir, UnityGI gi)\n{\n    #ifdef EFFECT_SUBSURFACE\n        half fSubsurfaceRough = 0.7 - s.Smoothness * 0.5;\n        half fSubsurface = GGXTerm(clamp(-dot(gi.light.dir, viewDir), 0, 1), fSubsurfaceRough);\n\n        // put modulated subsurface back into emission\n        s.Emission *= (gi.indirect.diffuse * _SubsurfaceIndirect + gi.light.color * fSubsurface);\n    #endif\n\n    return LightingStandard(s, viewDir, gi);\n}"
        },
        {
          "comment": "",
          "lineNum": 228,
          "modifiers": "",
          "parameters": "inout SurfaceOutputStandard s, UnityGIInput data, inout UnityGI gi",
          "type": "void",
          "name": "LightingSpeedTreeSubsurface_GI",
          "code": "void LightingSpeedTreeSubsurface_GI(inout SurfaceOutputStandard s, UnityGIInput data, inout UnityGI gi)\n{\n    #ifdef EFFECT_BILLBOARD\n        // fade off the shadows on billboards to avoid artifacts\n        data.atten = lerp(data.atten, 1.0, _BillboardShadowFade);\n    #endif\n\n    LightingStandard_GI(s, data, gi);\n}"
        },
        {
          "comment": "",
          "lineNum": 238,
          "modifiers": "",
          "parameters": "SurfaceOutputStandard s, half3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2",
          "type": "half4",
          "name": "LightingSpeedTreeSubsurface_Deferred",
          "code": "half4 LightingSpeedTreeSubsurface_Deferred(SurfaceOutputStandard s, half3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2)\n{\n    // no light/shadow info in deferred, so stop subsurface\n    s.Emission = half3(0,0,0);\n\n    return LightingStandard_Deferred(s, viewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n}"
        },
        {
          "comment": "",
          "lineNum": 250,
          "modifiers": "",
          "parameters": "Input IN, inout SurfaceOutputStandard OUT",
          "type": "void",
          "name": "SpeedTreeSurf",
          "code": "void SpeedTreeSurf(Input IN, inout SurfaceOutputStandard OUT)\n{\n    fixed4 color = tex2D(_MainTex, IN.uv_MainTex) * _Color;\n\n    // transparency\n    OUT.Alpha = color.a * IN.color.a;\n    clip(OUT.Alpha - 0.3333);\n\n    // color\n    OUT.Albedo = color.rgb;\n\n    // hue variation\n    #ifdef EFFECT_HUE_VARIATION\n        half3 shiftedColor = lerp(OUT.Albedo, _HueVariationColor.rgb, IN.color.g);\n\n        // preserve vibrance\n        half maxBase = max(OUT.Albedo.r, max(OUT.Albedo.g, OUT.Albedo.b));\n        half newMaxBase = max(shiftedColor.r, max(shiftedColor.g, shiftedColor.b));\n        maxBase /= newMaxBase;\n        maxBase = maxBase * 0.5f + 0.5f;\n        shiftedColor.rgb *= maxBase;\n\n        OUT.Albedo = saturate(shiftedColor);\n    #endif\n\n    // normal\n    #ifdef EFFECT_BUMP\n        OUT.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_MainTex));\n    #elif defined(EFFECT_BACKSIDE_NORMALS) || defined(EFFECT_BILLBOARD)\n        OUT.Normal = float3(0, 0, 1);\n    #endif\n\n    // flip normal on backsides\n    #ifdef EFFECT_BACKSIDE_NORMALS\n        if (IN.facing < 0.5)\n        {\n            OUT.Normal.z = -OUT.Normal.z;\n        }\n    #endif\n\n    // adjust billboard normals to improve GI and matching\n    #ifdef EFFECT_BILLBOARD\n        OUT.Normal.z *= 0.5;\n        OUT.Normal = normalize(OUT.Normal);\n    #endif\n\n    // extra\n    #ifdef EFFECT_EXTRA_TEX\n        fixed4 extra = tex2D(_ExtraTex, IN.uv_MainTex);\n        OUT.Smoothness = extra.r;\n        OUT.Metallic = extra.g;\n        OUT.Occlusion = extra.b * IN.color.r;\n    #else\n        OUT.Smoothness = _Glossiness;\n        OUT.Metallic = _Metallic;\n        OUT.Occlusion = IN.color.r;\n    #endif\n\n    // subsurface (hijack emissive)\n    #ifdef EFFECT_SUBSURFACE\n        OUT.Emission = tex2D(_SubsurfaceTex, IN.uv_MainTex) * _SubsurfaceColor;\n    #endif\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 19,
          "type": "struct",
          "name": "Input",
          "modifiers": "",
          "code": "struct Input\n{\n    half2   uv_MainTex  : TEXCOORD0;\n    fixed4  color       : COLOR;\n\n    #ifdef EFFECT_BACKSIDE_NORMALS\n        fixed   facing      : VFACE;\n    #endif\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 13,
          "modifiers": "",
          "type": "float",
          "name": "_WindEnabled;",
          "code": "float _WindEnabled;"
        },
        {
          "comment": "",
          "lineNum": 29,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 30,
          "modifiers": "",
          "type": "fixed4",
          "name": "_Color;",
          "code": "fixed4 _Color;"
        },
        {
          "comment": "",
          "lineNum": 31,
          "modifiers": "",
          "type": "int",
          "name": "_TwoSided;",
          "code": "int _TwoSided;"
        },
        {
          "comment": "",
          "lineNum": 34,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_BumpMap;",
          "code": "sampler2D _BumpMap;"
        },
        {
          "comment": "",
          "lineNum": 38,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_ExtraTex;",
          "code": "sampler2D _ExtraTex;"
        },
        {
          "comment": "",
          "lineNum": 40,
          "modifiers": "",
          "type": "half",
          "name": "_Glossiness;",
          "code": "half _Glossiness;"
        },
        {
          "comment": "",
          "lineNum": 41,
          "modifiers": "",
          "type": "half",
          "name": "_Metallic;",
          "code": "half _Metallic;"
        },
        {
          "comment": "",
          "lineNum": 45,
          "modifiers": "",
          "type": "half4",
          "name": "_HueVariationColor;",
          "code": "half4 _HueVariationColor;"
        },
        {
          "comment": "",
          "lineNum": 49,
          "modifiers": "",
          "type": "half",
          "name": "_BillboardShadowFade;",
          "code": "half _BillboardShadowFade;"
        },
        {
          "comment": "",
          "lineNum": 53,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_SubsurfaceTex;",
          "code": "sampler2D _SubsurfaceTex;"
        },
        {
          "comment": "",
          "lineNum": 54,
          "modifiers": "",
          "type": "fixed4",
          "name": "_SubsurfaceColor;",
          "code": "fixed4 _SubsurfaceColor;"
        },
        {
          "comment": "",
          "lineNum": 55,
          "modifiers": "",
          "type": "half",
          "name": "_SubsurfaceIndirect;",
          "code": "half _SubsurfaceIndirect;"
        }
      ]
    },
    {
      "file": "SpeedTreeBillboardCommon.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define SPEEDTREE_BILLBOARD_COMMON_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 4,
          "code": "#define SPEEDTREE_ALPHATEST"
        },
        {
          "comment": "",
          "lineNum": 13,
          "code": "    #define unity_BillboardCameraPosition (unity_BillboardCameraParams.xyz)"
        },
        {
          "comment": "",
          "lineNum": 14,
          "code": "    #define unity_BillboardCameraXZAngle (unity_BillboardCameraParams.w)"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 34,
          "modifiers": "",
          "parameters": "inout SpeedTreeBillboardData IN, out Input OUT",
          "type": "void",
          "name": "SpeedTreeBillboardVert",
          "code": "void SpeedTreeBillboardVert(inout SpeedTreeBillboardData IN, out Input OUT)\n{\n    UNITY_INITIALIZE_OUTPUT(Input, OUT);\n\n    // assume no scaling & rotation\n    float3 worldPos = IN.vertex.xyz + float3(unity_ObjectToWorld[0].w, unity_ObjectToWorld[1].w, unity_ObjectToWorld[2].w);\n\n#ifdef BILLBOARD_FACE_CAMERA_POS\n    float3 eyeVec = normalize(unity_BillboardCameraPosition - worldPos);\n    float3 billboardTangent = normalize(float3(-eyeVec.z, 0, eyeVec.x));            // cross(eyeVec, {0,1,0})\n    float3 billboardNormal = float3(billboardTangent.z, 0, -billboardTangent.x);    // cross({0,1,0},billboardTangent)\n    float3 angle = atan2(billboardNormal.z, billboardNormal.x);                     // signed angle between billboardNormal to {0,0,1}\n    angle += angle < 0 ? 2 * UNITY_PI : 0;\n#else\n    float3 billboardTangent = unity_BillboardTangent;\n    float3 billboardNormal = unity_BillboardNormal;\n    float angle = unity_BillboardCameraXZAngle;\n#endif\n\n    float widthScale = IN.texcoord1.x;\n    float heightScale = IN.texcoord1.y;\n    float rotation = IN.texcoord1.z;\n\n    float2 percent = IN.texcoord.xy;\n    float3 billboardPos = (percent.x - 0.5f) * unity_BillboardSize.x * widthScale * billboardTangent;\n    billboardPos.y += (percent.y * unity_BillboardSize.y + unity_BillboardSize.z) * heightScale;\n\n#ifdef ENABLE_WIND\n    if (_WindQuality * _WindEnabled > 0)\n        billboardPos = GlobalWind(billboardPos, worldPos, true, _ST_WindVector.xyz, IN.texcoord1.w);\n#endif\n\n    IN.vertex.xyz += billboardPos;\n    IN.vertex.w = 1.0f;\n    IN.normal = billboardNormal.xyz;\n    IN.tangent = float4(billboardTangent.xyz,-1);\n\n    float slices = unity_BillboardInfo.x;\n    float invDelta = unity_BillboardInfo.y;\n    angle += rotation;\n\n    float imageIndex = fmod(floor(angle * invDelta + 0.5f), slices);\n    float4 imageTexCoords = unity_BillboardImageTexCoords[imageIndex];\n    if (imageTexCoords.w < 0)\n    {\n        OUT.mainTexUV = imageTexCoords.xy - imageTexCoords.zw * percent.yx;\n    }\n    else\n    {\n        OUT.mainTexUV = imageTexCoords.xy + imageTexCoords.zw * percent;\n    }\n\n    OUT.color = _Color;\n\n#ifdef EFFECT_HUE_VARIATION\n    float hueVariationAmount = frac(worldPos.x + worldPos.y + worldPos.z);\n    OUT.HueVariationAmount = saturate(hueVariationAmount * _HueVariation.a);\n#endif\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 23,
          "type": "struct",
          "name": "SpeedTreeBillboardData",
          "modifiers": "",
          "code": "struct SpeedTreeBillboardData\n{\n    float4 vertex       : POSITION;\n    float2 texcoord     : TEXCOORD0;\n    float4 texcoord1    : TEXCOORD1;\n    float3 normal       : NORMAL;\n    float4 tangent      : TANGENT;\n    float4 color        : COLOR;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 5,
          "modifiers": "",
          "type": "fixed",
          "name": "_Cutoff;",
          "code": "fixed _Cutoff;"
        },
        {
          "comment": "",
          "lineNum": 10,
          "modifiers": "",
          "type": "float3",
          "name": "unity_BillboardNormal;",
          "code": "float3 unity_BillboardNormal;"
        },
        {
          "comment": "",
          "lineNum": 11,
          "modifiers": "",
          "type": "float3",
          "name": "unity_BillboardTangent;",
          "code": "float3 unity_BillboardTangent;"
        },
        {
          "comment": "",
          "lineNum": 12,
          "modifiers": "",
          "type": "float4",
          "name": "unity_BillboardCameraParams;",
          "code": "float4 unity_BillboardCameraParams;"
        },
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "",
          "type": "float4",
          "name": "unity_BillboardInfo;",
          "code": "float4 unity_BillboardInfo; // x: num of billboard slices; y: 1.0f / (delta angle between slices)"
        },
        {
          "comment": "",
          "lineNum": 19,
          "modifiers": "",
          "type": "float4",
          "name": "unity_BillboardSize;",
          "code": "float4 unity_BillboardSize; // x: width; y: height; z: bottom"
        },
        {
          "comment": "",
          "lineNum": 20,
          "modifiers": "",
          "type": "float4",
          "name": "unity_BillboardImageTexCoords[16];",
          "code": "float4 unity_BillboardImageTexCoords[16];"
        }
      ]
    },
    {
      "file": "SpeedTreeCommon.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define SPEEDTREE_COMMON_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 6,
          "code": "#define SPEEDTREE_Y_UP"
        },
        {
          "comment": "",
          "lineNum": 9,
          "code": "    #define GEOM_TYPE_BRANCH"
        },
        {
          "comment": "",
          "lineNum": 27,
          "code": "#define mainTexUV interpolator1.xy"
        },
        {
          "comment": "",
          "lineNum": 31,
          "code": "    #define Detail interpolator2"
        },
        {
          "comment": "",
          "lineNum": 36,
          "code": "    #define SPEEDTREE_ALPHATEST"
        },
        {
          "comment": "",
          "lineNum": 41,
          "code": "    #define HueVariationAmount interpolator1.z"
        },
        {
          "comment": "",
          "lineNum": 82,
          "code": "    #define SPEEDTREE_DATA_NORMAL           fixed3 Normal;"
        },
        {
          "comment": "",
          "lineNum": 83,
          "code": "    #define SPEEDTREE_COPY_NORMAL(to, from) to.Normal = from.Normal;"
        },
        {
          "comment": "",
          "lineNum": 85,
          "code": "    #define SPEEDTREE_DATA_NORMAL"
        },
        {
          "comment": "",
          "lineNum": 86,
          "code": "    #define SPEEDTREE_COPY_NORMAL(to, from)"
        },
        {
          "comment": "",
          "lineNum": 89,
          "code": "#define SPEEDTREE_COPY_FRAG(to, from)   \\\n    to.Albedo = from.Albedo;            \\\n    to.Alpha = from.Alpha;              \\\n    SPEEDTREE_COPY_NORMAL(to, from)"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 53,
          "modifiers": "",
          "parameters": "inout SpeedTreeVB IN, out Input OUT",
          "type": "void",
          "name": "SpeedTreeVert",
          "code": "void SpeedTreeVert(inout SpeedTreeVB IN, out Input OUT)\n{\n    UNITY_INITIALIZE_OUTPUT(Input, OUT);\n\n    OUT.mainTexUV = IN.texcoord.xy;\n    OUT.color = _Color;\n    OUT.color.rgb *= IN.color.r; // ambient occlusion factor\n\n    #ifdef EFFECT_HUE_VARIATION\n        float hueVariationAmount = frac(unity_ObjectToWorld[0].w + unity_ObjectToWorld[1].w + unity_ObjectToWorld[2].w);\n        hueVariationAmount += frac(IN.vertex.x + IN.normal.y + IN.normal.x) * 0.5 - 0.3;\n        OUT.HueVariationAmount = saturate(hueVariationAmount * _HueVariation.a);\n    #endif\n\n    #ifdef GEOM_TYPE_BRANCH_DETAIL\n        // The two types are always in different sub-range of the mesh so no interpolation (between detail and blend) problem.\n        OUT.Detail.xy = IN.texcoord2.xy;\n        if (IN.color.a == 0) // Blend\n            OUT.Detail.z = IN.texcoord2.z;\n        else // Detail texture\n            OUT.Detail.z = 2.5f; // stay out of Blend's .z range\n    #endif\n\n    OffsetSpeedTreeVertex(IN, unity_LODFade.x);\n}"
        },
        {
          "comment": "",
          "lineNum": 101,
          "modifiers": "",
          "parameters": "Input IN, out SpeedTreeFragOut OUT",
          "type": "void",
          "name": "SpeedTreeFrag",
          "code": "void SpeedTreeFrag(Input IN, out SpeedTreeFragOut OUT)\n{\n    half4 diffuseColor = tex2D(_MainTex, IN.mainTexUV);\n\n    OUT.Alpha = diffuseColor.a * _Color.a;\n    #ifdef SPEEDTREE_ALPHATEST\n        clip(OUT.Alpha - _Cutoff);\n    #endif\n\n    #ifdef GEOM_TYPE_BRANCH_DETAIL\n        half4 detailColor = tex2D(_DetailTex, IN.Detail.xy);\n        diffuseColor.rgb = lerp(diffuseColor.rgb, detailColor.rgb, IN.Detail.z < 2.0f ? saturate(IN.Detail.z) : detailColor.a);\n    #endif\n\n    #ifdef EFFECT_HUE_VARIATION\n        half3 shiftedColor = lerp(diffuseColor.rgb, _HueVariation.rgb, IN.HueVariationAmount);\n        half maxBase = max(diffuseColor.r, max(diffuseColor.g, diffuseColor.b));\n        half newMaxBase = max(shiftedColor.r, max(shiftedColor.g, shiftedColor.b));\n        maxBase /= newMaxBase;\n        maxBase = maxBase * 0.5f + 0.5f;\n        // preserve vibrance\n        shiftedColor.rgb *= maxBase;\n        diffuseColor.rgb = saturate(shiftedColor);\n    #endif\n\n    OUT.Albedo = diffuseColor.rgb * IN.color.rgb;\n\n    #if defined(EFFECT_BUMP)\n        #if defined(LIGHTMAP_ON)\n            OUT.Normal = fixed3(0,0,1);\n        #else\n            OUT.Normal = UnpackNormal(tex2D(_BumpMap, IN.mainTexUV));\n            #ifdef GEOM_TYPE_BRANCH_DETAIL\n                half3 detailNormal = UnpackNormal(tex2D(_BumpMap, IN.Detail.xy));\n                OUT.Normal = lerp(OUT.Normal, detailNormal, IN.Detail.z < 2.0f ? saturate(IN.Detail.z) : detailColor.a);\n            #endif\n        #endif\n    #endif\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 16,
          "type": "struct",
          "name": "Input",
          "modifiers": "",
          "code": "struct Input\n{\n    fixed4 color;\n    half3 interpolator1;\n    #ifdef GEOM_TYPE_BRANCH_DETAIL\n        half3 interpolator2;\n    #endif\n};"
        },
        {
          "comment": "",
          "lineNum": 94,
          "type": "struct",
          "name": "SpeedTreeFragOut",
          "modifiers": "",
          "code": "struct SpeedTreeFragOut\n{\n    fixed3 Albedo;\n    fixed Alpha;\n    SPEEDTREE_DATA_NORMAL\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 28,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 32,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_DetailTex;",
          "code": "sampler2D _DetailTex;"
        },
        {
          "comment": "",
          "lineNum": 37,
          "modifiers": "",
          "type": "fixed",
          "name": "_Cutoff;",
          "code": "fixed _Cutoff;"
        },
        {
          "comment": "",
          "lineNum": 42,
          "modifiers": "",
          "type": "half4",
          "name": "_HueVariation;",
          "code": "half4 _HueVariation;"
        },
        {
          "comment": "",
          "lineNum": 46,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_BumpMap;",
          "code": "sampler2D _BumpMap;"
        },
        {
          "comment": "",
          "lineNum": 49,
          "modifiers": "",
          "type": "fixed4",
          "name": "_Color;",
          "code": "fixed4 _Color;"
        }
      ]
    },
    {
      "file": "SpeedTreeVertex.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define SPEEDTREE_VERTEX_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 36,
          "code": "#define WIND_QUALITY_NONE       0"
        },
        {
          "comment": "",
          "lineNum": 37,
          "code": "#define WIND_QUALITY_FASTEST    1"
        },
        {
          "comment": "",
          "lineNum": 38,
          "code": "#define WIND_QUALITY_FAST       2"
        },
        {
          "comment": "",
          "lineNum": 39,
          "code": "#define WIND_QUALITY_BETTER     3"
        },
        {
          "comment": "",
          "lineNum": 40,
          "code": "#define WIND_QUALITY_BEST       4"
        },
        {
          "comment": "",
          "lineNum": 41,
          "code": "#define WIND_QUALITY_PALM       5"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 53,
          "modifiers": "",
          "parameters": "inout SpeedTreeVB data, float lodValue",
          "type": "void",
          "name": "OffsetSpeedTreeVertex",
          "code": "void OffsetSpeedTreeVertex(inout SpeedTreeVB data, float lodValue)\n{\n    float3 finalPosition = data.vertex.xyz;\n\n    #ifdef ENABLE_WIND\n        half windQuality = _WindQuality * _WindEnabled;\n\n        float3 rotatedWindVector, rotatedBranchAnchor;\n        if (windQuality <= WIND_QUALITY_NONE)\n        {\n            rotatedWindVector = float3(0.0f, 0.0f, 0.0f);\n            rotatedBranchAnchor = float3(0.0f, 0.0f, 0.0f);\n        }\n        else\n        {\n            // compute rotated wind parameters\n            rotatedWindVector = normalize(mul(_ST_WindVector.xyz, (float3x3)unity_ObjectToWorld));\n            rotatedBranchAnchor = normalize(mul(_ST_WindBranchAnchor.xyz, (float3x3)unity_ObjectToWorld)) * _ST_WindBranchAnchor.w;\n        }\n    #endif\n\n    #if defined(GEOM_TYPE_BRANCH) || defined(GEOM_TYPE_FROND)\n\n        // smooth LOD\n        #ifdef LOD_FADE_PERCENTAGE\n            finalPosition = lerp(finalPosition, data.texcoord1.xyz, lodValue);\n        #endif\n\n        // frond wind, if needed\n        #if defined(ENABLE_WIND) && defined(GEOM_TYPE_FROND)\n            if (windQuality == WIND_QUALITY_PALM)\n                finalPosition = RippleFrond(finalPosition, data.normal, data.texcoord.x, data.texcoord.y, data.texcoord2.x, data.texcoord2.y, data.texcoord2.z);\n        #endif\n\n    #elif defined(GEOM_TYPE_LEAF)\n\n        // remove anchor position\n        finalPosition -= data.texcoord1.xyz;\n\n        bool isFacingLeaf = data.color.a == 0;\n        if (isFacingLeaf)\n        {\n            #ifdef LOD_FADE_PERCENTAGE\n                finalPosition *= lerp(1.0, data.texcoord1.w, lodValue);\n            #endif\n            // face camera-facing leaf to camera\n            float offsetLen = length(finalPosition);\n            finalPosition = mul(finalPosition.xyz, (float3x3)UNITY_MATRIX_IT_MV); // inv(MV) * finalPosition\n            finalPosition = normalize(finalPosition) * offsetLen; // make sure the offset vector is still scaled\n        }\n        else\n        {\n            #ifdef LOD_FADE_PERCENTAGE\n                float3 lodPosition = float3(data.texcoord1.w, data.texcoord3.x, data.texcoord3.y);\n                finalPosition = lerp(finalPosition, lodPosition, lodValue);\n            #endif\n        }\n\n        #ifdef ENABLE_WIND\n            // leaf wind\n            if (windQuality > WIND_QUALITY_FASTEST && windQuality < WIND_QUALITY_PALM)\n            {\n                float leafWindTrigOffset = data.texcoord1.x + data.texcoord1.y;\n                finalPosition = LeafWind(windQuality == WIND_QUALITY_BEST, data.texcoord2.w > 0.0, finalPosition, data.normal, data.texcoord2.x, float3(0,0,0), data.texcoord2.y, data.texcoord2.z, leafWindTrigOffset, rotatedWindVector);\n            }\n        #endif\n\n        // move back out to anchor\n        finalPosition += data.texcoord1.xyz;\n\n    #endif\n\n    #ifdef ENABLE_WIND\n        float3 treePos = float3(unity_ObjectToWorld[0].w, unity_ObjectToWorld[1].w, unity_ObjectToWorld[2].w);\n\n        #ifndef GEOM_TYPE_MESH\n            if (windQuality >= WIND_QUALITY_BETTER)\n            {\n                // branch wind (applies to all 3D geometry)\n                finalPosition = BranchWind(windQuality == WIND_QUALITY_PALM, finalPosition, treePos, float4(data.texcoord.zw, 0, 0), rotatedWindVector, rotatedBranchAnchor);\n            }\n        #endif\n\n        if (windQuality > WIND_QUALITY_NONE)\n        {\n            // global wind\n            finalPosition = GlobalWind(finalPosition, treePos, true, rotatedWindVector, _ST_WindGlobal.x);\n        }\n    #endif\n\n    data.vertex.xyz = finalPosition;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 17,
          "type": "struct",
          "name": "SpeedTreeVB",
          "modifiers": "",
          "code": "struct SpeedTreeVB\n{\n    float4 vertex       : POSITION;\n    float4 tangent      : TANGENT;\n    float3 normal       : NORMAL;\n    float4 texcoord     : TEXCOORD0;\n    float4 texcoord1    : TEXCOORD1;\n    float4 texcoord2    : TEXCOORD2;\n    float2 texcoord3    : TEXCOORD3;\n    half4 color         : COLOR;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 43,
          "modifiers": "uniform",
          "type": "half",
          "name": "_WindQuality;",
          "code": "uniform half _WindQuality;"
        },
        {
          "comment": "",
          "lineNum": 44,
          "modifiers": "uniform",
          "type": "half",
          "name": "_WindEnabled;",
          "code": "uniform half _WindEnabled;"
        }
      ]
    },
    {
      "file": "SpeedTreeWind.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define SPEEDTREE_WIND_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 119,
          "code": "#define wind_cross(a, b) cross((a), (b))"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 30,
          "modifiers": "",
          "parameters": "float fValue",
          "type": "float3",
          "name": "UnpackNormalFromFloat",
          "code": "float3 UnpackNormalFromFloat(float fValue)\n{\n    float3 vDecodeKey = float3(16.0, 1.0, 0.0625);\n\n    // decode into [0,1] range\n    float3 vDecodedValue = frac(fValue / vDecodeKey);\n\n    // move back into [-1,1] range & normalize\n    return (vDecodedValue * 2.0 - 1.0);\n}"
        },
        {
          "comment": "",
          "lineNum": 45,
          "modifiers": "",
          "parameters": "float4 vData",
          "type": "float4",
          "name": "CubicSmooth",
          "code": "float4 CubicSmooth(float4 vData)\n{\n    return vData * vData * (3.0 - 2.0 * vData);\n}"
        },
        {
          "comment": "",
          "lineNum": 54,
          "modifiers": "",
          "parameters": "float4 vData",
          "type": "float4",
          "name": "TriangleWave",
          "code": "float4 TriangleWave(float4 vData)\n{\n    return abs((frac(vData + 0.5) * 2.0) - 1.0);\n}"
        },
        {
          "comment": "",
          "lineNum": 63,
          "modifiers": "",
          "parameters": "float4 vData",
          "type": "float4",
          "name": "TrigApproximate",
          "code": "float4 TrigApproximate(float4 vData)\n{\n    return (CubicSmooth(TriangleWave(vData)) - 0.5) * 2.0;\n}"
        },
        {
          "comment": "",
          "lineNum": 74,
          "modifiers": "",
          "parameters": "float3 vAxis, float fAngle",
          "type": "float3x3",
          "name": "RotationMatrix",
          "code": "float3x3 RotationMatrix(float3 vAxis, float fAngle)\n{\n    // compute sin/cos of fAngle\n    float2 vSinCos;\n    #ifdef OPENGL\n        vSinCos.x = sin(fAngle);\n        vSinCos.y = cos(fAngle);\n    #else\n        sincos(fAngle, vSinCos.x, vSinCos.y);\n    #endif\n\n    const float c = vSinCos.y;\n    const float s = vSinCos.x;\n    const float t = 1.0 - c;\n    const float x = vAxis.x;\n    const float y = vAxis.y;\n    const float z = vAxis.z;\n\n    return float3x3(t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n                    t * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n                    t * x * z - s * y,  t * y * z + s * x,  t * z * z + c);\n}"
        },
        {
          "comment": "",
          "lineNum": 101,
          "modifiers": "mul__",
          "parameters": "float3x3 mMatrixA, float3x3 mMatrixB",
          "type": "float3x3",
          "name": "mul_float3x3_float3x3",
          "code": "float3x3 mul_float3x3_float3x3(float3x3 mMatrixA, float3x3 mMatrixB)\n{\n    return mul(mMatrixA, mMatrixB);\n}"
        },
        {
          "comment": "",
          "lineNum": 110,
          "modifiers": "mul_x3_",
          "parameters": "float3x3 mMatrix, float3 vVector",
          "type": "float3",
          "name": "mul_float3x3_float3",
          "code": "float3 mul_float3x3_float3(float3x3 mMatrix, float3 vVector)\n{\n    return mul(mMatrix, vVector);\n}"
        },
        {
          "comment": "",
          "lineNum": 125,
          "modifiers": "",
          "parameters": "float fCurrent,           float fMaxScale,           float fMinScale,           float fSpeed,           float fRipple,           float3 vPos,           float fTime,           float3 vRotatedWindVector",
          "type": "float",
          "name": "Roll",
          "code": "float Roll(float fCurrent,\n           float fMaxScale,\n           float fMinScale,\n           float fSpeed,\n           float fRipple,\n           float3 vPos,\n           float fTime,\n           float3 vRotatedWindVector)\n{\n    float fWindAngle = dot(vPos, -vRotatedWindVector) * fRipple;\n    float fAdjust = TrigApproximate(float4(fWindAngle + fTime * fSpeed, 0.0, 0.0, 0.0)).x;\n    fAdjust = (fAdjust + 1.0) * 0.5;\n\n    return lerp(fCurrent * fMinScale, fCurrent * fMaxScale, fAdjust);\n}"
        },
        {
          "comment": "",
          "lineNum": 145,
          "modifiers": "",
          "parameters": "float3 vPos, float fAmount, float fSharpness, float fTime",
          "type": "float",
          "name": "Twitch",
          "code": "float Twitch(float3 vPos, float fAmount, float fSharpness, float fTime)\n{\n    const float c_fTwitchFudge = 0.87;\n    float4 vOscillations = TrigApproximate(float4(fTime + (vPos.x + vPos.z), c_fTwitchFudge * fTime + vPos.y, 0.0, 0.0));\n\n    //float fTwitch = sin(fFreq1 * fTime + (vPos.x + vPos.z)) * cos(fFreq2 * fTime + vPos.y);\n    float fTwitch = vOscillations.x * vOscillations.y * vOscillations.y;\n    fTwitch = (fTwitch + 1.0) * 0.5;\n\n    return fAmount * pow(saturate(fTwitch), fSharpness);\n}"
        },
        {
          "comment": "",
          "lineNum": 165,
          "modifiers": "",
          "parameters": "float3 vPos,                float fTime,                float fOffset,                float fWeight,                float fWhip,                bool bWhip,                bool bRoll,                bool bComplex,                float fTwitch,                float fTwitchFreqScale,                inout float4 vOscillations,                float3 vRotatedWindVector",
          "type": "float",
          "name": "Oscillate",
          "code": "float Oscillate(float3 vPos,\n                float fTime,\n                float fOffset,\n                float fWeight,\n                float fWhip,\n                bool bWhip,\n                bool bRoll,\n                bool bComplex,\n                float fTwitch,\n                float fTwitchFreqScale,\n                inout float4 vOscillations,\n                float3 vRotatedWindVector)\n{\n    float fOscillation = 1.0;\n    if (bComplex)\n    {\n        if (bWhip)\n            vOscillations = TrigApproximate(float4(fTime + fOffset, fTime * fTwitchFreqScale + fOffset, fTwitchFreqScale * 0.5 * (fTime + fOffset), fTime + fOffset + (1.0 - fWeight)));\n        else\n            vOscillations = TrigApproximate(float4(fTime + fOffset, fTime * fTwitchFreqScale + fOffset, fTwitchFreqScale * 0.5 * (fTime + fOffset), 0.0));\n\n        float fFineDetail = vOscillations.x;\n        float fBroadDetail = vOscillations.y * vOscillations.z;\n\n        float fTarget = 1.0;\n        float fAmount = fBroadDetail;\n        if (fBroadDetail < 0.0)\n        {\n            fTarget = -fTarget;\n            fAmount = -fAmount;\n        }\n\n        fBroadDetail = lerp(fBroadDetail, fTarget, fAmount);\n        fBroadDetail = lerp(fBroadDetail, fTarget, fAmount);\n\n        fOscillation = fBroadDetail * fTwitch * (1.0 - _ST_WindVector.w) + fFineDetail * (1.0 - fTwitch);\n\n        if (bWhip)\n            fOscillation *= 1.0 + (vOscillations.w * fWhip);\n    }\n    else\n    {\n        if (bWhip)\n            vOscillations = TrigApproximate(float4(fTime + fOffset, fTime * 0.689 + fOffset, 0.0, fTime + fOffset + (1.0 - fWeight)));\n        else\n            vOscillations = TrigApproximate(float4(fTime + fOffset, fTime * 0.689 + fOffset, 0.0, 0.0));\n\n        fOscillation = vOscillations.x + vOscillations.y * vOscillations.x;\n\n        if (bWhip)\n            fOscillation *= 1.0 + (vOscillations.w * fWhip);\n    }\n\n    //if (bRoll)\n    //{\n    //  fOscillation = Roll(fOscillation, _ST_WindRollingBranches.x, _ST_WindRollingBranches.y, _ST_WindRollingBranches.z, _ST_WindRollingBranches.w, vPos.xyz, fTime + fOffset, vRotatedWindVector);\n    //}\n\n    return fOscillation;\n}"
        },
        {
          "comment": "",
          "lineNum": 230,
          "modifiers": "",
          "parameters": "float fTime, float fOffset, float fGlobalTime, float fTurbulence",
          "type": "float",
          "name": "Turbulence",
          "code": "float Turbulence(float fTime, float fOffset, float fGlobalTime, float fTurbulence)\n{\n    const float c_fTurbulenceFactor = 0.1;\n\n    float4 vOscillations = TrigApproximate(float4(fTime * c_fTurbulenceFactor + fOffset, fGlobalTime * fTurbulence * c_fTurbulenceFactor + fOffset, 0.0, 0.0));\n\n    return 1.0 - (vOscillations.x * vOscillations.y * vOscillations.x * vOscillations.y * fTurbulence);\n}"
        },
        {
          "comment": "",
          "lineNum": 246,
          "modifiers": "",
          "parameters": "float3 vPos, float3 vInstancePos, bool bPreserveShape, float3 vRotatedWindVector, float time",
          "type": "float3",
          "name": "GlobalWind",
          "code": "float3 GlobalWind(float3 vPos, float3 vInstancePos, bool bPreserveShape, float3 vRotatedWindVector, float time)\n{\n    // WIND_LOD_GLOBAL may be on, but if the global wind effect (WIND_EFFECT_GLOBAL_ST_Wind)\n    // was disabled for the tree in the Modeler, we should skip it\n\n    float fLength = 1.0;\n    if (bPreserveShape)\n        fLength = length(vPos.xyz);\n\n    // compute how much the height contributes\n    #ifdef SPEEDTREE_Z_UP\n        float fAdjust = max(vPos.z - (1.0 / _ST_WindGlobal.z) * 0.25, 0.0) * _ST_WindGlobal.z;\n    #else\n        float fAdjust = max(vPos.y - (1.0 / _ST_WindGlobal.z) * 0.25, 0.0) * _ST_WindGlobal.z;\n    #endif\n    if (fAdjust != 0.0)\n        fAdjust = pow(fAdjust, _ST_WindGlobal.w);\n\n    // primary oscillation\n    float4 vOscillations = TrigApproximate(float4(vInstancePos.x + time, vInstancePos.y + time * 0.8, 0.0, 0.0));\n    float fOsc = vOscillations.x + (vOscillations.y * vOscillations.y);\n    float fMoveAmount = _ST_WindGlobal.y * fOsc;\n\n    // move a minimum amount based on direction adherence\n    fMoveAmount += _ST_WindBranchAdherences.x / _ST_WindGlobal.z;\n\n    // adjust based on how high up the tree this vertex is\n    fMoveAmount *= fAdjust;\n\n    // xy component\n    #ifdef SPEEDTREE_Z_UP\n        vPos.xy += vRotatedWindVector.xy * fMoveAmount;\n    #else\n        vPos.xz += vRotatedWindVector.xz * fMoveAmount;\n    #endif\n\n    if (bPreserveShape)\n        vPos.xyz = normalize(vPos.xyz) * fLength;\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 292,
          "modifiers": "",
          "parameters": "float3 vPos,                        float3 vInstancePos,                        float fWeight,                        float fOffset,                        float fTime,                        float fDistance,                        float fTwitch,                        float fTwitchScale,                        float fWhip,                        bool bWhip,                        bool bRoll,                        bool bComplex,                        float3 vRotatedWindVector",
          "type": "float3",
          "name": "SimpleBranchWind",
          "code": "float3 SimpleBranchWind(float3 vPos,\n                        float3 vInstancePos,\n                        float fWeight,\n                        float fOffset,\n                        float fTime,\n                        float fDistance,\n                        float fTwitch,\n                        float fTwitchScale,\n                        float fWhip,\n                        bool bWhip,\n                        bool bRoll,\n                        bool bComplex,\n                        float3 vRotatedWindVector)\n{\n    // turn the offset back into a nearly normalized vector\n    float3 vWindVector = UnpackNormalFromFloat(fOffset);\n    vWindVector = vWindVector * fWeight;\n\n    // try to fudge time a bit so that instances aren't in sync\n    fTime += vInstancePos.x + vInstancePos.y;\n\n    // oscillate\n    float4 vOscillations;\n    float fOsc = Oscillate(vPos, fTime, fOffset, fWeight, fWhip, bWhip, bRoll, bComplex, fTwitch, fTwitchScale, vOscillations, vRotatedWindVector);\n\n    vPos.xyz += vWindVector * fOsc * fDistance;\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 326,
          "modifiers": "",
          "parameters": "float3 vPos,                             float3 vInstancePos,                             float fWeight,                             float fOffset,                             float fTime,                             float fDistance,                             float fTurbulence,                             float fAdherence,                             float fTwitch,                             float fTwitchScale,                             float fWhip,                             bool bWhip,                             bool bRoll,                             bool bComplex,                             bool bTurbulence,                             float3 vRotatedWindVector",
          "type": "float3",
          "name": "DirectionalBranchWind",
          "code": "float3 DirectionalBranchWind(float3 vPos,\n                             float3 vInstancePos,\n                             float fWeight,\n                             float fOffset,\n                             float fTime,\n                             float fDistance,\n                             float fTurbulence,\n                             float fAdherence,\n                             float fTwitch,\n                             float fTwitchScale,\n                             float fWhip,\n                             bool bWhip,\n                             bool bRoll,\n                             bool bComplex,\n                             bool bTurbulence,\n                             float3 vRotatedWindVector)\n{\n    // turn the offset back into a nearly normalized vector\n    float3 vWindVector = UnpackNormalFromFloat(fOffset);\n    vWindVector = vWindVector * fWeight;\n\n    // try to fudge time a bit so that instances aren't in sync\n    fTime += vInstancePos.x + vInstancePos.y;\n\n    // oscillate\n    float4 vOscillations;\n    float fOsc = Oscillate(vPos, fTime, fOffset, fWeight, fWhip, bWhip, false, bComplex, fTwitch, fTwitchScale, vOscillations, vRotatedWindVector);\n\n    vPos.xyz += vWindVector * fOsc * fDistance;\n\n    // add in the direction, accounting for turbulence\n    float fAdherenceScale = 1.0;\n    if (bTurbulence)\n        fAdherenceScale = Turbulence(fTime, fOffset, _ST_WindAnimation.x, fTurbulence);\n\n    if (bWhip)\n        fAdherenceScale += vOscillations.w * _ST_WindVector.w * fWhip;\n\n    //if (bRoll)\n    //  fAdherenceScale = Roll(fAdherenceScale, _ST_WindRollingBranches.x, _ST_WindRollingBranches.y, _ST_WindRollingBranches.z, _ST_WindRollingBranches.w, vPos.xyz, fTime + fOffset, vRotatedWindVector);\n\n    vPos.xyz += vRotatedWindVector * fAdherence * fAdherenceScale * fWeight;\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 376,
          "modifiers": "",
          "parameters": "float3 vPos,                                       float3 vInstancePos,                                       float fWeight,                                       float fOffset,                                       float fTime,                                       float fDistance,                                       float fTurbulence,                                       float fAdherence,                                       float fTwitch,                                       float fTwitchScale,                                       float fWhip,                                       bool bWhip,                                       bool bRoll,                                       bool bComplex,                                       bool bTurbulence,                                       float3 vRotatedWindVector,                                       float3 vRotatedBranchAnchor",
          "type": "float3",
          "name": "DirectionalBranchWindFrondStyle",
          "code": "float3 DirectionalBranchWindFrondStyle(float3 vPos,\n                                       float3 vInstancePos,\n                                       float fWeight,\n                                       float fOffset,\n                                       float fTime,\n                                       float fDistance,\n                                       float fTurbulence,\n                                       float fAdherence,\n                                       float fTwitch,\n                                       float fTwitchScale,\n                                       float fWhip,\n                                       bool bWhip,\n                                       bool bRoll,\n                                       bool bComplex,\n                                       bool bTurbulence,\n                                       float3 vRotatedWindVector,\n                                       float3 vRotatedBranchAnchor)\n{\n    // turn the offset back into a nearly normalized vector\n    float3 vWindVector = UnpackNormalFromFloat(fOffset);\n    vWindVector = vWindVector * fWeight;\n\n    // try to fudge time a bit so that instances aren't in sync\n    fTime += vInstancePos.x + vInstancePos.y;\n\n    // oscillate\n    float4 vOscillations;\n    float fOsc = Oscillate(vPos, fTime, fOffset, fWeight, fWhip, bWhip, false, bComplex, fTwitch, fTwitchScale, vOscillations, vRotatedWindVector);\n\n    vPos.xyz += vWindVector * fOsc * fDistance;\n\n    // add in the direction, accounting for turbulence\n    float fAdherenceScale = 1.0;\n    if (bTurbulence)\n        fAdherenceScale = Turbulence(fTime, fOffset, _ST_WindAnimation.x, fTurbulence);\n\n    //if (bRoll)\n    //  fAdherenceScale = Roll(fAdherenceScale, _ST_WindRollingBranches.x, _ST_WindRollingBranches.y, _ST_WindRollingBranches.z, _ST_WindRollingBranches.w, vPos.xyz, fTime + fOffset, vRotatedWindVector);\n\n    if (bWhip)\n        fAdherenceScale += vOscillations.w * _ST_WindVector.w * fWhip;\n\n    float3 vWindAdherenceVector = vRotatedBranchAnchor - vPos.xyz;\n    vPos.xyz += vWindAdherenceVector * fAdherence * fAdherenceScale * fWeight;\n\n    return vPos;\n}"
        },
        {
          "comment": "// Apply only to better, best, palm winds",
          "lineNum": 429,
          "modifiers": "",
          "parameters": "bool isPalmWind, float3 vPos, float3 vInstancePos, float4 vWindData, float3 vRotatedWindVector, float3 vRotatedBranchAnchor",
          "type": "float3",
          "name": "BranchWind",
          "code": "float3 BranchWind(bool isPalmWind, float3 vPos, float3 vInstancePos, float4 vWindData, float3 vRotatedWindVector, float3 vRotatedBranchAnchor)\n{\n    if (isPalmWind)\n    {\n        vPos = DirectionalBranchWindFrondStyle(vPos, vInstancePos, vWindData.x, vWindData.y, _ST_WindBranch.x, _ST_WindBranch.y, _ST_WindTurbulences.x, _ST_WindBranchAdherences.y, _ST_WindBranchTwitch.x, _ST_WindBranchTwitch.y, _ST_WindBranchWhip.x, true, false, true, true, vRotatedWindVector, vRotatedBranchAnchor);\n    }\n    else\n    {\n        vPos = SimpleBranchWind(vPos, vInstancePos, vWindData.x, vWindData.y, _ST_WindBranch.x, _ST_WindBranch.y, _ST_WindBranchTwitch.x, _ST_WindBranchTwitch.y, _ST_WindBranchWhip.x, false, false, true, vRotatedWindVector);\n    }\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 447,
          "modifiers": "",
          "parameters": "float3 vPos,                  inout float3 vDirection,                  float fScale,                  float fPackedRippleDir,                  float fTime,                  float fAmount,                  bool bDirectional,                  float fTrigOffset",
          "type": "float3",
          "name": "LeafRipple",
          "code": "float3 LeafRipple(float3 vPos,\n                  inout float3 vDirection,\n                  float fScale,\n                  float fPackedRippleDir,\n                  float fTime,\n                  float fAmount,\n                  bool bDirectional,\n                  float fTrigOffset)\n{\n    // compute how much to move\n    float4 vInput = float4(fTime + fTrigOffset, 0.0, 0.0, 0.0);\n    float fMoveAmount = fAmount * TrigApproximate(vInput).x;\n\n    if (bDirectional)\n    {\n        vPos.xyz += vDirection.xyz * fMoveAmount * fScale;\n    }\n    else\n    {\n        float3 vRippleDir = UnpackNormalFromFloat(fPackedRippleDir);\n        vPos.xyz += vRippleDir * fMoveAmount * fScale;\n    }\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 477,
          "modifiers": "",
          "parameters": "float3 vPos,                  inout float3 vDirection,                  float fScale,                  float3 vAnchor,                  float3 vGrowthDir,                  float fTrigOffset,                  float fTime,                  float fFlip,                  float fTwist,                  float fAdherence,                  float3 vTwitch,                  float4 vRoll,                  bool bTwitch,                  bool bRoll,                  float3 vRotatedWindVector",
          "type": "float3",
          "name": "LeafTumble",
          "code": "float3 LeafTumble(float3 vPos,\n                  inout float3 vDirection,\n                  float fScale,\n                  float3 vAnchor,\n                  float3 vGrowthDir,\n                  float fTrigOffset,\n                  float fTime,\n                  float fFlip,\n                  float fTwist,\n                  float fAdherence,\n                  float3 vTwitch,\n                  float4 vRoll,\n                  bool bTwitch,\n                  bool bRoll,\n                  float3 vRotatedWindVector)\n{\n    // compute all oscillations up front\n    float3 vFracs = frac((vAnchor + fTrigOffset) * 30.3);\n    float fOffset = vFracs.x + vFracs.y + vFracs.z;\n    float4 vOscillations = TrigApproximate(float4(fTime + fOffset, fTime * 0.75 - fOffset, fTime * 0.01 + fOffset, fTime * 1.0 + fOffset));\n\n    // move to the origin and get the growth direction\n    float3 vOriginPos = vPos.xyz - vAnchor;\n    float fLength = length(vOriginPos);\n\n    // twist\n    float fOsc = vOscillations.x + vOscillations.y * vOscillations.y;\n    float3x3 matTumble = RotationMatrix(vGrowthDir, fScale * fTwist * fOsc);\n\n    // with wind\n    float3 vAxis = wind_cross(vGrowthDir, vRotatedWindVector);\n    float fDot = clamp(dot(vRotatedWindVector, vGrowthDir), -1.0, 1.0);\n    #ifdef SPEEDTREE_Z_UP\n        vAxis.z += fDot;\n    #else\n        vAxis.y += fDot;\n    #endif\n    vAxis = normalize(vAxis);\n\n    float fAngle = acos(fDot);\n\n    float fAdherenceScale = 1.0;\n    //if (bRoll)\n    //{\n    //  fAdherenceScale = Roll(fAdherenceScale, vRoll.x, vRoll.y, vRoll.z, vRoll.w, vAnchor.xyz, fTime, vRotatedWindVector);\n    //}\n\n    fOsc = vOscillations.y - vOscillations.x * vOscillations.x;\n\n    float fTwitch = 0.0;\n    if (bTwitch)\n        fTwitch = Twitch(vAnchor.xyz, vTwitch.x, vTwitch.y, vTwitch.z + fOffset);\n\n    matTumble = mul_float3x3_float3x3(matTumble, RotationMatrix(vAxis, fScale * (fAngle * fAdherence * fAdherenceScale + fOsc * fFlip + fTwitch)));\n\n    vDirection = mul_float3x3_float3(matTumble, vDirection);\n    vOriginPos = mul_float3x3_float3(matTumble, vOriginPos);\n\n    vOriginPos = normalize(vOriginPos) * fLength;\n\n    return (vOriginPos + vAnchor);\n}"
        },
        {
          "comment": "",
          "lineNum": 545,
          "modifiers": "",
          "parameters": "bool isBestWind,                bool bLeaf2,                float3 vPos,                inout float3 vDirection,                float fScale,                float3 vAnchor,                float fPackedGrowthDir,                float fPackedRippleDir,                float fRippleTrigOffset,                float3 vRotatedWindVector",
          "type": "float3",
          "name": "LeafWind",
          "code": "float3 LeafWind(bool isBestWind,\n                bool bLeaf2,\n                float3 vPos,\n                inout float3 vDirection,\n                float fScale,\n                float3 vAnchor,\n                float fPackedGrowthDir,\n                float fPackedRippleDir,\n                float fRippleTrigOffset,\n                float3 vRotatedWindVector)\n{\n\n    vPos = LeafRipple(vPos, vDirection, fScale, fPackedRippleDir,\n                            (bLeaf2 ? _ST_WindLeaf2Ripple.x : _ST_WindLeaf1Ripple.x),\n                            (bLeaf2 ? _ST_WindLeaf2Ripple.y : _ST_WindLeaf1Ripple.y),\n                            false, fRippleTrigOffset);\n\n    if (isBestWind)\n    {\n        float3 vGrowthDir = UnpackNormalFromFloat(fPackedGrowthDir);\n        vPos = LeafTumble(vPos, vDirection, fScale, vAnchor, vGrowthDir, fPackedGrowthDir,\n                          (bLeaf2 ? _ST_WindLeaf2Tumble.x : _ST_WindLeaf1Tumble.x),\n                          (bLeaf2 ? _ST_WindLeaf2Tumble.y : _ST_WindLeaf1Tumble.y),\n                          (bLeaf2 ? _ST_WindLeaf2Tumble.z : _ST_WindLeaf1Tumble.z),\n                          (bLeaf2 ? _ST_WindLeaf2Tumble.w : _ST_WindLeaf1Tumble.w),\n                          (bLeaf2 ? _ST_WindLeaf2Twitch.xyz : _ST_WindLeaf1Twitch.xyz),\n                          0.0f,\n                          (bLeaf2 ? true : true),\n                          (bLeaf2 ? true : true),\n                          vRotatedWindVector);\n    }\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 584,
          "modifiers": "",
          "parameters": "float3 vPos,                           inout float3 vDirection,                           float fU,                           float fV,                           float fRippleScale#ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING                           , float3 vBinormal                           , float3 vTangent#endif",
          "type": "float3",
          "name": "RippleFrondOneSided",
          "code": "float3 RippleFrondOneSided(float3 vPos,\n                           inout float3 vDirection,\n                           float fU,\n                           float fV,\n                           float fRippleScale\n#ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING\n                           , float3 vBinormal\n                           , float3 vTangent\n#endif\n                           )\n{\n    float fOffset = 0.0;\n    if (fU < 0.5)\n        fOffset = 0.75;\n\n    float4 vOscillations = TrigApproximate(float4((_ST_WindFrondRipple.x + fV) * _ST_WindFrondRipple.z + fOffset, 0.0, 0.0, 0.0));\n\n    float fAmount = fRippleScale * vOscillations.x * _ST_WindFrondRipple.y;\n    float3 vOffset = fAmount * vDirection;\n    vPos.xyz += vOffset;\n\n    #ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING\n        vTangent.xyz = normalize(vTangent.xyz + vOffset * _ST_WindFrondRipple.w);\n        float3 vNewNormal = normalize(wind_cross(vBinormal.xyz, vTangent.xyz));\n        if (dot(vNewNormal, vDirection.xyz) < 0.0)\n            vNewNormal = -vNewNormal;\n        vDirection.xyz = vNewNormal;\n    #endif\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 619,
          "modifiers": "",
          "parameters": "float3 vPos,                           inout float3 vDirection,                           float fU,                           float fLengthPercent,                           float fPackedRippleDir,                           float fRippleScale#ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING                           , float3 vBinormal                           , float3 vTangent#endif",
          "type": "float3",
          "name": "RippleFrondTwoSided",
          "code": "float3 RippleFrondTwoSided(float3 vPos,\n                           inout float3 vDirection,\n                           float fU,\n                           float fLengthPercent,\n                           float fPackedRippleDir,\n                           float fRippleScale\n#ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING\n                           , float3 vBinormal\n                           , float3 vTangent\n#endif\n                           )\n{\n    float4 vOscillations = TrigApproximate(float4(_ST_WindFrondRipple.x * fLengthPercent * _ST_WindFrondRipple.z, 0.0, 0.0, 0.0));\n\n    float3 vRippleDir = UnpackNormalFromFloat(fPackedRippleDir);\n\n    float fAmount = fRippleScale * vOscillations.x * _ST_WindFrondRipple.y;\n    float3 vOffset = fAmount * vRippleDir;\n\n    vPos.xyz += vOffset;\n\n    #ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING\n        vTangent.xyz = normalize(vTangent.xyz + vOffset * _ST_WindFrondRipple.w);\n        float3 vNewNormal = normalize(wind_cross(vBinormal.xyz, vTangent.xyz));\n        if (dot(vNewNormal, vDirection.xyz) < 0.0)\n            vNewNormal = -vNewNormal;\n        vDirection.xyz = vNewNormal;\n    #endif\n\n    return vPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 655,
          "modifiers": "",
          "parameters": "float3 vPos,                   inout float3 vDirection,                   float fU,                   float fV,                   float fPackedRippleDir,                   float fRippleScale,                   float fLenghtPercent                #ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING                   , float3 vBinormal                   , float3 vTangent                #endif",
          "type": "float3",
          "name": "RippleFrond",
          "code": "float3 RippleFrond(float3 vPos,\n                   inout float3 vDirection,\n                   float fU,\n                   float fV,\n                   float fPackedRippleDir,\n                   float fRippleScale,\n                   float fLenghtPercent\n                #ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING\n                   , float3 vBinormal\n                   , float3 vTangent\n                #endif\n                   )\n{\n    return RippleFrondOneSided(vPos,\n                                vDirection,\n                                fU,\n                                fV,\n                                fRippleScale\n                            #ifdef WIND_EFFECT_FROND_RIPPLE_ADJUST_LIGHTING\n                                , vBinormal\n                                , vTangent\n                            #endif\n                                );\n}"
        }
      ],
      "structs": [],
      "variables": [
        {
          "comment": "",
          "lineNum": 8,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindVector;",
          "code": "float4 _ST_WindVector;"
        },
        {
          "comment": "",
          "lineNum": 9,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindGlobal;",
          "code": "float4 _ST_WindGlobal;"
        },
        {
          "comment": "",
          "lineNum": 10,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindBranch;",
          "code": "float4 _ST_WindBranch;"
        },
        {
          "comment": "",
          "lineNum": 11,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindBranchTwitch;",
          "code": "float4 _ST_WindBranchTwitch;"
        },
        {
          "comment": "",
          "lineNum": 12,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindBranchWhip;",
          "code": "float4 _ST_WindBranchWhip;"
        },
        {
          "comment": "",
          "lineNum": 13,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindBranchAnchor;",
          "code": "float4 _ST_WindBranchAnchor;"
        },
        {
          "comment": "",
          "lineNum": 14,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindBranchAdherences;",
          "code": "float4 _ST_WindBranchAdherences;"
        },
        {
          "comment": "",
          "lineNum": 15,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindTurbulences;",
          "code": "float4 _ST_WindTurbulences;"
        },
        {
          "comment": "",
          "lineNum": 16,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindLeaf1Ripple;",
          "code": "float4 _ST_WindLeaf1Ripple;"
        },
        {
          "comment": "",
          "lineNum": 17,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindLeaf1Tumble;",
          "code": "float4 _ST_WindLeaf1Tumble;"
        },
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindLeaf1Twitch;",
          "code": "float4 _ST_WindLeaf1Twitch;"
        },
        {
          "comment": "",
          "lineNum": 19,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindLeaf2Ripple;",
          "code": "float4 _ST_WindLeaf2Ripple;"
        },
        {
          "comment": "",
          "lineNum": 20,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindLeaf2Tumble;",
          "code": "float4 _ST_WindLeaf2Tumble;"
        },
        {
          "comment": "",
          "lineNum": 21,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindLeaf2Twitch;",
          "code": "float4 _ST_WindLeaf2Twitch;"
        },
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindFrondRipple;",
          "code": "float4 _ST_WindFrondRipple;"
        },
        {
          "comment": "",
          "lineNum": 23,
          "modifiers": "",
          "type": "float4",
          "name": "_ST_WindAnimation;",
          "code": "float4 _ST_WindAnimation;"
        }
      ]
    },
    {
      "file": "TerrainEngine.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define TERRAIN_ENGINE_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "// Calculate a 4 fast sine-cosine pairs\n// val:     the 4 input values - each must be in the range (0 to 1)\n// s:       The sine of each of the 4 values\n// c:       The cosine of each of the 4 values",
          "lineNum": 54,
          "modifiers": "",
          "parameters": "float4 val, out float4 s, out float4 c",
          "type": "void",
          "name": "FastSinCos",
          "code": "void FastSinCos (float4 val, out float4 s, out float4 c) {\n    val = val * 6.408849 - 3.1415927;\n    // powers for taylor series\n    float4 r5 = val * val;                  // wavevec ^ 2\n    float4 r6 = r5 * r5;                        // wavevec ^ 4;\n    float4 r7 = r6 * r5;                        // wavevec ^ 6;\n    float4 r8 = r6 * r5;                        // wavevec ^ 8;\n\n    float4 r1 = r5 * val;                   // wavevec ^ 3\n    float4 r2 = r1 * r5;                        // wavevec ^ 5;\n    float4 r3 = r2 * r5;                        // wavevec ^ 7;\n\n\n    //Vectors for taylor's series expansion of sin and cos\n    float4 sin7 = {1, -0.16161616, 0.0083333, -0.00019841};\n    float4 cos8  = {-0.5, 0.041666666, -0.0013888889, 0.000024801587};\n\n    // sin\n    s =  val + r1 * sin7.y + r2 * sin7.z + r3 * sin7.w;\n\n    // cos\n    c = 1 + r5 * cos8.x + r6 * cos8.y + r7 * cos8.z + r8 * cos8.w;\n}"
        },
        {
          "comment": "",
          "lineNum": 78,
          "modifiers": "",
          "parameters": "inout float4 vertex, float waveAmount, fixed4 color",
          "type": "fixed4",
          "name": "TerrainWaveGrass",
          "code": "fixed4 TerrainWaveGrass (inout float4 vertex, float waveAmount, fixed4 color)\n{\n    float4 _waveXSize = float4(0.012, 0.02, 0.06, 0.024) * _WaveAndDistance.y;\n    float4 _waveZSize = float4 (0.006, .02, 0.02, 0.05) * _WaveAndDistance.y;\n    float4 waveSpeed = float4 (0.3, .5, .4, 1.2) * 4;\n\n    float4 _waveXmove = float4(0.012, 0.02, -0.06, 0.048) * 2;\n    float4 _waveZmove = float4 (0.006, .02, -0.02, 0.1);\n\n    float4 waves;\n    waves = vertex.x * _waveXSize;\n    waves += vertex.z * _waveZSize;\n\n    // Add in time to model them over time\n    waves += _WaveAndDistance.x * waveSpeed;\n\n    float4 s, c;\n    waves = frac (waves);\n    FastSinCos (waves, s,c);\n\n    s = s * s;\n\n    s = s * s;\n\n    float lighting = dot (s, normalize (float4 (1,1,.4,.2))) * .7;\n\n    s = s * waveAmount;\n\n    float3 waveMove = float3 (0,0,0);\n    waveMove.x = dot (s, _waveXmove);\n    waveMove.z = dot (s, _waveZmove);\n\n    vertex.xz -= waveMove.xz * _WaveAndDistance.z;\n\n    // apply color animation\n\n    // fix for dx11/etc warning\n    fixed3 waveColor = lerp (fixed3(0.5,0.5,0.5), _WavingTint.rgb, fixed3(lighting,lighting,lighting));\n\n    // Fade the grass out before detail distance.\n    // Saturate because Radeon HD drivers on OS X 10.4.10 don't saturate vertex colors properly.\n    float3 offset = vertex.xyz - _CameraPosition.xyz;\n    color.a = saturate (2 * (_WaveAndDistance.w - dot (offset, offset)) * _CameraPosition.w);\n\n    return fixed4(2 * waveColor * color.rgb, color.a);\n}"
        },
        {
          "comment": "",
          "lineNum": 125,
          "modifiers": "",
          "parameters": "inout float4 pos, float2 offset",
          "type": "void",
          "name": "TerrainBillboardGrass",
          "code": "void TerrainBillboardGrass( inout float4 pos, float2 offset )\n{\n    float3 grasspos = pos.xyz - _CameraPosition.xyz;\n    if (dot(grasspos, grasspos) > _WaveAndDistance.w)\n        offset = 0.0;\n    pos.xyz += offset.x * _CameraRight.xyz;\n    pos.xyz += offset.y * _CameraUp.xyz;\n}"
        },
        {
          "comment": "",
          "lineNum": 141,
          "modifiers": "",
          "parameters": "inout appdata_full v",
          "type": "void",
          "name": "WavingGrassVert",
          "code": "void WavingGrassVert (inout appdata_full v)\n{\n    // MeshGrass v.color.a: 1 on top vertices, 0 on bottom vertices\n    // _WaveAndDistance.z == 0 for MeshLit\n    float waveAmount = v.color.a * _WaveAndDistance.z;\n\n    v.color = TerrainWaveGrass (v.vertex, waveAmount, v.color);\n}"
        },
        {
          "comment": "",
          "lineNum": 150,
          "modifiers": "",
          "parameters": "inout appdata_full v",
          "type": "void",
          "name": "WavingGrassBillboardVert",
          "code": "void WavingGrassBillboardVert (inout appdata_full v)\n{\n    TerrainBillboardGrass (v.vertex, v.tangent.xy);\n    // wave amount defined by the grass height\n    float waveAmount = v.tangent.y;\n    v.color = TerrainWaveGrass (v.vertex, waveAmount, v.color);\n}"
        },
        {
          "comment": "",
          "lineNum": 162,
          "modifiers": "inline",
          "parameters": "in float4 pos",
          "type": "float4",
          "name": "Squash",
          "code": "inline float4 Squash(in float4 pos)\n{\n    // To squash the tree the vertex needs to be moved in the direction\n    // of the squash plane. The plane is defined by the the:\n    // plane point - point lying on the plane, defined in model space\n    // plane normal - _SquashPlaneNormal.xyz\n\n    // we're pushing squashed tree plane in direction of planeNormal by amount of _SquashPlaneNormal.w\n    // this squashing has to match logic of tree billboards\n\n    float3 planeNormal = _SquashPlaneNormal.xyz;\n\n    // unoptimized version:\n    //float3 planePoint = -planeNormal * _SquashPlaneNormal.w;\n    //float3 projectedVertex = pos.xyz + dot(planeNormal, (planePoint - pos)) * planeNormal;\n\n    // optimized version:\n    float3 projectedVertex = pos.xyz - (dot(planeNormal.xyz, pos.xyz) + _SquashPlaneNormal.w) * planeNormal;\n\n    pos = float4(lerp(projectedVertex, pos.xyz, _SquashAmount), 1);\n\n    return pos;\n}"
        },
        {
          "comment": "",
          "lineNum": 186,
          "modifiers": "",
          "parameters": "inout float4 pos, float alpha",
          "type": "void",
          "name": "TerrainAnimateTree",
          "code": "void TerrainAnimateTree( inout float4 pos, float alpha )\n{\n    pos.xyz *= _TreeInstanceScale.xyz;\n    float3 bent = mul(_TerrainEngineBendTree, float4(pos.xyz, 0.0)).xyz;\n    pos.xyz = lerp( pos.xyz, bent, alpha );\n\n    pos = Squash(pos);\n}"
        },
        {
          "comment": "",
          "lineNum": 199,
          "modifiers": "",
          "parameters": "inout float4 pos, float2 offset, float offsetz",
          "type": "void",
          "name": "TerrainBillboardTree",
          "code": "void TerrainBillboardTree( inout float4 pos, float2 offset, float offsetz )\n{\n    float3 treePos = pos.xyz - _TreeBillboardCameraPos.xyz;\n    float treeDistanceSqr = dot(treePos, treePos);\n    if( treeDistanceSqr > _TreeBillboardDistances.x )\n        offset.xy = offsetz = 0.0;\n\n    // positioning of billboard vertices horizontally\n    pos.xyz += _TreeBillboardCameraRight.xyz * offset.x;\n\n    // tree billboards can have non-uniform scale,\n    // so when looking from above (or bellow) we must use\n    // billboard width as billboard height\n\n    // 1) non-compensating\n    //pos.xyz += _TreeBillboardCameraUp.xyz * offset.y;\n\n    // 2) correct compensating (?)\n    //float alpha = _TreeBillboardCameraPos.w;\n    //float a = offset.y;\n    //float b = offsetz;\n        // 2a) using elipse-radius formula\n        ////float r = abs(a * b) / sqrt(sqr(a * sin(alpha)) + sqr(b * cos(alpha))) * sign(b);\n        //float r = abs(a) * b / sqrt(sqr(a * sin(alpha)) + sqr(b * cos(alpha)));\n        // 2b) sin-cos lerp\n        //float r = b * sin(alpha) + a * cos(alpha);\n    //pos.xyz += _TreeBillboardCameraUp.xyz * r;\n\n    // 3) incorrect compensating (using lerp)\n    // _TreeBillboardCameraPos.w contains ImposterRenderTexture::GetBillboardAngleFactor()\n    //float billboardAngleFactor = _TreeBillboardCameraPos.w;\n    //float r = lerp(offset.y, offsetz, billboardAngleFactor);\n    //pos.xyz += _TreeBillboardCameraUp.xyz * r;\n\n    // so now we take solution #3 and complicate it even further...\n    //\n    // case 49851: Flying trees\n    // The problem was that tree billboard was fixed on it's center, which means\n    // the root of the tree is not fixed and can float around. This can be quite visible\n    // on slopes (checkout the case on fogbugz for screenshots).\n    //\n    // We're fixing this by fixing billboards to the root of the tree.\n    // Note that root of the tree is not necessary the bottom of the tree -\n    // there might be significant part of the tree bellow terrain.\n    // This fixation mode doesn't work when looking from above/below, because\n    // billboard is so close to the ground, so we offset it by certain distance\n    // when viewing angle is bigger than certain treshold (40 deg at the moment)\n\n    // _TreeBillboardCameraPos.w contains ImposterRenderTexture::billboardAngleFactor\n    float billboardAngleFactor = _TreeBillboardCameraPos.w;\n    // The following line performs two things:\n    // 1) peform non-uniform scale, see \"3) incorrect compensating (using lerp)\" above\n    // 2) blend between vertical and horizontal billboard mode\n    float radius = lerp(offset.y, offsetz, billboardAngleFactor);\n\n    // positioning of billboard vertices veritally\n    pos.xyz += _TreeBillboardCameraUp.xyz * radius;\n\n    // _TreeBillboardCameraUp.w contains ImposterRenderTexture::billboardOffsetFactor\n    float billboardOffsetFactor = _TreeBillboardCameraUp.w;\n    // Offsetting billboad from the ground, so it doesn't get clipped by ztest.\n    // In theory we should use billboardCenterOffsetY instead of offset.x,\n    // but we can't because offset.y is not the same for all 4 vertices, so\n    // we use offset.x which is the same for all 4 vertices (except sign).\n    // And it doesn't matter a lot how much we offset, we just need to offset\n    // it by some distance\n    pos.xyz += _TreeBillboardCameraFront.xyz * abs(offset.x) * billboardOffsetFactor;\n}"
        },
        {
          "comment": "// Expand billboard and modify normal + tangent to fit",
          "lineNum": 274,
          "modifiers": "inline",
          "parameters": "in float4x4 mat, inout float4 pos, inout float3 normal, inout float4 tangent",
          "type": "void",
          "name": "ExpandBillboard",
          "code": "inline void ExpandBillboard (in float4x4 mat, inout float4 pos, inout float3 normal, inout float4 tangent)\n{\n    // tangent.w = 0 if this is a billboard\n    float isBillboard = 1.0f - abs(tangent.w);\n\n    // billboard normal\n    float3 norb = normalize(mul(float4(normal, 0), mat)).xyz;\n\n    // billboard tangent\n    float3 tanb = normalize(mul(float4(tangent.xyz, 0.0f), mat)).xyz;\n\n    pos += mul(float4(normal.xy, 0, 0), mat) * isBillboard;\n    normal = lerp(normal, norb, isBillboard);\n    tangent = lerp(tangent, float4(tanb, -1.0f), isBillboard);\n}"
        },
        {
          "comment": "",
          "lineNum": 290,
          "modifiers": "",
          "parameters": "float4 x",
          "type": "float4",
          "name": "SmoothCurve",
          "code": "float4 SmoothCurve( float4 x ) {\n    return x * x *( 3.0 - 2.0 * x );\n}"
        },
        {
          "comment": "",
          "lineNum": 293,
          "modifiers": "",
          "parameters": "float4 x",
          "type": "float4",
          "name": "TriangleWave",
          "code": "float4 TriangleWave( float4 x ) {\n    return abs( frac( x + 0.5 ) * 2.0 - 1.0 );\n}"
        },
        {
          "comment": "",
          "lineNum": 296,
          "modifiers": "",
          "parameters": "float4 x",
          "type": "float4",
          "name": "SmoothTriangleWave",
          "code": "float4 SmoothTriangleWave( float4 x ) {\n    return SmoothCurve( TriangleWave( x ) );\n}"
        },
        {
          "comment": "// Detail bending",
          "lineNum": 301,
          "modifiers": "inline",
          "parameters": "float4 pos, float3 normal, float4 animParams",
          "type": "float4",
          "name": "AnimateVertex",
          "code": "inline float4 AnimateVertex(float4 pos, float3 normal, float4 animParams)\n{\n    // animParams stored in color\n    // animParams.x = branch phase\n    // animParams.y = edge flutter factor\n    // animParams.z = primary factor\n    // animParams.w = secondary factor\n\n    float fDetailAmp = 0.1f;\n    float fBranchAmp = 0.3f;\n\n    // Phases (object, vertex, branch)\n    float fObjPhase = dot(unity_ObjectToWorld._14_24_34, 1);\n    float fBranchPhase = fObjPhase + animParams.x;\n\n    float fVtxPhase = dot(pos.xyz, animParams.y + fBranchPhase);\n\n    // x is used for edges; y is used for branches\n    float2 vWavesIn = _Time.yy + float2(fVtxPhase, fBranchPhase );\n\n    // 1.975, 0.793, 0.375, 0.193 are good frequencies\n    float4 vWaves = (frac( vWavesIn.xxyy * float4(1.975, 0.793, 0.375, 0.193) ) * 2.0 - 1.0);\n\n    vWaves = SmoothTriangleWave( vWaves );\n    float2 vWavesSum = vWaves.xz + vWaves.yw;\n\n    // Edge (xz) and branch bending (y)\n    float3 bend = animParams.y * fDetailAmp * normal.xyz;\n    bend.y = animParams.w * fBranchAmp;\n    pos.xyz += ((vWavesSum.xyx * bend) + (_Wind.xyz * vWavesSum.y * animParams.w)) * _Wind.w;\n\n    // Primary bending\n    // Displace position\n    pos.xyz += animParams.z * _Wind.xyz;\n\n    return pos;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 31,
          "type": "struct",
          "name": "appdata_tree",
          "modifiers": "",
          "code": "struct appdata_tree {\n    float4 vertex : POSITION;       // position\n    float4 tangent : TANGENT;       // directional AO\n    float3 normal : NORMAL;         // normal\n    fixed4 color : COLOR;           // .w = bend factor\n    float4 texcoord : TEXCOORD0;    // UV\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 40,
          "type": "struct",
          "name": "appdata_tree_billboard",
          "modifiers": "",
          "code": "struct appdata_tree_billboard {\n    float4 vertex : POSITION;\n    fixed4 color : COLOR;           // Color\n    float4 texcoord : TEXCOORD0;    // UV Coordinates\n    float2 texcoord1 : TEXCOORD1;   // Billboard extrusion\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        }
      ],
      "variables": [
        {
          "comment": "    // grass",
          "lineNum": 8,
          "modifiers": "",
          "type": "fixed4",
          "name": "_WavingTint;",
          "code": "fixed4 _WavingTint;"
        },
        {
          "comment": "    // grass",
          "lineNum": 9,
          "modifiers": "",
          "type": "float4",
          "name": "_WaveAndDistance;",
          "code": "float4 _WaveAndDistance;    // wind speed, wave size, wind amount, max sqr distance"
        },
        {
          "comment": "    // grass",
          "lineNum": 10,
          "modifiers": "",
          "type": "float4",
          "name": "_CameraPosition;",
          "code": "float4 _CameraPosition;     // .xyz = camera position, .w = 1 / (max sqr distance)"
        },
        {
          "comment": "    // grass",
          "lineNum": 11,
          "modifiers": "_CameraUp",
          "type": "float3",
          "name": "_CameraRight,",
          "code": "float3 _CameraRight, _CameraUp;"
        },
        {
          "comment": "    // trees",
          "lineNum": 14,
          "modifiers": "",
          "type": "fixed4",
          "name": "_TreeInstanceColor;",
          "code": "fixed4 _TreeInstanceColor;"
        },
        {
          "comment": "    // trees",
          "lineNum": 15,
          "modifiers": "",
          "type": "float4",
          "name": "_TreeInstanceScale;",
          "code": "float4 _TreeInstanceScale;"
        },
        {
          "comment": "    // trees",
          "lineNum": 16,
          "modifiers": "",
          "type": "float4x4",
          "name": "_TerrainEngineBendTree;",
          "code": "float4x4 _TerrainEngineBendTree;"
        },
        {
          "comment": "    // trees",
          "lineNum": 17,
          "modifiers": "",
          "type": "float4",
          "name": "_SquashPlaneNormal;",
          "code": "float4 _SquashPlaneNormal;"
        },
        {
          "comment": "    // trees",
          "lineNum": 18,
          "modifiers": "",
          "type": "float",
          "name": "_SquashAmount;",
          "code": "float _SquashAmount;"
        },
        {
          "comment": "    // billboards",
          "lineNum": 21,
          "modifiers": "",
          "type": "float3",
          "name": "_TreeBillboardCameraRight;",
          "code": "float3 _TreeBillboardCameraRight;"
        },
        {
          "comment": "    // billboards",
          "lineNum": 22,
          "modifiers": "",
          "type": "float4",
          "name": "_TreeBillboardCameraUp;",
          "code": "float4 _TreeBillboardCameraUp;"
        },
        {
          "comment": "    // billboards",
          "lineNum": 23,
          "modifiers": "",
          "type": "float4",
          "name": "_TreeBillboardCameraFront;",
          "code": "float4 _TreeBillboardCameraFront;"
        },
        {
          "comment": "    // billboards",
          "lineNum": 24,
          "modifiers": "",
          "type": "float4",
          "name": "_TreeBillboardCameraPos;",
          "code": "float4 _TreeBillboardCameraPos;"
        },
        {
          "comment": "    // billboards",
          "lineNum": 25,
          "modifiers": "",
          "type": "float4",
          "name": "_TreeBillboardDistances;",
          "code": "float4 _TreeBillboardDistances; // x = max distance ^ 2"
        },
        {
          "comment": "",
          "lineNum": 271,
          "modifiers": "",
          "type": "float4",
          "name": "_Wind;",
          "code": "float4 _Wind;"
        }
      ]
    },
    {
      "file": "TerrainPreview.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define TERRAIN_PREVIEW_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "// function to convert paint context pixels to heightmap uv",
          "lineNum": 10,
          "modifiers": "",
          "parameters": "float2 pcPixels",
          "type": "float2",
          "name": "PaintContextPixelsToHeightmapUV",
          "code": "float2 PaintContextPixelsToHeightmapUV(float2 pcPixels)\n{\n    return _HeightmapUV_PCPixelsX * pcPixels.x +\n        _HeightmapUV_PCPixelsY * pcPixels.y +\n        _HeightmapUV_Offset;\n}"
        },
        {
          "comment": "// function to convert paint context pixels to object position (terrain position)",
          "lineNum": 22,
          "modifiers": "",
          "parameters": "float2 pcPixels, float heightmapSample",
          "type": "float3",
          "name": "PaintContextPixelsToObjectPosition",
          "code": "float3 PaintContextPixelsToObjectPosition(float2 pcPixels, float heightmapSample)\n{\n    // note: we could assume no object space rotation and make this dramatically simpler\n    return _ObjectPos_PCPixelsX * pcPixels.x +\n        _ObjectPos_PCPixelsY * pcPixels.y +\n        _ObjectPos_HeightMapSample * heightmapSample +\n        _ObjectPos_Offset;\n}"
        },
        {
          "comment": "// function to convert paint context pixels to brush uv",
          "lineNum": 35,
          "modifiers": "",
          "parameters": "float2 pcPixels",
          "type": "float2",
          "name": "PaintContextPixelsToBrushUV",
          "code": "float2 PaintContextPixelsToBrushUV(float2 pcPixels)\n{\n    return _BrushUV_PCPixelsX * pcPixels.x +\n        _BrushUV_PCPixelsY * pcPixels.y +\n        _BrushUV_Offset;\n}"
        },
        {
          "comment": "// function to convert terrain object position to world position\n// We would normally use the ObjectToWorld / ObjectToClip calls to do this, but DrawProcedural does not set them\n// 'luckily' terrains cannot be rotated or scaled, so this transform is very simple",
          "lineNum": 46,
          "modifiers": "",
          "parameters": "float3 objectPosition",
          "type": "float3",
          "name": "TerrainObjectToWorldPosition",
          "code": "float3 TerrainObjectToWorldPosition(float3 objectPosition)\n{\n    return objectPosition + _TerrainObjectToWorldOffset;\n}"
        },
        {
          "comment": "// function to build a procedural quad mesh\n// based on the quad resolution defined by _QuadRez\n// returns integer positions, starting with (0, 0), and ending with (_QuadRez.xy - 1)",
          "lineNum": 55,
          "modifiers": "",
          "parameters": "uint vertexID",
          "type": "float2",
          "name": "BuildProceduralQuadMeshVertex",
          "code": "float2 BuildProceduralQuadMeshVertex(uint vertexID)\n{\n    int quadIndex = vertexID / 6;                       // quad index, each quad is made of 6 vertices\n    int vertIndex = vertexID - quadIndex * 6;           // vertex index within the quad [0..5]\n    int qY = floor((quadIndex + 0.5f) / _QuadRez.x);    // quad coords for current quad (Y)\n    int qX = round(quadIndex - qY * _QuadRez.x);        // quad coords for current quad (X)\n\n    // each quad is defined by 6 vertices (two triangles), offset from (qX,qY) as follows:\n    // vX = 0, 0, 1, 1, 1, 0\n    // vY = 0, 1, 1, 1, 0, 0\n    float sequence[6] = { 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f };\n    float vX = sequence[vertIndex];\n    float vY = sequence[5 - vertIndex];     // vY is just vX reversed\n    float2 coord = float2(qX + vX, qY + vY);\n    return coord;\n}"
        },
        {
          "comment": "",
          "lineNum": 73,
          "modifiers": "",
          "parameters": "in float x, in float stripeX, in float pixelWidth",
          "type": "float",
          "name": "Stripe",
          "code": "float Stripe(in float x, in float stripeX, in float pixelWidth)\n{\n    // compute derivatives to get ddx / pixel\n    float2 derivatives = float2(ddx(x), ddy(x));\n    float derivLen = length(derivatives);\n    float sharpen = 1.0f / max(derivLen, 0.00001f);\n    return saturate(0.5f + 0.5f * (0.5f * pixelWidth - sharpen * abs(x - stripeX)));\n}"
        }
      ],
      "structs": [],
      "variables": [
        {
          "comment": "// function to convert paint context pixels to heightmap uv",
          "lineNum": 6,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_Heightmap;",
          "code": "sampler2D _Heightmap;"
        },
        {
          "comment": "// function to convert paint context pixels to heightmap uv",
          "lineNum": 7,
          "modifiers": "",
          "type": "float2",
          "name": "_HeightmapUV_PCPixelsX;",
          "code": "float2 _HeightmapUV_PCPixelsX;"
        },
        {
          "comment": "// function to convert paint context pixels to heightmap uv",
          "lineNum": 8,
          "modifiers": "",
          "type": "float2",
          "name": "_HeightmapUV_PCPixelsY;",
          "code": "float2 _HeightmapUV_PCPixelsY;"
        },
        {
          "comment": "// function to convert paint context pixels to heightmap uv",
          "lineNum": 9,
          "modifiers": "",
          "type": "float2",
          "name": "_HeightmapUV_Offset;",
          "code": "float2 _HeightmapUV_Offset;"
        },
        {
          "comment": "// function to convert paint context pixels to object position (terrain position)",
          "lineNum": 18,
          "modifiers": "",
          "type": "float3",
          "name": "_ObjectPos_PCPixelsX;",
          "code": "float3 _ObjectPos_PCPixelsX;"
        },
        {
          "comment": "// function to convert paint context pixels to object position (terrain position)",
          "lineNum": 19,
          "modifiers": "",
          "type": "float3",
          "name": "_ObjectPos_PCPixelsY;",
          "code": "float3 _ObjectPos_PCPixelsY;"
        },
        {
          "comment": "// function to convert paint context pixels to object position (terrain position)",
          "lineNum": 20,
          "modifiers": "",
          "type": "float3",
          "name": "_ObjectPos_HeightMapSample;",
          "code": "float3 _ObjectPos_HeightMapSample;"
        },
        {
          "comment": "// function to convert paint context pixels to object position (terrain position)",
          "lineNum": 21,
          "modifiers": "",
          "type": "float3",
          "name": "_ObjectPos_Offset;",
          "code": "float3 _ObjectPos_Offset;"
        },
        {
          "comment": "// function to convert paint context pixels to brush uv",
          "lineNum": 32,
          "modifiers": "",
          "type": "float2",
          "name": "_BrushUV_PCPixelsX;",
          "code": "float2 _BrushUV_PCPixelsX;"
        },
        {
          "comment": "// function to convert paint context pixels to brush uv",
          "lineNum": 33,
          "modifiers": "",
          "type": "float2",
          "name": "_BrushUV_PCPixelsY;",
          "code": "float2 _BrushUV_PCPixelsY;"
        },
        {
          "comment": "// function to convert paint context pixels to brush uv",
          "lineNum": 34,
          "modifiers": "",
          "type": "float2",
          "name": "_BrushUV_Offset;",
          "code": "float2 _BrushUV_Offset;"
        },
        {
          "comment": "// function to convert terrain object position to world position\n// We would normally use the ObjectToWorld / ObjectToClip calls to do this, but DrawProcedural does not set them\n// 'luckily' terrains cannot be rotated or scaled, so this transform is very simple",
          "lineNum": 45,
          "modifiers": "",
          "type": "float3",
          "name": "_TerrainObjectToWorldOffset;",
          "code": "float3 _TerrainObjectToWorldOffset;"
        },
        {
          "comment": "// function to build a procedural quad mesh\n// based on the quad resolution defined by _QuadRez\n// returns integer positions, starting with (0, 0), and ending with (_QuadRez.xy - 1)",
          "lineNum": 54,
          "modifiers": "",
          "type": "float3",
          "name": "_QuadRez;",
          "code": "float3 _QuadRez;    // quads X, quads Y, vertexCount"
        }
      ]
    },
    {
      "file": "TerrainSplatmapCommon.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define TERRAIN_SPLATMAP_COMMON_CGINC_INCLUDED"
        },
        {
          "comment": "// Since 2018.3 we changed from _TERRAIN_NORMAL_MAP to _NORMALMAP to save 1 keyword.\n// Since 2019.2 terrain keywords are changed to  local keywords so it doesn't really matter. You can use both.",
          "lineNum": 7,
          "code": "    #define _TERRAIN_NORMAL_MAP"
        },
        {
          "comment": "// Since 2018.3 we changed from _TERRAIN_NORMAL_MAP to _NORMALMAP to save 1 keyword.\n// Since 2019.2 terrain keywords are changed to  local keywords so it doesn't really matter. You can use both.",
          "lineNum": 9,
          "code": "    #define _NORMALMAP"
        },
        {
          "comment": "",
          "lineNum": 159,
          "code": "    #define TERRAIN_SURFACE_OUTPUT SurfaceOutput"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 47,
          "modifiers": "",
          "parameters": "inout appdata_full v, out Input data",
          "type": "void",
          "name": "SplatmapVert",
          "code": "void SplatmapVert(inout appdata_full v, out Input data)\n{\n    UNITY_INITIALIZE_OUTPUT(Input, data);\n\n#if defined(UNITY_INSTANCING_ENABLED) && !defined(SHADER_API_D3D11_9X)\n\n    float2 patchVertex = v.vertex.xy;\n    float4 instanceData = UNITY_ACCESS_INSTANCED_PROP(Terrain, _TerrainPatchInstanceData);\n\n    float4 uvscale = instanceData.z * _TerrainHeightmapRecipSize;\n    float4 uvoffset = instanceData.xyxy * uvscale;\n    uvoffset.xy += 0.5f * _TerrainHeightmapRecipSize.xy;\n    float2 sampleCoords = (patchVertex.xy * uvscale.xy + uvoffset.xy);\n\n    float hm = UnpackHeightmap(tex2Dlod(_TerrainHeightmapTexture, float4(sampleCoords, 0, 0)));\n    v.vertex.xz = (patchVertex.xy + instanceData.xy) * _TerrainHeightmapScale.xz * instanceData.z;  //(x + xBase) * hmScale.x * skipScale;\n    v.vertex.y = hm * _TerrainHeightmapScale.y;\n    v.vertex.w = 1.0f;\n\n    v.texcoord.xy = (patchVertex.xy * uvscale.zw + uvoffset.zw);\n    v.texcoord3 = v.texcoord2 = v.texcoord1 = v.texcoord;\n\n    #ifdef TERRAIN_INSTANCED_PERPIXEL_NORMAL\n        v.normal = float3(0, 1, 0); // TODO: reconstruct the tangent space in the pixel shader. Seems to be hard with surface shader especially when other attributes are packed together with tSpace.\n        data.tc.zw = sampleCoords;\n    #else\n        float3 nor = tex2Dlod(_TerrainNormalmapTexture, float4(sampleCoords, 0, 0)).xyz;\n        v.normal = 2.0f * nor - 1.0f;\n    #endif\n#endif\n\n    v.tangent.xyz = cross(v.normal, float3(0,0,1));\n    v.tangent.w = -1;\n\n    data.tc.xy = v.texcoord.xy;\n#ifdef TERRAIN_BASE_PASS\n    #ifdef UNITY_PASS_META\n        data.tc.xy = TRANSFORM_TEX(v.texcoord.xy, _MainTex);\n    #endif\n#else\n    float4 pos = UnityObjectToClipPos(v.vertex);\n    UNITY_TRANSFER_FOG(data, pos);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 95,
          "modifiers": "",
          "parameters": "Input IN, half4 defaultAlpha, out half4 splat_control, out half weight, out fixed4 mixedDiffuse, inout fixed3 mixedNormal)#elsevoid SplatmapMix(Input IN, out half4 splat_control, out half weight, out fixed4 mixedDiffuse, inout fixed3 mixedNormal",
          "type": "void",
          "name": "SplatmapMix",
          "code": "void SplatmapMix(Input IN, half4 defaultAlpha, out half4 splat_control, out half weight, out fixed4 mixedDiffuse, inout fixed3 mixedNormal)\n#else\nvoid SplatmapMix(Input IN, out half4 splat_control, out half weight, out fixed4 mixedDiffuse, inout fixed3 mixedNormal)\n#endif\n{\n    // adjust splatUVs so the edges of the terrain tile lie on pixel centers\n    float2 splatUV = (IN.tc.xy * (_Control_TexelSize.zw - 1.0f) + 0.5f) * _Control_TexelSize.xy;\n    splat_control = tex2D(_Control, splatUV);\n    weight = dot(splat_control, half4(1,1,1,1));\n\n    #if !defined(SHADER_API_MOBILE) && defined(TERRAIN_SPLAT_ADDPASS)\n        clip(weight == 0.0f ? -1 : 1);\n    #endif\n\n    // Normalize weights before lighting and restore weights in final modifier functions so that the overal\n    // lighting result can be correctly weighted.\n    splat_control /= (weight + 1e-3f);\n\n    float2 uvSplat0 = TRANSFORM_TEX(IN.tc.xy, _Splat0);\n    float2 uvSplat1 = TRANSFORM_TEX(IN.tc.xy, _Splat1);\n    float2 uvSplat2 = TRANSFORM_TEX(IN.tc.xy, _Splat2);\n    float2 uvSplat3 = TRANSFORM_TEX(IN.tc.xy, _Splat3);\n\n    mixedDiffuse = 0.0f;\n    #ifdef TERRAIN_STANDARD_SHADER\n        mixedDiffuse += splat_control.r * tex2D(_Splat0, uvSplat0) * half4(1.0, 1.0, 1.0, defaultAlpha.r);\n        mixedDiffuse += splat_control.g * tex2D(_Splat1, uvSplat1) * half4(1.0, 1.0, 1.0, defaultAlpha.g);\n        mixedDiffuse += splat_control.b * tex2D(_Splat2, uvSplat2) * half4(1.0, 1.0, 1.0, defaultAlpha.b);\n        mixedDiffuse += splat_control.a * tex2D(_Splat3, uvSplat3) * half4(1.0, 1.0, 1.0, defaultAlpha.a);\n    #else\n        mixedDiffuse += splat_control.r * tex2D(_Splat0, uvSplat0);\n        mixedDiffuse += splat_control.g * tex2D(_Splat1, uvSplat1);\n        mixedDiffuse += splat_control.b * tex2D(_Splat2, uvSplat2);\n        mixedDiffuse += splat_control.a * tex2D(_Splat3, uvSplat3);\n    #endif\n\n    #ifdef _NORMALMAP\n        mixedNormal  = UnpackNormalWithScale(tex2D(_Normal0, uvSplat0), _NormalScale0) * splat_control.r;\n        mixedNormal += UnpackNormalWithScale(tex2D(_Normal1, uvSplat1), _NormalScale1) * splat_control.g;\n        mixedNormal += UnpackNormalWithScale(tex2D(_Normal2, uvSplat2), _NormalScale2) * splat_control.b;\n        mixedNormal += UnpackNormalWithScale(tex2D(_Normal3, uvSplat3), _NormalScale3) * splat_control.a;\n        mixedNormal.z += 1e-5f; // to avoid nan after normalizing\n    #endif\n\n    #if defined(INSTANCING_ON) && defined(SHADER_TARGET_SURFACE_ANALYSIS) && defined(TERRAIN_INSTANCED_PERPIXEL_NORMAL)\n        mixedNormal = float3(0, 0, 1); // make sure that surface shader compiler realizes we write to normal, as UNITY_INSTANCING_ENABLED is not defined for SHADER_TARGET_SURFACE_ANALYSIS.\n    #endif\n\n    #if defined(UNITY_INSTANCING_ENABLED) && !defined(SHADER_API_D3D11_9X) && defined(TERRAIN_INSTANCED_PERPIXEL_NORMAL)\n        float3 geomNormal = normalize(tex2D(_TerrainNormalmapTexture, IN.tc.zw).xyz * 2 - 1);\n        #ifdef _NORMALMAP\n            float3 geomTangent = normalize(cross(geomNormal, float3(0, 0, 1)));\n            float3 geomBitangent = normalize(cross(geomTangent, geomNormal));\n            mixedNormal = mixedNormal.x * geomTangent\n                          + mixedNormal.y * geomBitangent\n                          + mixedNormal.z * geomNormal;\n        #else\n            mixedNormal = geomNormal;\n        #endif\n        mixedNormal = mixedNormal.xzy;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 162,
          "modifiers": "",
          "parameters": "Input IN, TERRAIN_SURFACE_OUTPUT o, inout fixed4 color",
          "type": "void",
          "name": "SplatmapFinalColor",
          "code": "void SplatmapFinalColor(Input IN, TERRAIN_SURFACE_OUTPUT o, inout fixed4 color)\n{\n    color *= o.Alpha;\n    #ifdef TERRAIN_SPLAT_ADDPASS\n        UNITY_APPLY_FOG_COLOR(IN.fogCoord, color, fixed4(0,0,0,0));\n    #else\n        UNITY_APPLY_FOG(IN.fogCoord, color);\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 172,
          "modifiers": "",
          "parameters": "Input IN, TERRAIN_SURFACE_OUTPUT o, inout fixed4 normalSpec",
          "type": "void",
          "name": "SplatmapFinalPrepass",
          "code": "void SplatmapFinalPrepass(Input IN, TERRAIN_SURFACE_OUTPUT o, inout fixed4 normalSpec)\n{\n    normalSpec *= o.Alpha;\n}"
        },
        {
          "comment": "",
          "lineNum": 177,
          "modifiers": "",
          "parameters": "Input IN, TERRAIN_SURFACE_OUTPUT o, inout half4 outGBuffer0, inout half4 outGBuffer1, inout half4 outGBuffer2, inout half4 emission",
          "type": "void",
          "name": "SplatmapFinalGBuffer",
          "code": "void SplatmapFinalGBuffer(Input IN, TERRAIN_SURFACE_OUTPUT o, inout half4 outGBuffer0, inout half4 outGBuffer1, inout half4 outGBuffer2, inout half4 emission)\n{\n    UnityStandardDataApplyWeightToGbuffer(outGBuffer0, outGBuffer1, outGBuffer2, o.Alpha);\n    emission *= o.Alpha;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 12,
          "type": "struct",
          "name": "Input",
          "modifiers": "",
          "code": "struct Input\n{\n    float4 tc;\n    #ifndef TERRAIN_BASE_PASS\n        UNITY_FOG_COORDS(0) // needed because finalcolor oppresses fog code generation.\n    #endif\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 20,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_Control;",
          "code": "sampler2D _Control;"
        },
        {
          "comment": "",
          "lineNum": 21,
          "modifiers": "",
          "type": "float4",
          "name": "_Control_ST;",
          "code": "float4 _Control_ST;"
        },
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "",
          "type": "float4",
          "name": "_Control_TexelSize;",
          "code": "float4 _Control_TexelSize;"
        },
        {
          "comment": "",
          "lineNum": 23,
          "modifiers": "_Splat1, _Splat2, _Splat3",
          "type": "sampler2D",
          "name": "_Splat0,",
          "code": "sampler2D _Splat0, _Splat1, _Splat2, _Splat3;"
        },
        {
          "comment": "",
          "lineNum": 24,
          "modifiers": "_Splat1_ST, _Splat2_ST, _Splat3_ST",
          "type": "float4",
          "name": "_Splat0_ST,",
          "code": "float4 _Splat0_ST, _Splat1_ST, _Splat2_ST, _Splat3_ST;"
        },
        {
          "comment": "",
          "lineNum": 27,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_TerrainHeightmapTexture;",
          "code": "sampler2D _TerrainHeightmapTexture;"
        },
        {
          "comment": "",
          "lineNum": 28,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_TerrainNormalmapTexture;",
          "code": "sampler2D _TerrainNormalmapTexture;"
        },
        {
          "comment": "",
          "lineNum": 29,
          "modifiers": "",
          "type": "float4",
          "name": "_TerrainHeightmapRecipSize;",
          "code": "float4    _TerrainHeightmapRecipSize;   // float4(1.0f/width, 1.0f/height, 1.0f/(width-1), 1.0f/(height-1))"
        },
        {
          "comment": "",
          "lineNum": 30,
          "modifiers": "",
          "type": "float4",
          "name": "_TerrainHeightmapScale;",
          "code": "float4    _TerrainHeightmapScale;       // float4(hmScale.x, hmScale.y / (float)(kMaxHeight), hmScale.z, 0.0f)"
        },
        {
          "comment": "",
          "lineNum": 38,
          "modifiers": "_Normal1, _Normal2, _Normal3",
          "type": "sampler2D",
          "name": "_Normal0,",
          "code": "sampler2D _Normal0, _Normal1, _Normal2, _Normal3;"
        },
        {
          "comment": "",
          "lineNum": 39,
          "modifiers": "_NormalScale1, _NormalScale2, _NormalScale3",
          "type": "float",
          "name": "_NormalScale0,",
          "code": "float _NormalScale0, _NormalScale1, _NormalScale2, _NormalScale3;"
        },
        {
          "comment": "    // When we render albedo for GI baking, we actually need to take the ST",
          "lineNum": 44,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_ST;",
          "code": "float4 _MainTex_ST;"
        }
      ]
    },
    {
      "file": "TerrainTool.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define TERRAIN_TOOL_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "// function to convert paint context UV to brush uv",
          "lineNum": 8,
          "modifiers": "",
          "parameters": "float2 pcUV",
          "type": "float2",
          "name": "PaintContextUVToBrushUV",
          "code": "float2 PaintContextUVToBrushUV(float2 pcUV)\n{\n    return _PCUVToBrushUVScales.xy * pcUV.x +\n           _PCUVToBrushUVScales.zw * pcUV.y +\n           _PCUVToBrushUVOffset;\n}"
        },
        {
          "comment": "",
          "lineNum": 16,
          "modifiers": "",
          "parameters": "float2 pcUV",
          "type": "float2",
          "name": "PaintContextUVToHeightmapUV",
          "code": "float2 PaintContextUVToHeightmapUV(float2 pcUV)\n{\n    return pcUV;\n}"
        }
      ],
      "structs": [],
      "variables": [
        {
          "comment": "// function to convert paint context UV to brush uv",
          "lineNum": 6,
          "modifiers": "",
          "type": "float4",
          "name": "_PCUVToBrushUVScales;",
          "code": "float4 _PCUVToBrushUVScales;"
        },
        {
          "comment": "// function to convert paint context UV to brush uv",
          "lineNum": 7,
          "modifiers": "",
          "type": "float2",
          "name": "_PCUVToBrushUVOffset;",
          "code": "float2 _PCUVToBrushUVOffset;"
        }
      ]
    },
    {
      "file": "Tessellation.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define TESSELLATION_CGINC_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 8,
          "modifiers": "",
          "parameters": "float4 vertex, float minDist, float maxDist, float tess",
          "type": "float",
          "name": "UnityCalcDistanceTessFactor",
          "code": "float UnityCalcDistanceTessFactor (float4 vertex, float minDist, float maxDist, float tess)\n{\n    float3 wpos = mul(unity_ObjectToWorld,vertex).xyz;\n    float dist = distance (wpos, _WorldSpaceCameraPos);\n    float f = clamp(1.0 - (dist - minDist) / (maxDist - minDist), 0.01, 1.0) * tess;\n    return f;\n}"
        },
        {
          "comment": "",
          "lineNum": 16,
          "modifiers": "",
          "parameters": "float3 triVertexFactors",
          "type": "float4",
          "name": "UnityCalcTriEdgeTessFactors",
          "code": "float4 UnityCalcTriEdgeTessFactors (float3 triVertexFactors)\n{\n    float4 tess;\n    tess.x = 0.5 * (triVertexFactors.y + triVertexFactors.z);\n    tess.y = 0.5 * (triVertexFactors.x + triVertexFactors.z);\n    tess.z = 0.5 * (triVertexFactors.x + triVertexFactors.y);\n    tess.w = (triVertexFactors.x + triVertexFactors.y + triVertexFactors.z) / 3.0f;\n    return tess;\n}"
        },
        {
          "comment": "",
          "lineNum": 26,
          "modifiers": "",
          "parameters": "float3 wpos0, float3 wpos1, float edgeLen",
          "type": "float",
          "name": "UnityCalcEdgeTessFactor",
          "code": "float UnityCalcEdgeTessFactor (float3 wpos0, float3 wpos1, float edgeLen)\n{\n    // distance to edge center\n    float dist = distance (0.5 * (wpos0+wpos1), _WorldSpaceCameraPos);\n    // length of the edge\n    float len = distance(wpos0, wpos1);\n    // edgeLen is approximate desired size in pixels\n    float f = max(len * _ScreenParams.y / (edgeLen * dist), 1.0);\n    return f;\n}"
        },
        {
          "comment": "",
          "lineNum": 37,
          "modifiers": "",
          "parameters": "float3 pos, float4 plane",
          "type": "float",
          "name": "UnityDistanceFromPlane",
          "code": "float UnityDistanceFromPlane (float3 pos, float4 plane)\n{\n    float d = dot (float4(pos,1.0f), plane);\n    return d;\n}"
        },
        {
          "comment": "// Returns true if triangle with given 3 world positions is outside of camera's view frustum.\n// cullEps is distance outside of frustum that is still considered to be inside (i.e. max displacement)",
          "lineNum": 46,
          "modifiers": "",
          "parameters": "float3 wpos0, float3 wpos1, float3 wpos2, float cullEps",
          "type": "bool",
          "name": "UnityWorldViewFrustumCull",
          "code": "bool UnityWorldViewFrustumCull (float3 wpos0, float3 wpos1, float3 wpos2, float cullEps)\n{\n    float4 planeTest;\n\n    // left\n    planeTest.x = (( UnityDistanceFromPlane(wpos0, unity_CameraWorldClipPlanes[0]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos1, unity_CameraWorldClipPlanes[0]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos2, unity_CameraWorldClipPlanes[0]) > -cullEps) ? 1.0f : 0.0f );\n    // right\n    planeTest.y = (( UnityDistanceFromPlane(wpos0, unity_CameraWorldClipPlanes[1]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos1, unity_CameraWorldClipPlanes[1]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos2, unity_CameraWorldClipPlanes[1]) > -cullEps) ? 1.0f : 0.0f );\n    // top\n    planeTest.z = (( UnityDistanceFromPlane(wpos0, unity_CameraWorldClipPlanes[2]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos1, unity_CameraWorldClipPlanes[2]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos2, unity_CameraWorldClipPlanes[2]) > -cullEps) ? 1.0f : 0.0f );\n    // bottom\n    planeTest.w = (( UnityDistanceFromPlane(wpos0, unity_CameraWorldClipPlanes[3]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos1, unity_CameraWorldClipPlanes[3]) > -cullEps) ? 1.0f : 0.0f ) +\n                  (( UnityDistanceFromPlane(wpos2, unity_CameraWorldClipPlanes[3]) > -cullEps) ? 1.0f : 0.0f );\n\n    // has to pass all 4 plane tests to be visible\n    return !all (planeTest);\n}"
        },
        {
          "comment": "// Distance based tessellation:\n// Tessellation level is \"tess\" before \"minDist\" from camera, and linearly decreases to 1\n// up to \"maxDist\" from camera.",
          "lineNum": 79,
          "modifiers": "",
          "parameters": "float4 v0, float4 v1, float4 v2, float minDist, float maxDist, float tess",
          "type": "float4",
          "name": "UnityDistanceBasedTess",
          "code": "float4 UnityDistanceBasedTess (float4 v0, float4 v1, float4 v2, float minDist, float maxDist, float tess)\n{\n    float3 f;\n    f.x = UnityCalcDistanceTessFactor (v0,minDist,maxDist,tess);\n    f.y = UnityCalcDistanceTessFactor (v1,minDist,maxDist,tess);\n    f.z = UnityCalcDistanceTessFactor (v2,minDist,maxDist,tess);\n\n    return UnityCalcTriEdgeTessFactors (f);\n}"
        },
        {
          "comment": "// Desired edge length based tessellation:\n// Approximate resulting edge length in pixels is \"edgeLength\".\n// Does not take viewing FOV into account, just flat out divides factor by distance.",
          "lineNum": 92,
          "modifiers": "",
          "parameters": "float4 v0, float4 v1, float4 v2, float edgeLength",
          "type": "float4",
          "name": "UnityEdgeLengthBasedTess",
          "code": "float4 UnityEdgeLengthBasedTess (float4 v0, float4 v1, float4 v2, float edgeLength)\n{\n    float3 pos0 = mul(unity_ObjectToWorld,v0).xyz;\n    float3 pos1 = mul(unity_ObjectToWorld,v1).xyz;\n    float3 pos2 = mul(unity_ObjectToWorld,v2).xyz;\n    float4 tess;\n    tess.x = UnityCalcEdgeTessFactor (pos1, pos2, edgeLength);\n    tess.y = UnityCalcEdgeTessFactor (pos2, pos0, edgeLength);\n    tess.z = UnityCalcEdgeTessFactor (pos0, pos1, edgeLength);\n    tess.w = (tess.x + tess.y + tess.z) / 3.0f;\n    return tess;\n}"
        },
        {
          "comment": "// Same as UnityEdgeLengthBasedTess, but also does patch frustum culling:\n// patches outside of camera's view are culled before GPU tessellation. Saves some wasted work.",
          "lineNum": 108,
          "modifiers": "",
          "parameters": "float4 v0, float4 v1, float4 v2, float edgeLength, float maxDisplacement",
          "type": "float4",
          "name": "UnityEdgeLengthBasedTessCull",
          "code": "float4 UnityEdgeLengthBasedTessCull (float4 v0, float4 v1, float4 v2, float edgeLength, float maxDisplacement)\n{\n    float3 pos0 = mul(unity_ObjectToWorld,v0).xyz;\n    float3 pos1 = mul(unity_ObjectToWorld,v1).xyz;\n    float3 pos2 = mul(unity_ObjectToWorld,v2).xyz;\n    float4 tess;\n\n    if (UnityWorldViewFrustumCull(pos0, pos1, pos2, maxDisplacement))\n    {\n        tess = 0.0f;\n    }\n    else\n    {\n        tess.x = UnityCalcEdgeTessFactor (pos1, pos2, edgeLength);\n        tess.y = UnityCalcEdgeTessFactor (pos2, pos0, edgeLength);\n        tess.z = UnityCalcEdgeTessFactor (pos0, pos1, edgeLength);\n        tess.w = (tess.x + tess.y + tess.z) / 3.0f;\n    }\n    return tess;\n}"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "TextCoreProperties.cginc",
      "defines": [],
      "functions": [],
      "structs": [],
      "variables": [
        {
          "comment": "// UI Editable properties",
          "lineNum": 2,
          "modifiers": "uniform",
          "type": "fixed4",
          "name": "_FaceColor;",
          "code": "uniform fixed4      _FaceColor;                 // RGBA : Color + Opacity"
        },
        {
          "comment": "// UI Editable properties",
          "lineNum": 3,
          "modifiers": "uniform",
          "type": "float",
          "name": "_FaceDilate;",
          "code": "uniform float       _FaceDilate;                // v[ 0, 1]"
        },
        {
          "comment": "",
          "lineNum": 5,
          "modifiers": "uniform",
          "type": "fixed4",
          "name": "_OutlineColor;",
          "code": "uniform fixed4      _OutlineColor;              // RGBA : Color + Opacity"
        },
        {
          "comment": "",
          "lineNum": 6,
          "modifiers": "uniform",
          "type": "float",
          "name": "_OutlineWidth;",
          "code": "uniform float       _OutlineWidth;              // v[ 0, 1]"
        },
        {
          "comment": "",
          "lineNum": 7,
          "modifiers": "uniform",
          "type": "float",
          "name": "_OutlineSoftness;",
          "code": "uniform float       _OutlineSoftness;           // v[ 0, 1]"
        },
        {
          "comment": "// API Editable properties",
          "lineNum": 10,
          "modifiers": "uniform",
          "type": "float",
          "name": "_WeightNormal;",
          "code": "uniform float       _WeightNormal;"
        },
        {
          "comment": "// API Editable properties",
          "lineNum": 11,
          "modifiers": "uniform",
          "type": "float",
          "name": "_WeightBold;",
          "code": "uniform float       _WeightBold;"
        },
        {
          "comment": "",
          "lineNum": 13,
          "modifiers": "uniform",
          "type": "float",
          "name": "_ScaleRatioA;",
          "code": "uniform float       _ScaleRatioA;"
        },
        {
          "comment": "",
          "lineNum": 14,
          "modifiers": "uniform",
          "type": "float",
          "name": "_ScaleRatioB;",
          "code": "uniform float       _ScaleRatioB;"
        },
        {
          "comment": "",
          "lineNum": 15,
          "modifiers": "uniform",
          "type": "float",
          "name": "_ScaleRatioC;",
          "code": "uniform float       _ScaleRatioC;"
        },
        {
          "comment": "",
          "lineNum": 17,
          "modifiers": "uniform",
          "type": "float",
          "name": "_VertexOffsetX;",
          "code": "uniform float       _VertexOffsetX;"
        },
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "uniform",
          "type": "float",
          "name": "_VertexOffsetY;",
          "code": "uniform float       _VertexOffsetY;"
        },
        {
          "comment": "// Font Atlas properties",
          "lineNum": 21,
          "modifiers": "uniform",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "uniform sampler2D   _MainTex;"
        },
        {
          "comment": "// Font Atlas properties",
          "lineNum": 22,
          "modifiers": "uniform",
          "type": "float",
          "name": "_GradientScale;",
          "code": "uniform float       _GradientScale;"
        },
        {
          "comment": "// Font Atlas properties",
          "lineNum": 23,
          "modifiers": "uniform",
          "type": "float",
          "name": "_ScaleX;",
          "code": "uniform float       _ScaleX;"
        },
        {
          "comment": "// Font Atlas properties",
          "lineNum": 24,
          "modifiers": "uniform",
          "type": "float",
          "name": "_ScaleY;",
          "code": "uniform float       _ScaleY;"
        },
        {
          "comment": "// Font Atlas properties",
          "lineNum": 25,
          "modifiers": "uniform",
          "type": "float",
          "name": "_Sharpness;",
          "code": "uniform float       _Sharpness;"
        }
      ]
    },
    {
      "file": "UnityBuiltin2xTreeLibrary.cginc",
      "defines": [],
      "functions": [
        {
          "comment": "",
          "lineNum": 31,
          "modifiers": "",
          "parameters": "appdata_tree v",
          "type": "v2f",
          "name": "leaves",
          "code": "v2f leaves(appdata_tree v)\n{\n    v2f o;\n    UNITY_SETUP_INSTANCE_ID(v);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n    TerrainAnimateTree(v.vertex, v.color.w);\n\n    float3 viewpos = UnityObjectToViewPos(v.vertex);\n    o.pos = UnityObjectToClipPos(v.vertex);\n    o.uv = v.texcoord;\n\n    float4 lightDir = 0;\n    float4 lightColor = 0;\n    lightDir.w = _AO;\n\n    float4 light = UNITY_LIGHTMODEL_AMBIENT;\n\n    for (int i = 0; i < 4; i++) {\n        float atten = 1.0;\n        #ifdef USE_CUSTOM_LIGHT_DIR\n            lightDir.xyz = _TerrainTreeLightDirections[i];\n            lightColor = _TerrainTreeLightColors[i];\n        #else\n                float3 toLight = unity_LightPosition[i].xyz - viewpos.xyz * unity_LightPosition[i].w;\n                toLight.z *= -1.0;\n                lightDir.xyz = mul( (float3x3)_CameraToWorld, normalize(toLight) );\n                float lengthSq = dot(toLight, toLight);\n                atten = 1.0 / (1.0 + lengthSq * unity_LightAtten[i].z);\n\n                lightColor.rgb = unity_LightColor[i].rgb;\n        #endif\n\n        lightDir.xyz *= _Occlusion;\n        float occ =  dot (v.tangent, lightDir);\n        occ = max(0, occ);\n        occ += _BaseLight;\n        light += lightColor * (occ * atten);\n    }\n\n    o.color = light * _Color * _TreeInstanceColor;\n    o.color.a = 0.5 * _HalfOverCutoff;\n\n    UNITY_TRANSFER_FOG(o,o.pos);\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 77,
          "modifiers": "",
          "parameters": "appdata_tree v",
          "type": "v2f",
          "name": "bark",
          "code": "v2f bark(appdata_tree v)\n{\n    v2f o;\n    UNITY_SETUP_INSTANCE_ID(v);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n    TerrainAnimateTree(v.vertex, v.color.w);\n\n    float3 viewpos = UnityObjectToViewPos(v.vertex);\n    o.pos = UnityObjectToClipPos(v.vertex);\n    o.uv = v.texcoord;\n\n    float4 lightDir = 0;\n    float4 lightColor = 0;\n    lightDir.w = _AO;\n\n    float4 light = UNITY_LIGHTMODEL_AMBIENT;\n\n    for (int i = 0; i < 4; i++) {\n        float atten = 1.0;\n        #ifdef USE_CUSTOM_LIGHT_DIR\n            lightDir.xyz = _TerrainTreeLightDirections[i];\n            lightColor = _TerrainTreeLightColors[i];\n        #else\n                float3 toLight = unity_LightPosition[i].xyz - viewpos.xyz * unity_LightPosition[i].w;\n                toLight.z *= -1.0;\n                lightDir.xyz = mul( (float3x3)_CameraToWorld, normalize(toLight) );\n                float lengthSq = dot(toLight, toLight);\n                atten = 1.0 / (1.0 + lengthSq * unity_LightAtten[i].z);\n\n                lightColor.rgb = unity_LightColor[i].rgb;\n        #endif\n\n\n        float diffuse = dot (v.normal, lightDir.xyz);\n        diffuse = max(0, diffuse);\n        diffuse *= _AO * v.tangent.w + _BaseLight;\n        light += lightColor * (diffuse * atten);\n    }\n\n    light.a = 1;\n    o.color = light * _Color * _TreeInstanceColor;\n\n    #ifdef WRITE_ALPHA_1\n    o.color.a = 1;\n    #endif\n\n    UNITY_TRANSFER_FOG(o,o.pos);\n    return o;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 23,
          "type": "struct",
          "name": "v2f",
          "modifiers": "",
          "code": "struct v2f {\n    float4 pos : SV_POSITION;\n    float4 uv : TEXCOORD0;\n    half4 color : TEXCOORD1;\n    UNITY_FOG_COORDS(2)\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 7,
          "modifiers": "_AO, _BaseLight",
          "type": "float",
          "name": "_Occlusion,",
          "code": "float _Occlusion, _AO, _BaseLight;"
        },
        {
          "comment": "",
          "lineNum": 8,
          "modifiers": "",
          "type": "fixed4",
          "name": "_Color;",
          "code": "fixed4 _Color;"
        },
        {
          "comment": "",
          "lineNum": 12,
          "modifiers": "",
          "type": "float3",
          "name": "_TerrainTreeLightDirections[4];",
          "code": "float3 _TerrainTreeLightDirections[4];"
        },
        {
          "comment": "",
          "lineNum": 13,
          "modifiers": "",
          "type": "float4",
          "name": "_TerrainTreeLightColors[4];",
          "code": "float4 _TerrainTreeLightColors[4];"
        },
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "",
          "type": "float4x4",
          "name": "_CameraToWorld;",
          "code": "float4x4 _CameraToWorld;"
        },
        {
          "comment": "",
          "lineNum": 21,
          "modifiers": "",
          "type": "float",
          "name": "_HalfOverCutoff;",
          "code": "float _HalfOverCutoff;"
        }
      ]
    },
    {
      "file": "UnityBuiltin3xTreeLibrary.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_BUILTIN_3X_TREE_LIBRARY_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 25,
          "modifiers": "inline",
          "parameters": "LeafSurfaceOutput s, half3 lightDir, half3 viewDir, half atten",
          "type": "half4",
          "name": "LightingTreeLeaf",
          "code": "inline half4 LightingTreeLeaf (LeafSurfaceOutput s, half3 lightDir, half3 viewDir, half atten)\n{\n    half3 h = normalize (lightDir + viewDir);\n\n    half nl = dot (s.Normal, lightDir);\n\n    half nh = max (0, dot (s.Normal, h));\n    half spec = pow (nh, s.Specular * 128.0) * s.Gloss;\n\n    // view dependent back contribution for translucency\n    fixed backContrib = saturate(dot(viewDir, -lightDir));\n\n    // normally translucency is more like -nl, but looks better when it's view dependent\n    backContrib = lerp(saturate(-nl), backContrib, _TranslucencyViewDependency);\n\n    fixed3 translucencyColor = backContrib * s.Translucency * _TranslucencyColor;\n\n    // wrap-around diffuse\n    nl = max(0, nl * 0.6 + 0.4);\n\n    fixed4 c;\n    /////@TODO: what is is this multiply 2x here???\n    c.rgb = s.Albedo * (translucencyColor * 2 + nl);\n    c.rgb = c.rgb * _LightColor0.rgb + spec;\n\n    // For directional lights, apply less shadow attenuation\n    // based on shadow strength parameter.\n    #if defined(DIRECTIONAL) || defined(DIRECTIONAL_COOKIE)\n    c.rgb *= lerp(1, atten, _ShadowStrength);\n    #else\n    c.rgb *= atten;\n    #endif\n\n    c.a = s.Alpha;\n\n    return c;\n}"
        },
        {
          "comment": "",
          "lineNum": 65,
          "modifiers": "",
          "parameters": "float4 vertex, float3 normal",
          "type": "fixed3",
          "name": "ShadeTranslucentMainLight",
          "code": "fixed3 ShadeTranslucentMainLight (float4 vertex, float3 normal)\n{\n    float3 viewDir = normalize(WorldSpaceViewDir(vertex));\n    float3 lightDir = normalize(WorldSpaceLightDir(vertex));\n    fixed3 lightColor = _LightColor0.rgb;\n\n    float nl = dot (normal, lightDir);\n\n    // view dependent back contribution for translucency\n    fixed backContrib = saturate(dot(viewDir, -lightDir));\n\n    // normally translucency is more like -nl, but looks better when it's view dependent\n    backContrib = lerp(saturate(-nl), backContrib, _TranslucencyViewDependency);\n\n    // wrap-around diffuse\n    fixed diffuse = max(0, nl * 0.6 + 0.4);\n\n    return lightColor.rgb * (diffuse + backContrib * _TranslucencyColor);\n}"
        },
        {
          "comment": "",
          "lineNum": 85,
          "modifiers": "",
          "parameters": "float4 vertex, float3 normal",
          "type": "fixed3",
          "name": "ShadeTranslucentLights",
          "code": "fixed3 ShadeTranslucentLights (float4 vertex, float3 normal)\n{\n    float3 viewDir = normalize(WorldSpaceViewDir(vertex));\n    float3 mainLightDir = normalize(WorldSpaceLightDir(vertex));\n    float3 frontlight = ShadeSH9 (float4(normal,1.0));\n    float3 backlight = ShadeSH9 (float4(-normal,1.0));\n    #ifdef VERTEXLIGHT_ON\n    float3 worldPos = mul(unity_ObjectToWorld, vertex).xyz;\n    frontlight += Shade4PointLights (\n        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n        unity_4LightAtten0, worldPos, normal);\n    backlight += Shade4PointLights (\n        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n        unity_4LightAtten0, worldPos, -normal);\n    #endif\n\n    // view dependent back contribution for translucency using main light as a cue\n    fixed backContrib = saturate(dot(viewDir, -mainLightDir));\n    backlight = lerp(backlight, backlight * backContrib, _TranslucencyViewDependency);\n\n    // as we integrate over whole sphere instead of normal hemi-sphere\n    // lighting gets too washed out, so let's half it down\n    return 0.5 * (frontlight + backlight * _TranslucencyColor);\n}"
        },
        {
          "comment": "",
          "lineNum": 112,
          "modifiers": "",
          "parameters": "inout appdata_full v",
          "type": "void",
          "name": "TreeVertBark",
          "code": "void TreeVertBark (inout appdata_full v)\n{\n    v.vertex.xyz *= _TreeInstanceScale.xyz;\n    v.vertex = AnimateVertex(v.vertex, v.normal, float4(v.color.xy, v.texcoord1.xy));\n\n    v.vertex = Squash(v.vertex);\n\n    v.color.rgb = _TreeInstanceColor.rgb * _Color.rgb;\n    v.normal = normalize(v.normal);\n    v.tangent.xyz = normalize(v.tangent.xyz);\n}"
        },
        {
          "comment": "",
          "lineNum": 124,
          "modifiers": "",
          "parameters": "inout appdata_full v",
          "type": "void",
          "name": "TreeVertLeaf",
          "code": "void TreeVertLeaf (inout appdata_full v)\n{\n    ExpandBillboard (UNITY_MATRIX_IT_MV, v.vertex, v.normal, v.tangent);\n    v.vertex.xyz *= _TreeInstanceScale.xyz;\n    v.vertex = AnimateVertex (v.vertex,v.normal, float4(v.color.xy, v.texcoord1.xy));\n\n    v.vertex = Squash(v.vertex);\n\n    v.color.rgb = _TreeInstanceColor.rgb * _Color.rgb;\n    v.normal = normalize(v.normal);\n    v.tangent.xyz = normalize(v.tangent.xyz);\n}"
        },
        {
          "comment": "",
          "lineNum": 137,
          "modifiers": "",
          "parameters": "float x, float y, float c0",
          "type": "float",
          "name": "ScreenDitherToAlpha",
          "code": "float ScreenDitherToAlpha(float x, float y, float c0)\n{\n#if (SHADER_TARGET > 30) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLCORE) || defined(SHADER_API_GLES3)\n    //dither matrix reference: https://en.wikipedia.org/wiki/Ordered_dithering\n    const float dither[64] = {\n        0, 32, 8, 40, 2, 34, 10, 42,\n        48, 16, 56, 24, 50, 18, 58, 26 ,\n        12, 44, 4, 36, 14, 46, 6, 38 ,\n        60, 28, 52, 20, 62, 30, 54, 22,\n        3, 35, 11, 43, 1, 33, 9, 41,\n        51, 19, 59, 27, 49, 17, 57, 25,\n        15, 47, 7, 39, 13, 45, 5, 37,\n        63, 31, 55, 23, 61, 29, 53, 21 };\n\n    int xMat = int(x) & 7;\n    int yMat = int(y) & 7;\n\n    float limit = (dither[yMat * 8 + xMat] + 11.0) / 64.0;\n    //could also use saturate(step(0.995, c0) + limit*(c0));\n    //original step(limit, c0 + 0.01);\n\n    return lerp(limit*c0, 1.0, c0);\n#else\n    return 1.0;\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 164,
          "modifiers": "",
          "parameters": "float4 screenPos, float fadeAmount",
          "type": "float",
          "name": "ComputeAlphaCoverage",
          "code": "float ComputeAlphaCoverage(float4 screenPos, float fadeAmount)\n{\n#if (SHADER_TARGET > 30) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLCORE) || defined(SHADER_API_GLES3)\n    float2 pixelPosition = screenPos.xy / (screenPos.w + 0.00001);\n    pixelPosition *= _ScreenParams;\n    float coverage = ScreenDitherToAlpha(pixelPosition.x, pixelPosition.y, fadeAmount);\n    return coverage;\n#else\n    return 1.0;\n#endif\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 15,
          "type": "struct",
          "name": "LeafSurfaceOutput",
          "modifiers": "",
          "code": "struct LeafSurfaceOutput {\n    fixed3 Albedo;\n    fixed3 Normal;\n    fixed3 Emission;\n    fixed Translucency;\n    half Specular;\n    fixed Gloss;\n    fixed Alpha;\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 10,
          "modifiers": "",
          "type": "fixed4",
          "name": "_Color;",
          "code": "fixed4 _Color;"
        },
        {
          "comment": "",
          "lineNum": 11,
          "modifiers": "",
          "type": "fixed3",
          "name": "_TranslucencyColor;",
          "code": "fixed3 _TranslucencyColor;"
        },
        {
          "comment": "",
          "lineNum": 12,
          "modifiers": "",
          "type": "fixed",
          "name": "_TranslucencyViewDependency;",
          "code": "fixed _TranslucencyViewDependency;"
        },
        {
          "comment": "",
          "lineNum": 13,
          "modifiers": "",
          "type": "half",
          "name": "_ShadowStrength;",
          "code": "half _ShadowStrength;"
        }
      ]
    },
    {
      "file": "UnityCG.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_CG_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 4,
          "code": "#define UNITY_PI            3.14159265359f"
        },
        {
          "comment": "",
          "lineNum": 5,
          "code": "#define UNITY_TWO_PI        6.28318530718f"
        },
        {
          "comment": "",
          "lineNum": 6,
          "code": "#define UNITY_FOUR_PI       12.56637061436f"
        },
        {
          "comment": "",
          "lineNum": 7,
          "code": "#define UNITY_INV_PI        0.31830988618f"
        },
        {
          "comment": "",
          "lineNum": 8,
          "code": "#define UNITY_INV_TWO_PI    0.15915494309f"
        },
        {
          "comment": "",
          "lineNum": 9,
          "code": "#define UNITY_INV_FOUR_PI   0.07957747155f"
        },
        {
          "comment": "",
          "lineNum": 10,
          "code": "#define UNITY_HALF_PI       1.57079632679f"
        },
        {
          "comment": "",
          "lineNum": 11,
          "code": "#define UNITY_INV_HALF_PI   0.636619772367f"
        },
        {
          "comment": "// Should SH (light probe / ambient) calculations be performed?\n// - When both static and dynamic lightmaps are available, no SH evaluation is performed\n// - When static and dynamic lightmaps are not available, SH evaluation is always performed\n// - For low level LODs, static lightmap and real-time GI from light probes can be combined together\n// - Passes that don't do ambient (additive, shadowcaster etc.) should not do SH either.",
          "lineNum": 18,
          "code": "#define UNITY_SHOULD_SAMPLE_SH (defined(LIGHTPROBE_SH) && !defined(UNITY_PASS_FORWARDADD) && !defined(UNITY_PASS_PREPASSBASE) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(UNITY_PASS_META))"
        },
        {
          "comment": "",
          "lineNum": 25,
          "code": "#define unity_ColorSpaceGrey fixed4(0.5, 0.5, 0.5, 0.5)"
        },
        {
          "comment": "",
          "lineNum": 26,
          "code": "#define unity_ColorSpaceDouble fixed4(2.0, 2.0, 2.0, 2.0)"
        },
        {
          "comment": "",
          "lineNum": 27,
          "code": "#define unity_ColorSpaceDielectricSpec half4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301)"
        },
        {
          "comment": "",
          "lineNum": 28,
          "code": "#define unity_ColorSpaceLuminance half4(0.22, 0.707, 0.071, 0.0) // Legacy: alpha is set to 0.0 to specify gamma mode"
        },
        {
          "comment": "",
          "lineNum": 30,
          "code": "#define unity_ColorSpaceGrey fixed4(0.214041144, 0.214041144, 0.214041144, 0.5)"
        },
        {
          "comment": "",
          "lineNum": 31,
          "code": "#define unity_ColorSpaceDouble fixed4(4.59479380, 4.59479380, 4.59479380, 2.0)"
        },
        {
          "comment": "",
          "lineNum": 32,
          "code": "#define unity_ColorSpaceDielectricSpec half4(0.04, 0.04, 0.04, 1.0 - 0.04) // standard dielectric reflectivity coef at incident angle (= 4%)"
        },
        {
          "comment": "",
          "lineNum": 33,
          "code": "#define unity_ColorSpaceLuminance half4(0.0396819152, 0.458021790, 0.00609653955, 1.0) // Legacy: alpha is set to 1.0 to specify linear mode"
        },
        {
          "comment": "",
          "lineNum": 41,
          "code": "#define USING_LIGHT_MULTI_COMPILE"
        },
        {
          "comment": "// Real-support for depth-format cube shadow map.",
          "lineNum": 46,
          "code": "#define SHADOWS_CUBE_IN_DEPTH_TEX"
        },
        {
          "comment": "",
          "lineNum": 49,
          "code": "#define SCALED_NORMAL v.normal"
        },
        {
          "comment": "// These constants must be kept in sync with RGBMRanges.h",
          "lineNum": 53,
          "code": "#define LIGHTMAP_RGBM_SCALE 5.0"
        },
        {
          "comment": "// These constants must be kept in sync with RGBMRanges.h",
          "lineNum": 54,
          "code": "#define EMISSIVE_RGBM_SCALE 97.0"
        },
        {
          "comment": "// Declares 3x3 matrix 'rotation', filled with tangent space basis",
          "lineNum": 244,
          "code": "#define TANGENT_SPACE_ROTATION \\\n    float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w; \\\n    float3x3 rotation = float3x3( v.tangent.xyz, binormal, v.normal )"
        },
        {
          "comment": "// Transforms 2D UV by scale/bias property",
          "lineNum": 440,
          "code": "#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)"
        },
        {
          "comment": "// Deprecated. Used to transform 4D UV by a fixed function texture matrix. Now just returns the passed UV.",
          "lineNum": 443,
          "code": "#define TRANSFORM_UV(idx) v.texcoord.xy"
        },
        {
          "comment": "",
          "lineNum": 723,
          "code": "#define UnityStereoScreenSpaceUVAdjust(x, y) UnityStereoScreenSpaceUVAdjustInternal(x, y)"
        },
        {
          "comment": "",
          "lineNum": 746,
          "code": "#define TransformStereoScreenSpaceTex(uv, w) uv"
        },
        {
          "comment": "",
          "lineNum": 747,
          "code": "#define UnityStereoTransformScreenSpaceTex(uv) uv"
        },
        {
          "comment": "",
          "lineNum": 748,
          "code": "#define UnityStereoClamp(uv, scaleAndOffset) uv"
        },
        {
          "comment": "// Depth render texture helpers",
          "lineNum": 752,
          "code": "#define DECODE_EYEDEPTH(i) LinearEyeDepth(i)"
        },
        {
          "comment": "// Depth render texture helpers",
          "lineNum": 753,
          "code": "#define COMPUTE_EYEDEPTH(o) o = -UnityObjectToViewPos( v.vertex ).z"
        },
        {
          "comment": "// Depth render texture helpers",
          "lineNum": 754,
          "code": "#define COMPUTE_DEPTH_01 -(UnityObjectToViewPos( v.vertex ).z * _ProjectionParams.w)"
        },
        {
          "comment": "// Depth render texture helpers",
          "lineNum": 755,
          "code": "#define COMPUTE_VIEW_NORMAL normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal))"
        },
        {
          "comment": "// Projected screen position helpers",
          "lineNum": 794,
          "code": "#define V2F_SCREEN_TYPE float4"
        },
        {
          "comment": "    // Rendering into point light (cubemap) shadows",
          "lineNum": 930,
          "code": "    #define V2F_SHADOW_CASTER_NOPOS float3 vec : TEXCOORD0;"
        },
        {
          "comment": "    // Rendering into point light (cubemap) shadows",
          "lineNum": 931,
          "code": "    #define TRANSFER_SHADOW_CASTER_NOPOS_LEGACY(o,opos) o.vec = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz; opos = UnityObjectToClipPos(v.vertex);"
        },
        {
          "comment": "    // Rendering into point light (cubemap) shadows",
          "lineNum": 932,
          "code": "    #define TRANSFER_SHADOW_CASTER_NOPOS(o,opos) o.vec = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz; opos = UnityObjectToClipPos(v.vertex);"
        },
        {
          "comment": "    // Rendering into point light (cubemap) shadows",
          "lineNum": 933,
          "code": "    #define SHADOW_CASTER_FRAGMENT(i) return UnityEncodeCubeShadowDepth ((length(i.vec) + unity_LightShadowBias.x) * _LightPositionRange.w);"
        },
        {
          "comment": "    // Rendering into directional or spot light shadows",
          "lineNum": 937,
          "code": "    #define V2F_SHADOW_CASTER_NOPOS"
        },
        {
          "comment": "    // Rendering into directional or spot light shadows\n    // Let embedding code know that V2F_SHADOW_CASTER_NOPOS is empty; so that it can workaround\n    // empty structs that could possibly be produced.",
          "lineNum": 940,
          "code": "    #define V2F_SHADOW_CASTER_NOPOS_IS_EMPTY"
        },
        {
          "comment": "    // Rendering into directional or spot light shadows\n    // Let embedding code know that V2F_SHADOW_CASTER_NOPOS is empty; so that it can workaround\n    // empty structs that could possibly be produced.",
          "lineNum": 941,
          "code": "    #define TRANSFER_SHADOW_CASTER_NOPOS_LEGACY(o,opos) \\\n        opos = UnityObjectToClipPos(v.vertex.xyz); \\\n        opos = UnityApplyLinearShadowBias(opos);"
        },
        {
          "comment": "    // Rendering into directional or spot light shadows\n    // Let embedding code know that V2F_SHADOW_CASTER_NOPOS is empty; so that it can workaround\n    // empty structs that could possibly be produced.",
          "lineNum": 944,
          "code": "    #define TRANSFER_SHADOW_CASTER_NOPOS(o,opos) \\\n        opos = UnityClipSpaceShadowCasterPos(v.vertex, v.normal); \\\n        opos = UnityApplyLinearShadowBias(opos);"
        },
        {
          "comment": "    // Rendering into directional or spot light shadows\n    // Let embedding code know that V2F_SHADOW_CASTER_NOPOS is empty; so that it can workaround\n    // empty structs that could possibly be produced.",
          "lineNum": 947,
          "code": "    #define SHADOW_CASTER_FRAGMENT(i) return 0;"
        },
        {
          "comment": "// Declare all data needed for shadow caster pass output (any shadow directions/depths/distances as needed),\n// plus clip space position.",
          "lineNum": 952,
          "code": "#define V2F_SHADOW_CASTER V2F_SHADOW_CASTER_NOPOS UNITY_POSITION(pos)"
        },
        {
          "comment": "// Vertex shader part, with support for normal offset shadows. Requires\n// position and normal to be present in the vertex input.",
          "lineNum": 956,
          "code": "#define TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) TRANSFER_SHADOW_CASTER_NOPOS(o,o.pos)"
        },
        {
          "comment": "// Vertex shader part, legacy. No support for normal offset shadows - because\n// that would require vertex normals, which might not be present in user-written shaders.",
          "lineNum": 960,
          "code": "#define TRANSFER_SHADOW_CASTER(o) TRANSFER_SHADOW_CASTER_NOPOS_LEGACY(o,o.pos)"
        },
        {
          "comment": "",
          "lineNum": 966,
          "code": "#define UNITY_OPAQUE_ALPHA(outputAlpha) outputAlpha = 1.0"
        },
        {
          "comment": "        //D3d with reversed Z => z clip range is [near, 0] -> remapping to [0, far]\n        //max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.",
          "lineNum": 990,
          "code": "        #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) max(((1.0-(coord)/_ProjectionParams.y)*_ProjectionParams.z),0)"
        },
        {
          "comment": "        //D3d with reversed Z => z clip range is [near, 0] -> remapping to [0, far]\n        //max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.\n        //GL with reversed z => z clip range is [near, -far] -> should remap in theory but dont do it in practice to save some perf (range is close enough)",
          "lineNum": 993,
          "code": "        #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) max(-(coord), 0)"
        },
        {
          "comment": "        //D3d with reversed Z => z clip range is [near, 0] -> remapping to [0, far]\n        //max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.\n        //GL with reversed z => z clip range is [near, -far] -> should remap in theory but dont do it in practice to save some perf (range is close enough)\n    //D3d without reversed z => z clip range is [0, far] -> nothing to do",
          "lineNum": 997,
          "code": "    #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)"
        },
        {
          "comment": "        //D3d with reversed Z => z clip range is [near, 0] -> remapping to [0, far]\n        //max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.\n        //GL with reversed z => z clip range is [near, -far] -> should remap in theory but dont do it in practice to save some perf (range is close enough)\n    //D3d without reversed z => z clip range is [0, far] -> nothing to do\n    //Opengl => z clip range is [-near, far] -> should remap in theory but dont do it in practice to save some perf (range is close enough)",
          "lineNum": 1000,
          "code": "    #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)"
        },
        {
          "comment": "    // factor = (end-z)/(end-start) = z * (-1/(end-start)) + (end/(end-start))",
          "lineNum": 1005,
          "code": "    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = (coord) * unity_FogParams.z + unity_FogParams.w"
        },
        {
          "comment": "    // factor = (end-z)/(end-start) = z * (-1/(end-start)) + (end/(end-start))\n    // factor = exp(-density*z)",
          "lineNum": 1008,
          "code": "    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = unity_FogParams.y * (coord); unityFogFactor = exp2(-unityFogFactor)"
        },
        {
          "comment": "    // factor = (end-z)/(end-start) = z * (-1/(end-start)) + (end/(end-start))\n    // factor = exp(-density*z)\n    // factor = exp(-(density*z)^2)",
          "lineNum": 1011,
          "code": "    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = unity_FogParams.x * (coord); unityFogFactor = exp2(-unityFogFactor*unityFogFactor)"
        },
        {
          "comment": "    // factor = (end-z)/(end-start) = z * (-1/(end-start)) + (end/(end-start))\n    // factor = exp(-density*z)\n    // factor = exp(-(density*z)^2)",
          "lineNum": 1013,
          "code": "    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = 0.0"
        },
        {
          "comment": "",
          "lineNum": 1016,
          "code": "#define UNITY_CALC_FOG_FACTOR(coord) UNITY_CALC_FOG_FACTOR_RAW(UNITY_Z_0_FAR_FROM_CLIPSPACE(coord))"
        },
        {
          "comment": "",
          "lineNum": 1018,
          "code": "#define UNITY_FOG_COORDS_PACKED(idx, vectype) vectype fogCoord : TEXCOORD##idx;"
        },
        {
          "comment": "",
          "lineNum": 1021,
          "code": "    #define UNITY_FOG_COORDS(idx) UNITY_FOG_COORDS_PACKED(idx, float1)"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex",
          "lineNum": 1025,
          "code": "        #define UNITY_TRANSFER_FOG(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.fogCoord.x = unityFogFactor"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex",
          "lineNum": 1026,
          "code": "        #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.tSpace1.y = tangentSign; o.tSpace2.y = unityFogFactor"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex",
          "lineNum": 1027,
          "code": "        #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.worldPos.w = unityFogFactor"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex",
          "lineNum": 1028,
          "code": "        #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.eyeVec.w = unityFogFactor"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1031,
          "code": "        #define UNITY_TRANSFER_FOG(o,outpos) o.fogCoord.x = (outpos).z"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1032,
          "code": "        #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) o.tSpace2.y = (outpos).z"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1033,
          "code": "        #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) o.worldPos.w = (outpos).z"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1034,
          "code": "        #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) o.eyeVec.w = (outpos).z"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1037,
          "code": "    #define UNITY_FOG_COORDS(idx)"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1038,
          "code": "    #define UNITY_TRANSFER_FOG(o,outpos)"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1039,
          "code": "    #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos)"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1040,
          "code": "    #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos)"
        },
        {
          "comment": "        // mobile or SM2.0: calculate fog factor per-vertex\n        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel",
          "lineNum": 1041,
          "code": "    #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos)"
        },
        {
          "comment": "",
          "lineNum": 1044,
          "code": "#define UNITY_FOG_LERP_COLOR(col,fogCol,fogFac) col.rgb = lerp((fogCol).rgb, (col).rgb, saturate(fogFac))"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color",
          "lineNum": 1050,
          "code": "        #define UNITY_APPLY_FOG_COLOR(coord,col,fogCol) UNITY_FOG_LERP_COLOR(col,fogCol,(coord).x)"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1053,
          "code": "        #define UNITY_APPLY_FOG_COLOR(coord,col,fogCol) UNITY_CALC_FOG_FACTOR((coord).x); UNITY_FOG_LERP_COLOR(col,fogCol,unityFogFactor)"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1055,
          "code": "    #define UNITY_EXTRACT_FOG(name) float _unity_fogCoord = name.fogCoord"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1056,
          "code": "    #define UNITY_EXTRACT_FOG_FROM_TSPACE(name) float _unity_fogCoord = name.tSpace2.y"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1057,
          "code": "    #define UNITY_EXTRACT_FOG_FROM_WORLD_POS(name) float _unity_fogCoord = name.worldPos.w"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1058,
          "code": "    #define UNITY_EXTRACT_FOG_FROM_EYE_VEC(name) float _unity_fogCoord = name.eyeVec.w"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1060,
          "code": "    #define UNITY_APPLY_FOG_COLOR(coord,col,fogCol)"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1061,
          "code": "    #define UNITY_EXTRACT_FOG(name)"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1062,
          "code": "    #define UNITY_EXTRACT_FOG_FROM_TSPACE(name)"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1063,
          "code": "    #define UNITY_EXTRACT_FOG_FROM_WORLD_POS(name)"
        },
        {
          "comment": "        // mobile or SM2.0: fog factor was already calculated per-vertex, so just lerp the color\n        // SM3.0 and PC/console: calculate fog factor and lerp fog color",
          "lineNum": 1064,
          "code": "    #define UNITY_EXTRACT_FOG_FROM_EYE_VEC(name)"
        },
        {
          "comment": "",
          "lineNum": 1068,
          "code": "    #define UNITY_APPLY_FOG(coord,col) UNITY_APPLY_FOG_COLOR(coord,col,fixed4(0,0,0,0))"
        },
        {
          "comment": "",
          "lineNum": 1070,
          "code": "    #define UNITY_APPLY_FOG(coord,col) UNITY_APPLY_FOG_COLOR(coord,col,unity_FogColor)"
        },
        {
          "comment": "// ------------------------------------------------------------------\n//  TBN helpers",
          "lineNum": 1075,
          "code": "#define UNITY_EXTRACT_TBN_0(name) fixed3 _unity_tbn_0 = name.tSpace0.xyz"
        },
        {
          "comment": "// ------------------------------------------------------------------\n//  TBN helpers",
          "lineNum": 1076,
          "code": "#define UNITY_EXTRACT_TBN_1(name) fixed3 _unity_tbn_1 = name.tSpace1.xyz"
        },
        {
          "comment": "// ------------------------------------------------------------------\n//  TBN helpers",
          "lineNum": 1077,
          "code": "#define UNITY_EXTRACT_TBN_2(name) fixed3 _unity_tbn_2 = name.tSpace2.xyz"
        },
        {
          "comment": "",
          "lineNum": 1079,
          "code": "#define UNITY_EXTRACT_TBN(name) UNITY_EXTRACT_TBN_0(name); UNITY_EXTRACT_TBN_1(name); UNITY_EXTRACT_TBN_2(name)"
        },
        {
          "comment": "",
          "lineNum": 1081,
          "code": "#define UNITY_EXTRACT_TBN_T(name) fixed3 _unity_tangent = fixed3(name.tSpace0.x, name.tSpace1.x, name.tSpace2.x)"
        },
        {
          "comment": "",
          "lineNum": 1082,
          "code": "#define UNITY_EXTRACT_TBN_N(name) fixed3 _unity_normal = fixed3(name.tSpace0.z, name.tSpace1.z, name.tSpace2.z)"
        },
        {
          "comment": "",
          "lineNum": 1083,
          "code": "#define UNITY_EXTRACT_TBN_B(name) fixed3 _unity_binormal = cross(_unity_normal, _unity_tangent)"
        },
        {
          "comment": "",
          "lineNum": 1084,
          "code": "#define UNITY_CORRECT_TBN_B_SIGN(name) _unity_binormal *= name.tSpace1.y;"
        },
        {
          "comment": "",
          "lineNum": 1085,
          "code": "#define UNITY_RECONSTRUCT_TBN_0 fixed3 _unity_tbn_0 = fixed3(_unity_tangent.x, _unity_binormal.x, _unity_normal.x)"
        },
        {
          "comment": "",
          "lineNum": 1086,
          "code": "#define UNITY_RECONSTRUCT_TBN_1 fixed3 _unity_tbn_1 = fixed3(_unity_tangent.y, _unity_binormal.y, _unity_normal.y)"
        },
        {
          "comment": "",
          "lineNum": 1087,
          "code": "#define UNITY_RECONSTRUCT_TBN_2 fixed3 _unity_tbn_2 = fixed3(_unity_tangent.z, _unity_binormal.z, _unity_normal.z)"
        },
        {
          "comment": "",
          "lineNum": 1090,
          "code": "    #define UNITY_RECONSTRUCT_TBN(name) UNITY_EXTRACT_TBN_T(name); UNITY_EXTRACT_TBN_N(name); UNITY_EXTRACT_TBN_B(name); UNITY_CORRECT_TBN_B_SIGN(name); UNITY_RECONSTRUCT_TBN_0; UNITY_RECONSTRUCT_TBN_1; UNITY_RECONSTRUCT_TBN_2"
        },
        {
          "comment": "",
          "lineNum": 1092,
          "code": "    #define UNITY_RECONSTRUCT_TBN(name) UNITY_EXTRACT_TBN(name)"
        },
        {
          "comment": "//  LOD cross fade helpers\n// keep all the old macros",
          "lineNum": 1097,
          "code": "#define UNITY_DITHER_CROSSFADE_COORDS"
        },
        {
          "comment": "//  LOD cross fade helpers\n// keep all the old macros",
          "lineNum": 1098,
          "code": "#define UNITY_DITHER_CROSSFADE_COORDS_IDX(idx)"
        },
        {
          "comment": "//  LOD cross fade helpers\n// keep all the old macros",
          "lineNum": 1099,
          "code": "#define UNITY_TRANSFER_DITHER_CROSSFADE(o,v)"
        },
        {
          "comment": "//  LOD cross fade helpers\n// keep all the old macros",
          "lineNum": 1100,
          "code": "#define UNITY_TRANSFER_DITHER_CROSSFADE_HPOS(o,hpos)"
        },
        {
          "comment": "",
          "lineNum": 1103,
          "code": "    #define UNITY_APPLY_DITHER_CROSSFADE(vpos)  UnityApplyDitherCrossFade(vpos)"
        },
        {
          "comment": "",
          "lineNum": 1113,
          "code": "    #define UNITY_APPLY_DITHER_CROSSFADE(vpos)"
        },
        {
          "comment": "// Note: V2F_SHADOW_COLLECTOR and TRANSFER_SHADOW_COLLECTOR are deprecated",
          "lineNum": 1130,
          "code": "#define V2F_SHADOW_COLLECTOR float4 pos : SV_POSITION; float3 _ShadowCoord0 : TEXCOORD0; float3 _ShadowCoord1 : TEXCOORD1; float3 _ShadowCoord2 : TEXCOORD2; float3 _ShadowCoord3 : TEXCOORD3; float4 _WorldPosViewZ : TEXCOORD4"
        },
        {
          "comment": "// Note: V2F_SHADOW_COLLECTOR and TRANSFER_SHADOW_COLLECTOR are deprecated",
          "lineNum": 1131,
          "code": "#define TRANSFER_SHADOW_COLLECTOR(o)    \\\n    o.pos = UnityObjectToClipPos(v.vertex); \\\n    float4 wpos = mul(unity_ObjectToWorld, v.vertex); \\\n    o._WorldPosViewZ.xyz = wpos; \\\n    o._WorldPosViewZ.w = -UnityObjectToViewPos(v.vertex).z; \\\n    o._ShadowCoord0 = mul(unity_WorldToShadow[0], wpos).xyz; \\\n    o._ShadowCoord1 = mul(unity_WorldToShadow[1], wpos).xyz; \\\n    o._ShadowCoord2 = mul(unity_WorldToShadow[2], wpos).xyz; \\\n    o._ShadowCoord3 = mul(unity_WorldToShadow[3], wpos).xyz;"
        },
        {
          "comment": "// Note: SAMPLE_SHADOW_COLLECTOR_SHADOW is deprecated",
          "lineNum": 1142,
          "code": "#define SAMPLE_SHADOW_COLLECTOR_SHADOW(coord) \\\n    half shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture,coord); \\\n    shadow = _LightShadowData.r + shadow * (1-_LightShadowData.r);"
        },
        {
          "comment": "// Note: COMPUTE_SHADOW_COLLECTOR_SHADOW is deprecated",
          "lineNum": 1147,
          "code": "#define COMPUTE_SHADOW_COLLECTOR_SHADOW(i, weights, shadowFade) \\\n    float4 coord = float4(i._ShadowCoord0 * weights[0] + i._ShadowCoord1 * weights[1] + i._ShadowCoord2 * weights[2] + i._ShadowCoord3 * weights[3], 1); \\\n    SAMPLE_SHADOW_COLLECTOR_SHADOW(coord) \\\n    float4 res; \\\n    res.x = saturate(shadow + shadowFade); \\\n    res.y = 1.0; \\\n    res.zw = EncodeFloatRG (1 - i._WorldPosViewZ.w * _ProjectionParams.w); \\\n    return res;"
        },
        {
          "comment": "// Note: deprecated",
          "lineNum": 1158,
          "code": "#define SHADOW_COLLECTOR_FRAGMENT(i) \\\n    float3 fromCenter0 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[0].xyz; \\\n    float3 fromCenter1 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[1].xyz; \\\n    float3 fromCenter2 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[2].xyz; \\\n    float3 fromCenter3 = i._WorldPosViewZ.xyz - unity_ShadowSplitSpheres[3].xyz; \\\n    float4 distances2 = float4(dot(fromCenter0,fromCenter0), dot(fromCenter1,fromCenter1), dot(fromCenter2,fromCenter2), dot(fromCenter3,fromCenter3)); \\\n    float4 cascadeWeights = float4(distances2 < unity_ShadowSplitSqRadii); \\\n    cascadeWeights.yzw = saturate(cascadeWeights.yzw - cascadeWeights.xyz); \\\n    float sphereDist = distance(i._WorldPosViewZ.xyz, unity_ShadowFadeCenterAndType.xyz); \\\n    float shadowFade = saturate(sphereDist * _LightShadowData.z + _LightShadowData.w); \\\n    COMPUTE_SHADOW_COLLECTOR_SHADOW(i, cascadeWeights, shadowFade)"
        },
        {
          "comment": "// Note: deprecated",
          "lineNum": 1170,
          "code": "#define SHADOW_COLLECTOR_FRAGMENT(i) \\\n    float4 viewZ = i._WorldPosViewZ.w; \\\n    float4 zNear = float4( viewZ >= _LightSplitsNear ); \\\n    float4 zFar = float4( viewZ < _LightSplitsFar ); \\\n    float4 cascadeWeights = zNear * zFar; \\\n    float shadowFade = saturate(i._WorldPosViewZ.w * _LightShadowData.z + _LightShadowData.w); \\\n    COMPUTE_SHADOW_COLLECTOR_SHADOW(i, cascadeWeights, shadowFade)"
        },
        {
          "comment": "// Legacy; used to do something on platforms that had to emulate depth textures manually. Now all platforms have native depth textures.",
          "lineNum": 1183,
          "code": "#define UNITY_TRANSFER_DEPTH(oo)"
        },
        {
          "comment": "// Legacy; used to do something on platforms that had to emulate depth textures manually. Now all platforms have native depth textures.\n// Legacy; used to do something on platforms that had to emulate depth textures manually. Now all platforms have native depth textures.",
          "lineNum": 1185,
          "code": "#define UNITY_OUTPUT_DEPTH(i) return 0"
        },
        {
          "comment": "",
          "lineNum": 1189,
          "code": "#define API_HAS_GUARANTEED_R16_SUPPORT !(SHADER_API_VULKAN || SHADER_API_GLES || SHADER_API_GLES3)"
        }
      ],
      "functions": [
        {
          "comment": "// Legacy for compatibility with existing shaders",
          "lineNum": 84,
          "modifiers": "inline",
          "parameters": "",
          "type": "bool",
          "name": "IsGammaSpace",
          "code": "inline bool IsGammaSpace()\n{\n    #ifdef UNITY_COLORSPACE_GAMMA\n        return true;\n    #else\n        return false;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 93,
          "modifiers": "inline",
          "parameters": "float value",
          "type": "float",
          "name": "GammaToLinearSpaceExact",
          "code": "inline float GammaToLinearSpaceExact (float value)\n{\n    if (value <= 0.04045F)\n        return value / 12.92F;\n    else if (value < 1.0F)\n        return pow((value + 0.055F)/1.055F, 2.4F);\n    else\n        return pow(value, 2.2F);\n}"
        },
        {
          "comment": "",
          "lineNum": 103,
          "modifiers": "inline",
          "parameters": "half3 sRGB",
          "type": "half3",
          "name": "GammaToLinearSpace",
          "code": "inline half3 GammaToLinearSpace (half3 sRGB)\n{\n    // Approximate version from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return sRGB * (sRGB * (sRGB * 0.305306011h + 0.682171111h) + 0.012522878h);\n\n    // Precise version, useful for debugging.\n    //return half3(GammaToLinearSpaceExact(sRGB.r), GammaToLinearSpaceExact(sRGB.g), GammaToLinearSpaceExact(sRGB.b));\n}"
        },
        {
          "comment": "",
          "lineNum": 112,
          "modifiers": "inline",
          "parameters": "float value",
          "type": "float",
          "name": "LinearToGammaSpaceExact",
          "code": "inline float LinearToGammaSpaceExact (float value)\n{\n    if (value <= 0.0F)\n        return 0.0F;\n    else if (value <= 0.0031308F)\n        return 12.92F * value;\n    else if (value < 1.0F)\n        return 1.055F * pow(value, 0.4166667F) - 0.055F;\n    else\n        return pow(value, 0.45454545F);\n}"
        },
        {
          "comment": "",
          "lineNum": 124,
          "modifiers": "inline",
          "parameters": "half3 linRGB",
          "type": "half3",
          "name": "LinearToGammaSpace",
          "code": "inline half3 LinearToGammaSpace (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n\n    // Exact version, useful for debugging.\n    //return half3(LinearToGammaSpaceExact(linRGB.r), LinearToGammaSpaceExact(linRGB.g), LinearToGammaSpaceExact(linRGB.b));\n}"
        },
        {
          "comment": "// Tranforms position from world to homogenous space",
          "lineNum": 135,
          "modifiers": "inline",
          "parameters": "in float3 pos",
          "type": "float4",
          "name": "UnityWorldToClipPos",
          "code": "inline float4 UnityWorldToClipPos( in float3 pos )\n{\n    return mul(UNITY_MATRIX_VP, float4(pos, 1.0));\n}"
        },
        {
          "comment": "// Tranforms position from view to homogenous space",
          "lineNum": 141,
          "modifiers": "inline",
          "parameters": "in float3 pos",
          "type": "float4",
          "name": "UnityViewToClipPos",
          "code": "inline float4 UnityViewToClipPos( in float3 pos )\n{\n    return mul(UNITY_MATRIX_P, float4(pos, 1.0));\n}"
        },
        {
          "comment": "// Tranforms position from object to camera space",
          "lineNum": 147,
          "modifiers": "inline",
          "parameters": "in float3 pos",
          "type": "float3",
          "name": "UnityObjectToViewPos",
          "code": "inline float3 UnityObjectToViewPos( in float3 pos )\n{\n    return mul(UNITY_MATRIX_V, mul(unity_ObjectToWorld, float4(pos, 1.0))).xyz;\n}"
        },
        {
          "comment": "// Tranforms position from object to camera space",
          "lineNum": 151,
          "modifiers": "inline",
          "parameters": "float4 pos",
          "type": "float3",
          "name": "UnityObjectToViewPos",
          "code": "inline float3 UnityObjectToViewPos(float4 pos) // overload for float4; avoids \"implicit truncation\" warning for existing shaders\n{\n    return UnityObjectToViewPos(pos.xyz);\n}"
        },
        {
          "comment": "// Tranforms position from world to camera space",
          "lineNum": 157,
          "modifiers": "inline",
          "parameters": "in float3 pos",
          "type": "float3",
          "name": "UnityWorldToViewPos",
          "code": "inline float3 UnityWorldToViewPos( in float3 pos )\n{\n    return mul(UNITY_MATRIX_V, float4(pos, 1.0)).xyz;\n}"
        },
        {
          "comment": "// Transforms direction from object to world space",
          "lineNum": 163,
          "modifiers": "inline",
          "parameters": "in float3 dir",
          "type": "float3",
          "name": "UnityObjectToWorldDir",
          "code": "inline float3 UnityObjectToWorldDir( in float3 dir )\n{\n    return normalize(mul((float3x3)unity_ObjectToWorld, dir));\n}"
        },
        {
          "comment": "// Transforms direction from world to object space",
          "lineNum": 169,
          "modifiers": "inline",
          "parameters": "in float3 dir",
          "type": "float3",
          "name": "UnityWorldToObjectDir",
          "code": "inline float3 UnityWorldToObjectDir( in float3 dir )\n{\n    return normalize(mul((float3x3)unity_WorldToObject, dir));\n}"
        },
        {
          "comment": "// Transforms normal from object to world space",
          "lineNum": 175,
          "modifiers": "inline",
          "parameters": "in float3 norm",
          "type": "float3",
          "name": "UnityObjectToWorldNormal",
          "code": "inline float3 UnityObjectToWorldNormal( in float3 norm )\n{\n#ifdef UNITY_ASSUME_UNIFORM_SCALING\n    return UnityObjectToWorldDir(norm);\n#else\n    // mul(IT_M, norm) => mul(norm, I_M) => {dot(norm, I_M.col0), dot(norm, I_M.col1), dot(norm, I_M.col2)}\n    return normalize(mul(norm, (float3x3)unity_WorldToObject));\n#endif\n}"
        },
        {
          "comment": "// Computes world space light direction, from world space position",
          "lineNum": 186,
          "modifiers": "inline",
          "parameters": "in float3 worldPos",
          "type": "float3",
          "name": "UnityWorldSpaceLightDir",
          "code": "inline float3 UnityWorldSpaceLightDir( in float3 worldPos )\n{\n    #ifndef USING_LIGHT_MULTI_COMPILE\n        return _WorldSpaceLightPos0.xyz - worldPos * _WorldSpaceLightPos0.w;\n    #else\n        #ifndef USING_DIRECTIONAL_LIGHT\n        return _WorldSpaceLightPos0.xyz - worldPos;\n        #else\n        return _WorldSpaceLightPos0.xyz;\n        #endif\n    #endif\n}"
        },
        {
          "comment": "// Computes world space light direction, from object space position\n// *Legacy* Please use UnityWorldSpaceLightDir instead",
          "lineNum": 201,
          "modifiers": "inline",
          "parameters": "in float4 localPos",
          "type": "float3",
          "name": "WorldSpaceLightDir",
          "code": "inline float3 WorldSpaceLightDir( in float4 localPos )\n{\n    float3 worldPos = mul(unity_ObjectToWorld, localPos).xyz;\n    return UnityWorldSpaceLightDir(worldPos);\n}"
        },
        {
          "comment": "// Computes object space light direction",
          "lineNum": 208,
          "modifiers": "inline",
          "parameters": "in float4 v",
          "type": "float3",
          "name": "ObjSpaceLightDir",
          "code": "inline float3 ObjSpaceLightDir( in float4 v )\n{\n    float3 objSpaceLightPos = mul(unity_WorldToObject, _WorldSpaceLightPos0).xyz;\n    #ifndef USING_LIGHT_MULTI_COMPILE\n        return objSpaceLightPos.xyz - v.xyz * _WorldSpaceLightPos0.w;\n    #else\n        #ifndef USING_DIRECTIONAL_LIGHT\n        return objSpaceLightPos.xyz - v.xyz;\n        #else\n        return objSpaceLightPos.xyz;\n        #endif\n    #endif\n}"
        },
        {
          "comment": "// Computes world space view direction, from object space position",
          "lineNum": 223,
          "modifiers": "inline",
          "parameters": "in float3 worldPos",
          "type": "float3",
          "name": "UnityWorldSpaceViewDir",
          "code": "inline float3 UnityWorldSpaceViewDir( in float3 worldPos )\n{\n    return _WorldSpaceCameraPos.xyz - worldPos;\n}"
        },
        {
          "comment": "// Computes world space view direction, from object space position\n// *Legacy* Please use UnityWorldSpaceViewDir instead",
          "lineNum": 230,
          "modifiers": "inline",
          "parameters": "in float4 localPos",
          "type": "float3",
          "name": "WorldSpaceViewDir",
          "code": "inline float3 WorldSpaceViewDir( in float4 localPos )\n{\n    float3 worldPos = mul(unity_ObjectToWorld, localPos).xyz;\n    return UnityWorldSpaceViewDir(worldPos);\n}"
        },
        {
          "comment": "// Computes object space view direction",
          "lineNum": 237,
          "modifiers": "inline",
          "parameters": "in float4 v",
          "type": "float3",
          "name": "ObjSpaceViewDir",
          "code": "inline float3 ObjSpaceViewDir( in float4 v )\n{\n    float3 objSpaceCameraPos = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos.xyz, 1)).xyz;\n    return objSpaceCameraPos - v.xyz;\n}"
        },
        {
          "comment": "// Used in ForwardBase pass: Calculates diffuse lighting from 4 point lights, with data packed in a special way.",
          "lineNum": 251,
          "modifiers": "",
          "parameters": "float4 lightPosX, float4 lightPosY, float4 lightPosZ,    float3 lightColor0, float3 lightColor1, float3 lightColor2, float3 lightColor3,    float4 lightAttenSq,    float3 pos, float3 normal",
          "type": "float3",
          "name": "Shade4PointLights",
          "code": "float3 Shade4PointLights (\n    float4 lightPosX, float4 lightPosY, float4 lightPosZ,\n    float3 lightColor0, float3 lightColor1, float3 lightColor2, float3 lightColor3,\n    float4 lightAttenSq,\n    float3 pos, float3 normal)\n{\n    // to light vectors\n    float4 toLightX = lightPosX - pos.x;\n    float4 toLightY = lightPosY - pos.y;\n    float4 toLightZ = lightPosZ - pos.z;\n    // squared lengths\n    float4 lengthSq = 0;\n    lengthSq += toLightX * toLightX;\n    lengthSq += toLightY * toLightY;\n    lengthSq += toLightZ * toLightZ;\n    // don't produce NaNs if some vertex position overlaps with the light\n    lengthSq = max(lengthSq, 0.000001);\n\n    // NdotL\n    float4 ndotl = 0;\n    ndotl += toLightX * normal.x;\n    ndotl += toLightY * normal.y;\n    ndotl += toLightZ * normal.z;\n    // correct NdotL\n    float4 corr = rsqrt(lengthSq);\n    ndotl = max (float4(0,0,0,0), ndotl * corr);\n    // attenuation\n    float4 atten = 1.0 / (1.0 + lengthSq * lightAttenSq);\n    float4 diff = ndotl * atten;\n    // final color\n    float3 col = 0;\n    col += lightColor0 * diff.x;\n    col += lightColor1 * diff.y;\n    col += lightColor2 * diff.z;\n    col += lightColor3 * diff.w;\n    return col;\n}"
        },
        {
          "comment": "// Used in Vertex pass: Calculates diffuse lighting from lightCount lights. Specifying true to spotLight is more expensive\n// to calculate but lights are treated as spot lights otherwise they are treated as point lights.",
          "lineNum": 291,
          "modifiers": "",
          "parameters": "float4 vertex, float3 normal, int lightCount, bool spotLight",
          "type": "float3",
          "name": "ShadeVertexLightsFull",
          "code": "float3 ShadeVertexLightsFull (float4 vertex, float3 normal, int lightCount, bool spotLight)\n{\n    float3 viewpos = UnityObjectToViewPos (vertex.xyz);\n    float3 viewN = normalize (mul ((float3x3)UNITY_MATRIX_IT_MV, normal));\n\n    float3 lightColor = UNITY_LIGHTMODEL_AMBIENT.xyz;\n    for (int i = 0; i < lightCount; i++) {\n        float3 toLight = unity_LightPosition[i].xyz - viewpos.xyz * unity_LightPosition[i].w;\n        float lengthSq = dot(toLight, toLight);\n\n        // don't produce NaNs if some vertex position overlaps with the light\n        lengthSq = max(lengthSq, 0.000001);\n\n        toLight *= rsqrt(lengthSq);\n\n        float atten = 1.0 / (1.0 + lengthSq * unity_LightAtten[i].z);\n        if (spotLight)\n        {\n            float rho = max (0, dot(toLight, unity_SpotDirection[i].xyz));\n            float spotAtt = (rho - unity_LightAtten[i].x) * unity_LightAtten[i].y;\n            atten *= saturate(spotAtt);\n        }\n\n        float diff = max (0, dot (viewN, toLight));\n        lightColor += unity_LightColor[i].rgb * (diff * atten);\n    }\n    return lightColor;\n}"
        },
        {
          "comment": "",
          "lineNum": 320,
          "modifiers": "",
          "parameters": "float4 vertex, float3 normal",
          "type": "float3",
          "name": "ShadeVertexLights",
          "code": "float3 ShadeVertexLights (float4 vertex, float3 normal)\n{\n    return ShadeVertexLightsFull (vertex, normal, 4, false);\n}"
        },
        {
          "comment": "// normal should be normalized, w=1.0",
          "lineNum": 326,
          "modifiers": "",
          "parameters": "half4 normal",
          "type": "half3",
          "name": "SHEvalLinearL0L1",
          "code": "half3 SHEvalLinearL0L1 (half4 normal)\n{\n    half3 x;\n\n    // Linear (L1) + constant (L0) polynomial terms\n    x.r = dot(unity_SHAr,normal);\n    x.g = dot(unity_SHAg,normal);\n    x.b = dot(unity_SHAb,normal);\n\n    return x;\n}"
        },
        {
          "comment": "// normal should be normalized, w=1.0",
          "lineNum": 339,
          "modifiers": "",
          "parameters": "half4 normal",
          "type": "half3",
          "name": "SHEvalLinearL2",
          "code": "half3 SHEvalLinearL2 (half4 normal)\n{\n    half3 x1, x2;\n    // 4 of the quadratic (L2) polynomials\n    half4 vB = normal.xyzz * normal.yzzx;\n    x1.r = dot(unity_SHBr,vB);\n    x1.g = dot(unity_SHBg,vB);\n    x1.b = dot(unity_SHBb,vB);\n\n    // Final (5th) quadratic (L2) polynomial\n    half vC = normal.x*normal.x - normal.y*normal.y;\n    x2 = unity_SHC.rgb * vC;\n\n    return x1 + x2;\n}"
        },
        {
          "comment": "// normal should be normalized, w=1.0\n// output in active color space",
          "lineNum": 357,
          "modifiers": "",
          "parameters": "half4 normal",
          "type": "half3",
          "name": "ShadeSH9",
          "code": "half3 ShadeSH9 (half4 normal)\n{\n    // Linear + constant polynomial terms\n    half3 res = SHEvalLinearL0L1 (normal);\n\n    // Quadratic polynomials\n    res += SHEvalLinearL2 (normal);\n\n#   ifdef UNITY_COLORSPACE_GAMMA\n        res = LinearToGammaSpace (res);\n#   endif\n\n    return res;\n}"
        },
        {
          "comment": "// OBSOLETE: for backwards compatibility with 5.0",
          "lineNum": 373,
          "modifiers": "",
          "parameters": "half4 normal",
          "type": "half3",
          "name": "ShadeSH3Order",
          "code": "half3 ShadeSH3Order(half4 normal)\n{\n    // Quadratic polynomials\n    half3 res = SHEvalLinearL2 (normal);\n\n#   ifdef UNITY_COLORSPACE_GAMMA\n        res = LinearToGammaSpace (res);\n#   endif\n\n    return res;\n}"
        },
        {
          "comment": "// normal should be normalized, w=1.0",
          "lineNum": 388,
          "modifiers": "",
          "parameters": "half4 normal, float3 worldPos",
          "type": "half3",
          "name": "SHEvalLinearL0L1_SampleProbeVolume",
          "code": "half3 SHEvalLinearL0L1_SampleProbeVolume (half4 normal, float3 worldPos)\n{\n    const float transformToLocal = unity_ProbeVolumeParams.y;\n    const float texelSizeX = unity_ProbeVolumeParams.z;\n\n    //The SH coefficients textures and probe occlusion are packed into 1 atlas.\n    //-------------------------\n    //| ShR | ShG | ShB | Occ |\n    //-------------------------\n\n    float3 position = (transformToLocal == 1.0f) ? mul(unity_ProbeVolumeWorldToObject, float4(worldPos, 1.0)).xyz : worldPos;\n    float3 texCoord = (position - unity_ProbeVolumeMin.xyz) * unity_ProbeVolumeSizeInv.xyz;\n    texCoord.x = texCoord.x * 0.25f;\n\n    // We need to compute proper X coordinate to sample.\n    // Clamp the coordinate otherwize we'll have leaking between RGB coefficients\n    float texCoordX = clamp(texCoord.x, 0.5f * texelSizeX, 0.25f - 0.5f * texelSizeX);\n\n    // sampler state comes from SHr (all SH textures share the same sampler)\n    texCoord.x = texCoordX;\n    half4 SHAr = UNITY_SAMPLE_TEX3D_SAMPLER(unity_ProbeVolumeSH, unity_ProbeVolumeSH, texCoord);\n\n    texCoord.x = texCoordX + 0.25f;\n    half4 SHAg = UNITY_SAMPLE_TEX3D_SAMPLER(unity_ProbeVolumeSH, unity_ProbeVolumeSH, texCoord);\n\n    texCoord.x = texCoordX + 0.5f;\n    half4 SHAb = UNITY_SAMPLE_TEX3D_SAMPLER(unity_ProbeVolumeSH, unity_ProbeVolumeSH, texCoord);\n\n    // Linear + constant polynomial terms\n    half3 x1;\n    x1.r = dot(SHAr, normal);\n    x1.g = dot(SHAg, normal);\n    x1.b = dot(SHAb, normal);\n\n    return x1;\n}"
        },
        {
          "comment": "// normal should be normalized, w=1.0",
          "lineNum": 427,
          "modifiers": "",
          "parameters": "half4 normal",
          "type": "half3",
          "name": "ShadeSH12Order",
          "code": "half3 ShadeSH12Order (half4 normal)\n{\n    // Linear + constant polynomial terms\n    half3 res = SHEvalLinearL0L1 (normal);\n\n#   ifdef UNITY_COLORSPACE_GAMMA\n        res = LinearToGammaSpace (res);\n#   endif\n\n    return res;\n}"
        },
        {
          "comment": "",
          "lineNum": 453,
          "modifiers": "inline",
          "parameters": "v2f_vertex_lit i, sampler2D mainTex",
          "type": "fixed4",
          "name": "VertexLight",
          "code": "inline fixed4 VertexLight( v2f_vertex_lit i, sampler2D mainTex )\n{\n    fixed4 texcol = tex2D( mainTex, i.uv );\n    fixed4 c;\n    c.xyz = ( texcol.xyz * i.diff.xyz + i.spec.xyz * texcol.a );\n    c.w = texcol.w * i.diff.w;\n    return c;\n}"
        },
        {
          "comment": "// Calculates UV offset for parallax bump mapping",
          "lineNum": 464,
          "modifiers": "inline",
          "parameters": "half h, half height, half3 viewDir",
          "type": "float2",
          "name": "ParallaxOffset",
          "code": "inline float2 ParallaxOffset( half h, half height, half3 viewDir )\n{\n    h = h * height - height/2.0;\n    float3 v = normalize(viewDir);\n    v.z += 0.42;\n    return h * (v.xy / v.z);\n}"
        },
        {
          "comment": "// Converts color to luminance (grayscale)",
          "lineNum": 473,
          "modifiers": "inline",
          "parameters": "half3 rgb",
          "type": "half",
          "name": "Luminance",
          "code": "inline half Luminance(half3 rgb)\n{\n    return dot(rgb, unity_ColorSpaceLuminance.rgb);\n}"
        },
        {
          "comment": "// Convert rgb to luminance\n// with rgb in linear space with sRGB primaries and D65 white point",
          "lineNum": 480,
          "modifiers": "",
          "parameters": "half3 linearRgb",
          "type": "half",
          "name": "LinearRgbToLuminance",
          "code": "half LinearRgbToLuminance(half3 linearRgb)\n{\n    return dot(linearRgb, half3(0.2126729f,  0.7151522f, 0.0721750f));\n}"
        },
        {
          "comment": "",
          "lineNum": 485,
          "modifiers": "",
          "parameters": "half3 color, float maxRGBM",
          "type": "half4",
          "name": "UnityEncodeRGBM",
          "code": "half4 UnityEncodeRGBM (half3 color, float maxRGBM)\n{\n    float kOneOverRGBMMaxRange = 1.0 / maxRGBM;\n    const float kMinMultiplier = 2.0 * 1e-2;\n\n    float3 rgb = color * kOneOverRGBMMaxRange;\n    float alpha = max(max(rgb.r, rgb.g), max(rgb.b, kMinMultiplier));\n    alpha = ceil(alpha * 255.0) / 255.0;\n\n    // Division-by-zero warning from d3d9, so make compiler happy.\n    alpha = max(alpha, kMinMultiplier);\n\n    return half4(rgb / alpha, alpha);\n}"
        },
        {
          "comment": "// Decodes HDR textures\n// handles dLDR, RGBM formats",
          "lineNum": 502,
          "modifiers": "inline",
          "parameters": "half4 data, half4 decodeInstructions",
          "type": "half3",
          "name": "DecodeHDR",
          "code": "inline half3 DecodeHDR (half4 data, half4 decodeInstructions)\n{\n    // Take into account texture alpha if decodeInstructions.w is true(the alpha value affects the RGB channels)\n    half alpha = decodeInstructions.w * (data.a - 1.0) + 1.0;\n\n    // If Linear mode is not supported we can skip exponent part\n    #if defined(UNITY_COLORSPACE_GAMMA)\n        return (decodeInstructions.x * alpha) * data.rgb;\n    #else\n    #   if defined(UNITY_USE_NATIVE_HDR)\n            return decodeInstructions.x * data.rgb; // Multiplier for future HDRI relative to absolute conversion.\n    #   else\n            return (decodeInstructions.x * pow(alpha, decodeInstructions.y)) * data.rgb;\n    #   endif\n    #endif\n}"
        },
        {
          "comment": "// Decodes HDR textures\n// handles dLDR, RGBM formats",
          "lineNum": 521,
          "modifiers": "inline",
          "parameters": "half4 data, half4 decodeInstructions",
          "type": "half3",
          "name": "DecodeLightmapRGBM",
          "code": "inline half3 DecodeLightmapRGBM (half4 data, half4 decodeInstructions)\n{\n    // If Linear mode is not supported we can skip exponent part\n    #if defined(UNITY_COLORSPACE_GAMMA)\n    # if defined(UNITY_FORCE_LINEAR_READ_FOR_RGBM)\n        return (decodeInstructions.x * data.a) * sqrt(data.rgb);\n    # else\n        return (decodeInstructions.x * data.a) * data.rgb;\n    # endif\n    #else\n        return (decodeInstructions.x * pow(data.a, decodeInstructions.y)) * data.rgb;\n    #endif\n}"
        },
        {
          "comment": "// Decodes doubleLDR encoded lightmaps.",
          "lineNum": 536,
          "modifiers": "inline",
          "parameters": "fixed4 color, half4 decodeInstructions",
          "type": "half3",
          "name": "DecodeLightmapDoubleLDR",
          "code": "inline half3 DecodeLightmapDoubleLDR( fixed4 color, half4 decodeInstructions)\n{\n    // decodeInstructions.x contains 2.0 when gamma color space is used or pow(2.0, 2.2) = 4.59 when linear color space is used on mobile platforms\n    return decodeInstructions.x * color.rgb;\n}"
        },
        {
          "comment": "",
          "lineNum": 542,
          "modifiers": "inline",
          "parameters": "fixed4 color, half4 decodeInstructions",
          "type": "half3",
          "name": "DecodeLightmap",
          "code": "inline half3 DecodeLightmap( fixed4 color, half4 decodeInstructions)\n{\n#if defined(UNITY_LIGHTMAP_DLDR_ENCODING)\n    return DecodeLightmapDoubleLDR(color, decodeInstructions);\n#elif defined(UNITY_LIGHTMAP_RGBM_ENCODING)\n    return DecodeLightmapRGBM(color, decodeInstructions);\n#else //defined(UNITY_LIGHTMAP_FULL_HDR)\n    return color.rgb;\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 555,
          "modifiers": "inline",
          "parameters": "fixed4 color",
          "type": "half3",
          "name": "DecodeLightmap",
          "code": "inline half3 DecodeLightmap( fixed4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}"
        },
        {
          "comment": "// Decodes Enlighten RGBM encoded lightmaps\n// NOTE: Enlighten dynamic texture RGBM format is _different_ from standard Unity HDR textures\n// (such as Baked Lightmaps, Reflection Probes and IBL images)\n// Instead Enlighten provides RGBM texture in _Linear_ color space with _different_ exponent.\n// WARNING: 3 pow operations, might be very expensive for mobiles!",
          "lineNum": 567,
          "modifiers": "inline",
          "parameters": "fixed4 color",
          "type": "half3",
          "name": "DecodeRealtimeLightmap",
          "code": "inline half3 DecodeRealtimeLightmap( fixed4 color )\n{\n    //@TODO: Temporary until Geomerics gives us an API to convert lightmaps to RGBM in gamma space on the enlighten thread before we upload the textures.\n#if defined(UNITY_FORCE_LINEAR_READ_FOR_RGBM)\n    return pow ((unity_DynamicLightmap_HDR.x * color.a) * sqrt(color.rgb), unity_DynamicLightmap_HDR.y);\n#else\n    return pow ((unity_DynamicLightmap_HDR.x * color.a) * color.rgb, unity_DynamicLightmap_HDR.y);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 577,
          "modifiers": "inline",
          "parameters": "half3 color, fixed4 dirTex, half3 normalWorld",
          "type": "half3",
          "name": "DecodeDirectionalLightmap",
          "code": "inline half3 DecodeDirectionalLightmap (half3 color, fixed4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}"
        },
        {
          "comment": "// Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.",
          "lineNum": 592,
          "modifiers": "inline",
          "parameters": "float v",
          "type": "float4",
          "name": "EncodeFloatRGBA",
          "code": "inline float4 EncodeFloatRGBA( float v )\n{\n    float4 kEncodeMul = float4(1.0, 255.0, 65025.0, 16581375.0);\n    float kEncodeBit = 1.0/255.0;\n    float4 enc = kEncodeMul * v;\n    enc = frac (enc);\n    enc -= enc.yzww * kEncodeBit;\n    return enc;\n}"
        },
        {
          "comment": "// Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.",
          "lineNum": 601,
          "modifiers": "inline",
          "parameters": "float4 enc",
          "type": "float",
          "name": "DecodeFloatRGBA",
          "code": "inline float DecodeFloatRGBA( float4 enc )\n{\n    float4 kDecodeDot = float4(1.0, 1/255.0, 1/65025.0, 1/16581375.0);\n    return dot( enc, kDecodeDot );\n}"
        },
        {
          "comment": "// Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.",
          "lineNum": 608,
          "modifiers": "inline",
          "parameters": "float v",
          "type": "float2",
          "name": "EncodeFloatRG",
          "code": "inline float2 EncodeFloatRG( float v )\n{\n    float2 kEncodeMul = float2(1.0, 255.0);\n    float kEncodeBit = 1.0/255.0;\n    float2 enc = kEncodeMul * v;\n    enc = frac (enc);\n    enc.x -= enc.y * kEncodeBit;\n    return enc;\n}"
        },
        {
          "comment": "// Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.",
          "lineNum": 617,
          "modifiers": "inline",
          "parameters": "float2 enc",
          "type": "float",
          "name": "DecodeFloatRG",
          "code": "inline float DecodeFloatRG( float2 enc )\n{\n    float2 kDecodeDot = float2(1.0, 1/255.0);\n    return dot( enc, kDecodeDot );\n}"
        },
        {
          "comment": "// Encoding/decoding view space normals into 2D 0..1 vector",
          "lineNum": 625,
          "modifiers": "inline",
          "parameters": "float3 n",
          "type": "float2",
          "name": "EncodeViewNormalStereo",
          "code": "inline float2 EncodeViewNormalStereo( float3 n )\n{\n    float kScale = 1.7777;\n    float2 enc;\n    enc = n.xy / (n.z+1);\n    enc /= kScale;\n    enc = enc*0.5+0.5;\n    return enc;\n}"
        },
        {
          "comment": "// Encoding/decoding view space normals into 2D 0..1 vector",
          "lineNum": 634,
          "modifiers": "inline",
          "parameters": "float4 enc4",
          "type": "float3",
          "name": "DecodeViewNormalStereo",
          "code": "inline float3 DecodeViewNormalStereo( float4 enc4 )\n{\n    float kScale = 1.7777;\n    float3 nn = enc4.xyz*float3(2*kScale,2*kScale,0) + float3(-kScale,-kScale,1);\n    float g = 2.0 / dot(nn.xyz,nn.xyz);\n    float3 n;\n    n.xy = g*nn.xy;\n    n.z = g-1;\n    return n;\n}"
        },
        {
          "comment": "",
          "lineNum": 645,
          "modifiers": "inline",
          "parameters": "float depth, float3 normal",
          "type": "float4",
          "name": "EncodeDepthNormal",
          "code": "inline float4 EncodeDepthNormal( float depth, float3 normal )\n{\n    float4 enc;\n    enc.xy = EncodeViewNormalStereo (normal);\n    enc.zw = EncodeFloatRG (depth);\n    return enc;\n}"
        },
        {
          "comment": "",
          "lineNum": 653,
          "modifiers": "inline",
          "parameters": "float4 enc, out float depth, out float3 normal",
          "type": "void",
          "name": "DecodeDepthNormal",
          "code": "inline void DecodeDepthNormal( float4 enc, out float depth, out float3 normal )\n{\n    depth = DecodeFloatRG (enc.zw);\n    normal = DecodeViewNormalStereo (enc);\n}"
        },
        {
          "comment": "",
          "lineNum": 659,
          "modifiers": "inline",
          "parameters": "fixed4 packednormal",
          "type": "fixed3",
          "name": "UnpackNormalDXT5nm",
          "code": "inline fixed3 UnpackNormalDXT5nm (fixed4 packednormal)\n{\n    fixed3 normal;\n    normal.xy = packednormal.wy * 2 - 1;\n    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}"
        },
        {
          "comment": "// Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n// Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5",
          "lineNum": 669,
          "modifiers": "",
          "parameters": "fixed4 packednormal",
          "type": "fixed3",
          "name": "UnpackNormalmapRGorAG",
          "code": "fixed3 UnpackNormalmapRGorAG(fixed4 packednormal)\n{\n    // This do the trick\n   packednormal.x *= packednormal.w;\n\n    fixed3 normal;\n    normal.xy = packednormal.xy * 2 - 1;\n    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}"
        },
        {
          "comment": "",
          "lineNum": 679,
          "modifiers": "inline",
          "parameters": "fixed4 packednormal",
          "type": "fixed3",
          "name": "UnpackNormal",
          "code": "inline fixed3 UnpackNormal(fixed4 packednormal)\n{\n#if defined(UNITY_NO_DXT5nm)\n    return packednormal.xyz * 2 - 1;\n#else\n    return UnpackNormalmapRGorAG(packednormal);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 688,
          "modifiers": "",
          "parameters": "fixed4 packednormal, float scale",
          "type": "fixed3",
          "name": "UnpackNormalWithScale",
          "code": "fixed3 UnpackNormalWithScale(fixed4 packednormal, float scale)\n{\n#ifndef UNITY_NO_DXT5nm\n    // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n    // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n    packednormal.x *= packednormal.w;\n#endif\n    fixed3 normal;\n    normal.xy = (packednormal.xy * 2 - 1) * scale;\n    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}"
        },
        {
          "comment": "// Z buffer to linear 0..1 depth",
          "lineNum": 702,
          "modifiers": "inline",
          "parameters": "float z",
          "type": "float",
          "name": "Linear01Depth",
          "code": "inline float Linear01Depth( float z )\n{\n    return 1.0 / (_ZBufferParams.x * z + _ZBufferParams.y);\n}"
        },
        {
          "comment": "// Z buffer to linear 0..1 depth\n// Z buffer to linear depth",
          "lineNum": 707,
          "modifiers": "inline",
          "parameters": "float z",
          "type": "float",
          "name": "LinearEyeDepth",
          "code": "inline float LinearEyeDepth( float z )\n{\n    return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);\n}"
        },
        {
          "comment": "",
          "lineNum": 713,
          "modifiers": "inline",
          "parameters": "float2 uv, float4 scaleAndOffset",
          "type": "float2",
          "name": "UnityStereoScreenSpaceUVAdjustInternal",
          "code": "inline float2 UnityStereoScreenSpaceUVAdjustInternal(float2 uv, float4 scaleAndOffset)\n{\n    return uv.xy * scaleAndOffset.xy + scaleAndOffset.zw;\n}"
        },
        {
          "comment": "",
          "lineNum": 718,
          "modifiers": "inline",
          "parameters": "float4 uv, float4 scaleAndOffset",
          "type": "float4",
          "name": "UnityStereoScreenSpaceUVAdjustInternal",
          "code": "inline float4 UnityStereoScreenSpaceUVAdjustInternal(float4 uv, float4 scaleAndOffset)\n{\n    return float4(UnityStereoScreenSpaceUVAdjustInternal(uv.xy, scaleAndOffset), UnityStereoScreenSpaceUVAdjustInternal(uv.zw, scaleAndOffset));\n}"
        },
        {
          "comment": "",
          "lineNum": 726,
          "modifiers": "",
          "parameters": "float2 uv, float w",
          "type": "float2",
          "name": "TransformStereoScreenSpaceTex",
          "code": "float2 TransformStereoScreenSpaceTex(float2 uv, float w)\n{\n    float4 scaleOffset = unity_StereoScaleOffset[unity_StereoEyeIndex];\n    return uv.xy * scaleOffset.xy + scaleOffset.zw * w;\n}"
        },
        {
          "comment": "",
          "lineNum": 732,
          "modifiers": "inline",
          "parameters": "float2 uv",
          "type": "float2",
          "name": "UnityStereoTransformScreenSpaceTex",
          "code": "inline float2 UnityStereoTransformScreenSpaceTex(float2 uv)\n{\n    return TransformStereoScreenSpaceTex(saturate(uv), 1.0);\n}"
        },
        {
          "comment": "",
          "lineNum": 737,
          "modifiers": "inline",
          "parameters": "float4 uv",
          "type": "float4",
          "name": "UnityStereoTransformScreenSpaceTex",
          "code": "inline float4 UnityStereoTransformScreenSpaceTex(float4 uv)\n{\n    return float4(UnityStereoTransformScreenSpaceTex(uv.xy), UnityStereoTransformScreenSpaceTex(uv.zw));\n}"
        },
        {
          "comment": "",
          "lineNum": 741,
          "modifiers": "inline",
          "parameters": "float2 uv, float4 scaleAndOffset",
          "type": "float2",
          "name": "UnityStereoClamp",
          "code": "inline float2 UnityStereoClamp(float2 uv, float4 scaleAndOffset)\n{\n    return float2(clamp(uv.x, scaleAndOffset.z, scaleAndOffset.z + scaleAndOffset.x), uv.y);\n}"
        },
        {
          "comment": "",
          "lineNum": 775,
          "modifiers": "",
          "parameters": "float4x4 mat, float2 inUV",
          "type": "float2",
          "name": "MultiplyUV",
          "code": "float2 MultiplyUV (float4x4 mat, float2 inUV) {\n    float4 temp = float4 (inUV.x, inUV.y, 0, 0);\n    temp = mul (mat, temp);\n    return temp.xy;\n}"
        },
        {
          "comment": "",
          "lineNum": 781,
          "modifiers": "",
          "parameters": "appdata_img v",
          "type": "v2f_img",
          "name": "vert_img",
          "code": "v2f_img vert_img( appdata_img v )\n{\n    v2f_img o;\n    UNITY_INITIALIZE_OUTPUT(v2f_img, o);\n    UNITY_SETUP_INSTANCE_ID(v);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n    o.pos = UnityObjectToClipPos (v.vertex);\n    o.uv = v.texcoord;\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 796,
          "modifiers": "inline",
          "parameters": "float4 pos",
          "type": "float4",
          "name": "ComputeNonStereoScreenPos",
          "code": "inline float4 ComputeNonStereoScreenPos(float4 pos) {\n    float4 o = pos * 0.5f;\n    o.xy = float2(o.x, o.y*_ProjectionParams.x) + o.w;\n    o.zw = pos.zw;\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 803,
          "modifiers": "inline",
          "parameters": "float4 pos",
          "type": "float4",
          "name": "ComputeScreenPos",
          "code": "inline float4 ComputeScreenPos(float4 pos) {\n    float4 o = ComputeNonStereoScreenPos(pos);\n#if defined(UNITY_SINGLE_PASS_STEREO)\n    o.xy = TransformStereoScreenSpaceTex(o.xy, pos.w);\n#endif\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 811,
          "modifiers": "inline",
          "parameters": "float4 pos",
          "type": "float4",
          "name": "ComputeGrabScreenPos",
          "code": "inline float4 ComputeGrabScreenPos (float4 pos) {\n    #if UNITY_UV_STARTS_AT_TOP\n    float scale = -1.0;\n    #else\n    float scale = 1.0;\n    #endif\n    float4 o = pos * 0.5f;\n    o.xy = float2(o.x, o.y*scale) + o.w;\n#ifdef UNITY_SINGLE_PASS_STEREO\n    o.xy = TransformStereoScreenSpaceTex(o.xy, pos.w);\n#endif\n    o.zw = pos.zw;\n    return o;\n}"
        },
        {
          "comment": "// snaps post-transformed position to screen pixels",
          "lineNum": 827,
          "modifiers": "inline",
          "parameters": "float4 pos",
          "type": "float4",
          "name": "UnityPixelSnap",
          "code": "inline float4 UnityPixelSnap (float4 pos)\n{\n    float2 hpc = _ScreenParams.xy * 0.5f;\n#if  SHADER_API_PSSL\n// sdk 4.5 splits round into v_floor_f32(x+0.5) ... sdk 5.0 uses v_rndne_f32, for compatabilty we use the 4.5 version\n    float2 temp = ((pos.xy / pos.w) * hpc) + float2(0.5f,0.5f);\n    float2 pixelPos = float2(__v_floor_f32(temp.x), __v_floor_f32(temp.y));\n#else\n    float2 pixelPos = round ((pos.xy / pos.w) * hpc);\n#endif\n    pos.xy = pixelPos / hpc * pos.w;\n    return pos;\n}"
        },
        {
          "comment": "",
          "lineNum": 841,
          "modifiers": "inline",
          "parameters": "float2 v",
          "type": "float2",
          "name": "TransformViewToProjection",
          "code": "inline float2 TransformViewToProjection (float2 v) {\n    return mul((float2x2)UNITY_MATRIX_P, v);\n}"
        },
        {
          "comment": "",
          "lineNum": 845,
          "modifiers": "inline",
          "parameters": "float3 v",
          "type": "float3",
          "name": "TransformViewToProjection",
          "code": "inline float3 TransformViewToProjection (float3 v) {\n    return mul((float3x3)UNITY_MATRIX_P, v);\n}"
        },
        {
          "comment": "",
          "lineNum": 851,
          "modifiers": "",
          "parameters": "float z",
          "type": "float4",
          "name": "UnityEncodeCubeShadowDepth",
          "code": "float4 UnityEncodeCubeShadowDepth (float z)\n{\n    #ifdef UNITY_USE_RGBA_FOR_POINT_SHADOWS\n    return EncodeFloatRGBA (min(z, 0.999));\n    #else\n    return z;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 860,
          "modifiers": "",
          "parameters": "float4 vals",
          "type": "float",
          "name": "UnityDecodeCubeShadowDepth",
          "code": "float UnityDecodeCubeShadowDepth (float4 vals)\n{\n    #ifdef UNITY_USE_RGBA_FOR_POINT_SHADOWS\n    return DecodeFloatRGBA (vals);\n    #else\n    return vals.r;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 870,
          "modifiers": "",
          "parameters": "float4 vertex, float3 normal",
          "type": "float4",
          "name": "UnityClipSpaceShadowCasterPos",
          "code": "float4 UnityClipSpaceShadowCasterPos(float4 vertex, float3 normal)\n{\n    float4 wPos = mul(unity_ObjectToWorld, vertex);\n\n    if (unity_LightShadowBias.z != 0.0)\n    {\n        float3 wNormal = UnityObjectToWorldNormal(normal);\n        float3 wLight = normalize(UnityWorldSpaceLightDir(wPos.xyz));\n\n        // apply normal offset bias (inset position along the normal)\n        // bias needs to be scaled by sine between normal and light direction\n        // (http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/)\n        //\n        // unity_LightShadowBias.z contains user-specified normal offset amount\n        // scaled by world space texel size.\n\n        float shadowCos = dot(wNormal, wLight);\n        float shadowSine = sqrt(1-shadowCos*shadowCos);\n        float normalBias = unity_LightShadowBias.z * shadowSine;\n\n        wPos.xyz -= wNormal * normalBias;\n    }\n\n    return mul(UNITY_MATRIX_VP, wPos);\n}"
        },
        {
          "comment": "// Legacy, not used anymore; kept around to not break existing user shaders",
          "lineNum": 896,
          "modifiers": "",
          "parameters": "float3 vertex, float3 normal",
          "type": "float4",
          "name": "UnityClipSpaceShadowCasterPos",
          "code": "float4 UnityClipSpaceShadowCasterPos(float3 vertex, float3 normal)\n{\n    return UnityClipSpaceShadowCasterPos(float4(vertex, 1), normal);\n}"
        },
        {
          "comment": "",
          "lineNum": 902,
          "modifiers": "",
          "parameters": "float4 clipPos",
          "type": "float4",
          "name": "UnityApplyLinearShadowBias",
          "code": "float4 UnityApplyLinearShadowBias(float4 clipPos)\n\n{\n    // For point lights that support depth cube map, the bias is applied in the fragment shader sampling the shadow map.\n    // This is because the legacy behaviour for point light shadow map cannot be implemented by offseting the vertex position\n    // in the vertex shader generating the shadow map.\n#if !(defined(SHADOWS_CUBE) && defined(SHADOWS_CUBE_IN_DEPTH_TEX))\n    #if defined(UNITY_REVERSED_Z)\n        // We use max/min instead of clamp to ensure proper handling of the rare case\n        // where both numerator and denominator are zero and the fraction becomes NaN.\n        clipPos.z += max(-1, min(unity_LightShadowBias.x / clipPos.w, 0));\n    #else\n        clipPos.z += saturate(unity_LightShadowBias.x/clipPos.w);\n    #endif\n#endif\n\n#if defined(UNITY_REVERSED_Z)\n    float clamped = min(clipPos.z, clipPos.w*UNITY_NEAR_CLIP_VALUE);\n#else\n    float clamped = max(clipPos.z, clipPos.w*UNITY_NEAR_CLIP_VALUE);\n#endif\n    clipPos.z = lerp(clipPos.z, clamped, unity_LightShadowBias.y);\n    return clipPos;\n}"
        },
        {
          "comment": "",
          "lineNum": 1105,
          "modifiers": "",
          "parameters": "float2 vpos",
          "type": "void",
          "name": "UnityApplyDitherCrossFade",
          "code": "    void UnityApplyDitherCrossFade(float2 vpos)\n    {\n        vpos /= 4; // the dither mask texture is 4x4\n        float mask = tex2D(unity_DitherMask, vpos).a;\n        float sgn = unity_LODFade.x > 0 ? 1.0f : -1.0f;\n        clip(unity_LODFade.x - mask * sgn);\n    }"
        },
        {
          "comment": "",
          "lineNum": 1191,
          "modifiers": "",
          "parameters": "float height",
          "type": "float4",
          "name": "PackHeightmap",
          "code": "float4 PackHeightmap(float height)\n{\n    #if (API_HAS_GUARANTEED_R16_SUPPORT)\n        return height;\n    #else\n        uint a = (uint)(65535.0f * height);\n        return float4((a >> 0) & 0xFF, (a >> 8) & 0xFF, 0, 0) / 255.0f;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 1201,
          "modifiers": "",
          "parameters": "float4 height",
          "type": "float",
          "name": "UnpackHeightmap",
          "code": "float UnpackHeightmap(float4 height)\n{\n    #if (API_HAS_GUARANTEED_R16_SUPPORT)\n        return height.r;\n    #else\n        return (height.r + height.g * 256.0f) / 257.0f; // (255.0f * height.r + 255.0f * 256.0f * height.g) / 65535.0f\n    #endif\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 56,
          "type": "struct",
          "name": "appdata_base",
          "modifiers": "",
          "code": "struct appdata_base {\n    float4 vertex : POSITION;\n    float3 normal : NORMAL;\n    float4 texcoord : TEXCOORD0;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 63,
          "type": "struct",
          "name": "appdata_tan",
          "modifiers": "",
          "code": "struct appdata_tan {\n    float4 vertex : POSITION;\n    float4 tangent : TANGENT;\n    float3 normal : NORMAL;\n    float4 texcoord : TEXCOORD0;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 71,
          "type": "struct",
          "name": "appdata_full",
          "modifiers": "",
          "code": "struct appdata_full {\n    float4 vertex : POSITION;\n    float4 tangent : TANGENT;\n    float3 normal : NORMAL;\n    float4 texcoord : TEXCOORD0;\n    float4 texcoord1 : TEXCOORD1;\n    float4 texcoord2 : TEXCOORD2;\n    float4 texcoord3 : TEXCOORD3;\n    fixed4 color : COLOR;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 447,
          "type": "struct",
          "name": "v2f_vertex_lit",
          "modifiers": "",
          "code": "struct v2f_vertex_lit {\n    float2 uv   : TEXCOORD0;\n    fixed4 diff : COLOR0;\n    fixed4 spec : COLOR1;\n};"
        },
        {
          "comment": "",
          "lineNum": 760,
          "type": "struct",
          "name": "appdata_img",
          "modifiers": "",
          "code": "struct appdata_img\n{\n    float4 vertex : POSITION;\n    half2 texcoord : TEXCOORD0;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 767,
          "type": "struct",
          "name": "v2f_img",
          "modifiers": "",
          "code": "struct v2f_img\n{\n    float4 pos : SV_POSITION;\n    half2 uv : TEXCOORD0;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 553,
          "modifiers": "",
          "type": "half4",
          "name": "unity_Lightmap_HDR;",
          "code": "half4 unity_Lightmap_HDR;"
        },
        {
          "comment": "",
          "lineNum": 560,
          "modifiers": "",
          "type": "half4",
          "name": "unity_DynamicLightmap_HDR;",
          "code": "half4 unity_DynamicLightmap_HDR;"
        },
        {
          "comment": "",
          "lineNum": 1104,
          "modifiers": "",
          "type": "sampler2D",
          "name": "unity_DitherMask;",
          "code": "sampler2D unity_DitherMask;"
        }
      ]
    },
    {
      "file": "UnityCustomRenderTexture.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_CUSTOM_TEXTURE_INCLUDED"
        },
        {
          "comment": "// Keep in sync with CustomRenderTexture.h",
          "lineNum": 8,
          "code": "#define kCustomTextureBatchSize 16"
        },
        {
          "comment": "",
          "lineNum": 39,
          "code": "#define     CustomRenderTextureUpdateSpace  CustomRenderTextureParameters.x // Normalized(0)/PixelSpace(1)"
        },
        {
          "comment": "",
          "lineNum": 40,
          "code": "#define     CustomRenderTexture3DTexcoordW  CustomRenderTextureParameters.y"
        },
        {
          "comment": "",
          "lineNum": 41,
          "code": "#define     CustomRenderTextureIs3D         CustomRenderTextureParameters.z"
        },
        {
          "comment": "// Helpers",
          "lineNum": 47,
          "code": "#define _CustomRenderTextureWidth   _CustomRenderTextureInfo.x"
        },
        {
          "comment": "// Helpers",
          "lineNum": 48,
          "code": "#define _CustomRenderTextureHeight  _CustomRenderTextureInfo.y"
        },
        {
          "comment": "// Helpers",
          "lineNum": 49,
          "code": "#define _CustomRenderTextureDepth   _CustomRenderTextureInfo.z"
        },
        {
          "comment": "// Those two are mutually exclusive so we can use the same slot",
          "lineNum": 52,
          "code": "#define _CustomRenderTextureCubeFace    _CustomRenderTextureInfo.w"
        },
        {
          "comment": "// Those two are mutually exclusive so we can use the same slot",
          "lineNum": 53,
          "code": "#define _CustomRenderTexture3DSlice     _CustomRenderTextureInfo.w"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 25,
          "modifiers": "",
          "parameters": "float2 pos, float angle",
          "type": "float2",
          "name": "CustomRenderTextureRotate2D",
          "code": "float2 CustomRenderTextureRotate2D(float2 pos, float angle)\n{\n    float sn = sin(angle);\n    float cs = cos(angle);\n\n    return float2( pos.x * cs - pos.y * sn, pos.x * sn + pos.y * cs);\n}"
        },
        {
          "comment": "",
          "lineNum": 59,
          "modifiers": "",
          "parameters": "float2 globalTexcoord",
          "type": "float3",
          "name": "CustomRenderTextureComputeCubeDirection",
          "code": "float3 CustomRenderTextureComputeCubeDirection(float2 globalTexcoord)\n{\n    float2 xy = globalTexcoord * 2.0 - 1.0;\n    float3 direction;\n    if(_CustomRenderTextureCubeFace == 0.0)\n    {\n        direction = normalize(float3(1.0, -xy.y, -xy.x));\n    }\n    else if(_CustomRenderTextureCubeFace == 1.0)\n    {\n        direction = normalize(float3(-1.0, -xy.y, xy.x));\n    }\n    else if(_CustomRenderTextureCubeFace == 2.0)\n    {\n        direction = normalize(float3(xy.x, 1.0, xy.y));\n    }\n    else if(_CustomRenderTextureCubeFace == 3.0)\n    {\n        direction = normalize(float3(xy.x, -1.0, -xy.y));\n    }\n    else if(_CustomRenderTextureCubeFace == 4.0)\n    {\n        direction = normalize(float3(xy.x, -xy.y, 1.0));\n    }\n    else if(_CustomRenderTextureCubeFace == 5.0)\n    {\n        direction = normalize(float3(-xy.x, -xy.y, -1.0));\n    }\n\n    return direction;\n}"
        },
        {
          "comment": "// standard custom texture vertex shader that should always be used",
          "lineNum": 92,
          "modifiers": "",
          "parameters": "appdata_customrendertexture IN",
          "type": "v2f_customrendertexture",
          "name": "CustomRenderTextureVertexShader",
          "code": "v2f_customrendertexture CustomRenderTextureVertexShader(appdata_customrendertexture IN)\n{\n    v2f_customrendertexture OUT;\n\n#if UNITY_UV_STARTS_AT_TOP\n    const float2 vertexPositions[6] =\n    {\n        { -1.0f,  1.0f },\n        { -1.0f, -1.0f },\n        {  1.0f, -1.0f },\n        {  1.0f,  1.0f },\n        { -1.0f,  1.0f },\n        {  1.0f, -1.0f }\n    };\n\n    const float2 texCoords[6] =\n    {\n        { 0.0f, 0.0f },\n        { 0.0f, 1.0f },\n        { 1.0f, 1.0f },\n        { 1.0f, 0.0f },\n        { 0.0f, 0.0f },\n        { 1.0f, 1.0f }\n    };\n#else\n    const float2 vertexPositions[6] =\n    {\n        {  1.0f,  1.0f },\n        { -1.0f, -1.0f },\n        { -1.0f,  1.0f },\n        { -1.0f, -1.0f },\n        {  1.0f,  1.0f },\n        {  1.0f, -1.0f }\n    };\n\n    const float2 texCoords[6] =\n    {\n        { 1.0f, 1.0f },\n        { 0.0f, 0.0f },\n        { 0.0f, 1.0f },\n        { 0.0f, 0.0f },\n        { 1.0f, 1.0f },\n        { 1.0f, 0.0f }\n    };\n#endif\n\n    uint primitiveID = IN.vertexID / 6;\n    uint vertexID = IN.vertexID % 6;\n    float3 updateZoneCenter = CustomRenderTextureCenters[primitiveID].xyz;\n    float3 updateZoneSize = CustomRenderTextureSizesAndRotations[primitiveID].xyz;\n    float rotation = CustomRenderTextureSizesAndRotations[primitiveID].w * UNITY_PI / 180.0f;\n\n#if !UNITY_UV_STARTS_AT_TOP\n    rotation = -rotation;\n#endif\n\n    // Normalize rect if needed\n    if (CustomRenderTextureUpdateSpace > 0.0) // Pixel space\n    {\n        // Normalize xy because we need it in clip space.\n        updateZoneCenter.xy /= _CustomRenderTextureInfo.xy;\n        updateZoneSize.xy /= _CustomRenderTextureInfo.xy;\n    }\n    else // normalized space\n    {\n        // Un-normalize depth because we need actual slice index for culling\n        updateZoneCenter.z *= _CustomRenderTextureInfo.z;\n        updateZoneSize.z *= _CustomRenderTextureInfo.z;\n    }\n\n    // Compute rotation\n\n    // Compute quad vertex position\n    float2 clipSpaceCenter = updateZoneCenter.xy * 2.0 - 1.0;\n    float2 pos = vertexPositions[vertexID] * updateZoneSize.xy;\n    pos = CustomRenderTextureRotate2D(pos, rotation);\n    pos.x += clipSpaceCenter.x;\n#if UNITY_UV_STARTS_AT_TOP\n    pos.y += clipSpaceCenter.y;\n#else\n    pos.y -= clipSpaceCenter.y;\n#endif\n\n    // For 3D texture, cull quads outside of the update zone\n    // This is neeeded in additional to the preliminary minSlice/maxSlice done on the CPU because update zones can be disjointed.\n    // ie: slices [1..5] and [10..15] for two differents zones so we need to cull out slices 0 and [6..9]\n    if (CustomRenderTextureIs3D > 0.0)\n    {\n        int minSlice = (int)(updateZoneCenter.z - updateZoneSize.z * 0.5);\n        int maxSlice = minSlice + (int)updateZoneSize.z;\n        if (_CustomRenderTexture3DSlice < minSlice || _CustomRenderTexture3DSlice >= maxSlice)\n        {\n            pos.xy = float2(1000.0, 1000.0); // Vertex outside of ncs\n        }\n    }\n\n    OUT.vertex = float4(pos, 0.0, 1.0);\n    OUT.primitiveID = asuint(CustomRenderTexturePrimitiveIDs[primitiveID]);\n    OUT.localTexcoord = float3(texCoords[vertexID], CustomRenderTexture3DTexcoordW);\n    OUT.globalTexcoord = float3(pos.xy * 0.5 + 0.5, CustomRenderTexture3DTexcoordW);\n#if UNITY_UV_STARTS_AT_TOP\n    OUT.globalTexcoord.y = 1.0 - OUT.globalTexcoord.y;\n#endif\n    OUT.direction = CustomRenderTextureComputeCubeDirection(OUT.globalTexcoord.xy);\n\n    return OUT;\n}"
        },
        {
          "comment": "// standard custom texture vertex shader that should always be used for initialization shaders",
          "lineNum": 215,
          "modifiers": "",
          "parameters": "appdata_init_customrendertexture v",
          "type": "v2f_init_customrendertexture",
          "name": "InitCustomRenderTextureVertexShader",
          "code": "v2f_init_customrendertexture InitCustomRenderTextureVertexShader (appdata_init_customrendertexture v)\n{\n    v2f_init_customrendertexture o;\n    o.vertex = UnityObjectToClipPos(v.vertex);\n    o.texcoord = float3(v.texcoord.xy, CustomRenderTexture3DTexcoordW);\n    o.direction = CustomRenderTextureComputeCubeDirection(v.texcoord.xy);\n    return o;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 10,
          "type": "struct",
          "name": "appdata_customrendertexture",
          "modifiers": "",
          "code": "struct appdata_customrendertexture\n{\n    uint    vertexID    : SV_VertexID;\n};"
        },
        {
          "comment": "// User facing vertex to fragment shader structure",
          "lineNum": 16,
          "type": "struct",
          "name": "v2f_customrendertexture",
          "modifiers": "",
          "code": "struct v2f_customrendertexture\n{\n    float4 vertex           : SV_POSITION;\n    float3 localTexcoord    : TEXCOORD0;    // Texcoord local to the update zone (== globalTexcoord if no partial update zone is specified)\n    float3 globalTexcoord   : TEXCOORD1;    // Texcoord relative to the complete custom texture\n    uint primitiveID        : TEXCOORD2;    // Index of the update zone (correspond to the index in the updateZones of the Custom Texture)\n    float3 direction        : TEXCOORD3;    // For cube textures, direction of the pixel being rendered in the cubemap\n};"
        },
        {
          "comment": "",
          "lineNum": 200,
          "type": "struct",
          "name": "appdata_init_customrendertexture",
          "modifiers": "",
          "code": "struct appdata_init_customrendertexture\n{\n    float4 vertex : POSITION;\n    float2 texcoord : TEXCOORD0;\n};"
        },
        {
          "comment": "// User facing vertex to fragment structure for initialization materials",
          "lineNum": 207,
          "type": "struct",
          "name": "v2f_init_customrendertexture",
          "modifiers": "",
          "code": "struct v2f_init_customrendertexture\n{\n    float4 vertex : SV_POSITION;\n    float3 texcoord : TEXCOORD0;\n    float3 direction : TEXCOORD1;\n};"
        }
      ],
      "variables": [
        {
          "comment": "// Internal",
          "lineNum": 34,
          "modifiers": "",
          "type": "float4",
          "name": "CustomRenderTextureCenters[kCustomTextureBatchSize];",
          "code": "float4      CustomRenderTextureCenters[kCustomTextureBatchSize];"
        },
        {
          "comment": "// Internal",
          "lineNum": 35,
          "modifiers": "",
          "type": "float4",
          "name": "CustomRenderTextureSizesAndRotations[kCustomTextureBatchSize];",
          "code": "float4      CustomRenderTextureSizesAndRotations[kCustomTextureBatchSize];"
        },
        {
          "comment": "// Internal",
          "lineNum": 36,
          "modifiers": "",
          "type": "float",
          "name": "CustomRenderTexturePrimitiveIDs[kCustomTextureBatchSize];",
          "code": "float       CustomRenderTexturePrimitiveIDs[kCustomTextureBatchSize];"
        },
        {
          "comment": "",
          "lineNum": 38,
          "modifiers": "",
          "type": "float4",
          "name": "CustomRenderTextureParameters;",
          "code": "float4      CustomRenderTextureParameters;"
        },
        {
          "comment": "// User facing uniform variables",
          "lineNum": 44,
          "modifiers": "",
          "type": "float4",
          "name": "_CustomRenderTextureInfo;",
          "code": "float4      _CustomRenderTextureInfo; // x = width, y = height, z = depth, w = face/3DSlice"
        },
        {
          "comment": "",
          "lineNum": 55,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_SelfTexture2D;",
          "code": "sampler2D   _SelfTexture2D;"
        },
        {
          "comment": "",
          "lineNum": 56,
          "modifiers": "",
          "type": "samplerCUBE",
          "name": "_SelfTextureCube;",
          "code": "samplerCUBE _SelfTextureCube;"
        },
        {
          "comment": "",
          "lineNum": 57,
          "modifiers": "",
          "type": "sampler3D",
          "name": "_SelfTexture3D;",
          "code": "sampler3D   _SelfTexture3D;"
        }
      ]
    },
    {
      "file": "UnityDeferredLibrary.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_DEFERRED_LIBRARY_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "",
          "parameters": "float4 vertex : POSITION, float3 normal : NORMAL",
          "type": "unity_v2f_deferred",
          "name": "vert_deferred",
          "code": "unity_v2f_deferred vert_deferred (float4 vertex : POSITION, float3 normal : NORMAL)\n{\n    unity_v2f_deferred o;\n    o.pos = UnityObjectToClipPos(vertex);\n    o.uv = ComputeScreenPos(o.pos);\n    o.ray = UnityObjectToViewPos(vertex) * float3(-1,-1,1);\n\n    // normal contains a ray pointing from the camera to one of near plane's\n    // corners in camera space when we are drawing a full screen quad.\n    // Otherwise, when rendering 3D shapes, use the ray calculated here.\n    o.ray = lerp(o.ray, normal, _LightAsQuad);\n\n    return o;\n}"
        },
        {
          "comment": "// --------------------------------------------------------",
          "lineNum": 78,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half",
          "name": "UnityDeferredSampleShadowMask",
          "code": "half UnityDeferredSampleShadowMask(float2 uv)\n{\n    half shadowMaskAttenuation = 1.0f;\n\n    #if defined (SHADOWS_SHADOWMASK)\n        half4 shadowMask = tex2D(_CameraGBufferTexture4, uv);\n        shadowMaskAttenuation = saturate(dot(shadowMask, unity_OcclusionMaskSelector));\n    #endif\n\n    return shadowMaskAttenuation;\n}"
        },
        {
          "comment": "// --------------------------------------------------------",
          "lineNum": 91,
          "modifiers": "",
          "parameters": "half fade, float3 vec, float2 uv",
          "type": "half",
          "name": "UnityDeferredSampleRealtimeShadow",
          "code": "half UnityDeferredSampleRealtimeShadow(half fade, float3 vec, float2 uv)\n{\n    half shadowAttenuation = 1.0f;\n\n    #if defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE)\n        #if defined(SHADOWS_SCREEN)\n            shadowAttenuation = tex2D(_ShadowMapTexture, uv).r;\n        #endif\n    #endif\n\n    #if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) && defined(SHADOWS_SOFT) && !defined(LIGHTMAP_SHADOW_MIXING)\n    //avoid expensive shadows fetches in the distance where coherency will be good\n    UNITY_BRANCH\n    if (fade < (1.0f - 1e-2f))\n    {\n    #endif\n\n        #if defined(SPOT)\n            #if defined(SHADOWS_DEPTH)\n                float4 shadowCoord = mul(unity_WorldToShadow[0], float4(vec, 1));\n                shadowAttenuation = UnitySampleShadowmap(shadowCoord);\n            #endif\n        #endif\n\n        #if defined (POINT) || defined (POINT_COOKIE)\n            #if defined(SHADOWS_CUBE)\n                shadowAttenuation = UnitySampleShadowmap(vec);\n            #endif\n        #endif\n\n    #if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) && defined(SHADOWS_SOFT) && !defined(LIGHTMAP_SHADOW_MIXING)\n    }\n    #endif\n\n    return shadowAttenuation;\n}"
        },
        {
          "comment": "// --------------------------------------------------------",
          "lineNum": 129,
          "modifiers": "",
          "parameters": "float3 vec, float fadeDist, float2 uv",
          "type": "half",
          "name": "UnityDeferredComputeShadow",
          "code": "half UnityDeferredComputeShadow(float3 vec, float fadeDist, float2 uv)\n{\n\n    half fade                      = UnityComputeShadowFade(fadeDist);\n    half shadowMaskAttenuation     = UnityDeferredSampleShadowMask(uv);\n    half realtimeShadowAttenuation = UnityDeferredSampleRealtimeShadow(fade, vec, uv);\n\n    return UnityMixRealtimeAndBakedShadows(realtimeShadowAttenuation, shadowMaskAttenuation, fade);\n}"
        },
        {
          "comment": "// --------------------------------------------------------\n// Common lighting data calculation (direction, attenuation, ...)",
          "lineNum": 141,
          "modifiers": "",
          "parameters": "unity_v2f_deferred i,    out float3 outWorldPos,    out float2 outUV,    out half3 outLightDir,    out float outAtten,    out float outFadeDist",
          "type": "void",
          "name": "UnityDeferredCalculateLightParams",
          "code": "void UnityDeferredCalculateLightParams (\n    unity_v2f_deferred i,\n    out float3 outWorldPos,\n    out float2 outUV,\n    out half3 outLightDir,\n    out float outAtten,\n    out float outFadeDist)\n{\n    i.ray = i.ray * (_ProjectionParams.z / i.ray.z);\n    float2 uv = i.uv.xy / i.uv.w;\n\n    // read depth and reconstruct world position\n    float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv);\n    depth = Linear01Depth (depth);\n    float4 vpos = float4(i.ray * depth,1);\n    float3 wpos = mul (unity_CameraToWorld, vpos).xyz;\n\n    float fadeDist = UnityComputeShadowFadeDistance(wpos, vpos.z);\n\n    // spot light case\n    #if defined (SPOT)\n        float3 tolight = _LightPos.xyz - wpos;\n        half3 lightDir = normalize (tolight);\n\n        float4 uvCookie = mul (unity_WorldToLight, float4(wpos,1));\n        // negative bias because http://aras-p.info/blog/2010/01/07/screenspace-vs-mip-mapping/\n        float atten = tex2Dbias (_LightTexture0, float4(uvCookie.xy / uvCookie.w, 0, -8)).w;\n        atten *= uvCookie.w < 0;\n        float att = dot(tolight, tolight) * _LightPos.w;\n        atten *= tex2D (_LightTextureB0, att.rr).r;\n\n        atten *= UnityDeferredComputeShadow (wpos, fadeDist, uv);\n\n    // directional light case\n    #elif defined (DIRECTIONAL) || defined (DIRECTIONAL_COOKIE)\n        half3 lightDir = -_LightDir.xyz;\n        float atten = 1.0;\n\n        atten *= UnityDeferredComputeShadow (wpos, fadeDist, uv);\n\n        #if defined (DIRECTIONAL_COOKIE)\n        atten *= tex2Dbias (_LightTexture0, float4(mul(unity_WorldToLight, half4(wpos,1)).xy, 0, -8)).w;\n        #endif //DIRECTIONAL_COOKIE\n\n    // point light case\n    #elif defined (POINT) || defined (POINT_COOKIE)\n        float3 tolight = wpos - _LightPos.xyz;\n        half3 lightDir = -normalize (tolight);\n\n        float att = dot(tolight, tolight) * _LightPos.w;\n        float atten = tex2D (_LightTextureB0, att.rr).r;\n\n        atten *= UnityDeferredComputeShadow (tolight, fadeDist, uv);\n\n        #if defined (POINT_COOKIE)\n        atten *= texCUBEbias(_LightTexture0, float4(mul(unity_WorldToLight, half4(wpos,1)).xyz, -8)).w;\n        #endif //POINT_COOKIE\n    #else\n        half3 lightDir = 0;\n        float atten = 0;\n    #endif\n\n    outWorldPos = wpos;\n    outUV = uv;\n    outLightDir = lightDir;\n    outAtten = atten;\n    outFadeDist = fadeDist;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 10,
          "type": "struct",
          "name": "unity_v2f_deferred",
          "modifiers": "",
          "code": "struct unity_v2f_deferred {\n    float4 pos : SV_POSITION;\n    float4 uv : TEXCOORD0;\n    float3 ray : TEXCOORD1;\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 16,
          "modifiers": "",
          "type": "float",
          "name": "_LightAsQuad;",
          "code": "float _LightAsQuad;"
        },
        {
          "comment": "",
          "lineNum": 40,
          "modifiers": "",
          "type": "float4",
          "name": "_LightDir;",
          "code": "float4 _LightDir;"
        },
        {
          "comment": "",
          "lineNum": 41,
          "modifiers": "",
          "type": "float4",
          "name": "_LightPos;",
          "code": "float4 _LightPos;"
        },
        {
          "comment": "",
          "lineNum": 42,
          "modifiers": "",
          "type": "float4",
          "name": "_LightColor;",
          "code": "float4 _LightColor;"
        },
        {
          "comment": "",
          "lineNum": 43,
          "modifiers": "",
          "type": "float4",
          "name": "unity_LightmapFade;",
          "code": "float4 unity_LightmapFade;"
        },
        {
          "comment": "",
          "lineNum": 44,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_WorldToLight;",
          "code": "float4x4 unity_WorldToLight;"
        },
        {
          "comment": "",
          "lineNum": 45,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "_LightTextureB0;",
          "code": "sampler2D_float _LightTextureB0;"
        },
        {
          "comment": "",
          "lineNum": 48,
          "modifiers": "",
          "type": "samplerCUBE_float",
          "name": "_LightTexture0;",
          "code": "samplerCUBE_float _LightTexture0;"
        },
        {
          "comment": "",
          "lineNum": 50,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "_LightTexture0;",
          "code": "sampler2D_float _LightTexture0;"
        },
        {
          "comment": "",
          "lineNum": 54,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_ShadowMapTexture;",
          "code": "sampler2D _ShadowMapTexture;"
        },
        {
          "comment": "",
          "lineNum": 58,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_CameraGBufferTexture4;",
          "code": "sampler2D _CameraGBufferTexture4;"
        }
      ]
    },
    {
      "file": "UnityDeprecated.cginc",
      "defines": [],
      "functions": [
        {
          "comment": "",
          "lineNum": 16,
          "modifiers": "inline",
          "parameters": "half3 F0, half roughness, half cosA",
          "type": "half3",
          "name": "LazarovFresnelTerm",
          "code": "inline half3 LazarovFresnelTerm (half3 F0, half roughness, half cosA)\n{\n    half t = Pow5 (1 - cosA);   // ala Schlick interpoliation\n    t /= 4 - 3 * roughness;\n    return F0 + (1-F0) * t;\n}"
        },
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "inline",
          "parameters": "half3 F0, half roughness, half cosA",
          "type": "half3",
          "name": "SebLagardeFresnelTerm",
          "code": "inline half3 SebLagardeFresnelTerm (half3 F0, half roughness, half cosA)\n{\n    half t = Pow5 (1 - cosA);   // ala Schlick interpoliation\n    return F0 + (max (F0, roughness) - F0) * t;\n}"
        },
        {
          "comment": "// Cook-Torrance visibility term, doesn't take roughness into account",
          "lineNum": 29,
          "modifiers": "inline",
          "parameters": "half NdotL, half NdotV,  half NdotH, half VdotH",
          "type": "half",
          "name": "CookTorranceVisibilityTerm",
          "code": "inline half CookTorranceVisibilityTerm (half NdotL, half NdotV,  half NdotH, half VdotH)\n{\n    VdotH += 1e-5f;\n    half G = min (1.0, min (\n        (2.0 * NdotH * NdotV) / VdotH,\n        (2.0 * NdotH * NdotL) / VdotH));\n    return G / (NdotL * NdotV + 1e-4f);\n}"
        },
        {
          "comment": "// Kelemen-Szirmay-Kalos is an approximation to Cook-Torrance visibility term\n// http://sirkan.iit.bme.hu/~szirmay/scook.pdf",
          "lineNum": 40,
          "modifiers": "inline",
          "parameters": "half LdotH",
          "type": "half",
          "name": "KelemenVisibilityTerm",
          "code": "inline half KelemenVisibilityTerm (half LdotH)\n{\n    return 1.0 / (LdotH * LdotH);\n}"
        },
        {
          "comment": "// Modified Kelemen-Szirmay-Kalos which takes roughness into account, based on: http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/",
          "lineNum": 46,
          "modifiers": "inline",
          "parameters": "half LdotH, half perceptualRoughness",
          "type": "half",
          "name": "ModifiedKelemenVisibilityTerm",
          "code": "inline half ModifiedKelemenVisibilityTerm (half LdotH, half perceptualRoughness)\n{\n    half c = 0.797884560802865h; // c = sqrt(2 / Pi)\n    half k = PerceptualRoughnessToRoughness(perceptualRoughness) * c;\n    half gH = LdotH * (1-k) + k;\n    return 1.0 / (gH * gH);\n}"
        },
        {
          "comment": "// Smith-Schlick derived for GGX",
          "lineNum": 55,
          "modifiers": "inline",
          "parameters": "half NdotL, half NdotV, half perceptualRoughness",
          "type": "half",
          "name": "SmithGGXVisibilityTerm",
          "code": "inline half SmithGGXVisibilityTerm (half NdotL, half NdotV, half perceptualRoughness)\n{\n    half k = (PerceptualRoughnessToRoughness(perceptualRoughness)) / 2; // derived by B. Karis, http://graphicrants.blogspot.se/2013/08/specular-brdf-reference.html\n    return SmithVisibilityTerm (NdotL, NdotV, k);\n}"
        },
        {
          "comment": "",
          "lineNum": 61,
          "modifiers": "inline",
          "parameters": "",
          "type": "half",
          "name": "ImplicitVisibilityTerm",
          "code": "inline half ImplicitVisibilityTerm ()\n{\n    return 1;\n}"
        },
        {
          "comment": "// BlinnPhong normalized as reflection density­sity function (RDF)\n// ready for use directly as specular: spec=D\n// http://www.thetenthplanet.de/archives/255",
          "lineNum": 69,
          "modifiers": "inline",
          "parameters": "half NdotH, half n",
          "type": "half",
          "name": "RDFBlinnPhongNormalizedTerm",
          "code": "inline half RDFBlinnPhongNormalizedTerm (half NdotH, half n)\n{\n    half normTerm = (n + 2.0) / (8.0 * UNITY_PI);\n    half specTerm = pow (NdotH, n);\n    return specTerm * normTerm;\n}"
        },
        {
          "comment": "// Decodes HDR textures\n// sm 2.0 is no longer supported",
          "lineNum": 78,
          "modifiers": "inline",
          "parameters": "half4 data, half4 decodeInstructions",
          "type": "half3",
          "name": "DecodeHDR_NoLinearSupportInSM2",
          "code": "inline half3 DecodeHDR_NoLinearSupportInSM2 (half4 data, half4 decodeInstructions)\n{\n    // If Linear mode is not supported we can skip exponent part\n    // In Standard shader SM2.0 and SM3.0 paths are always using different shader variations\n    // SM2.0: hardware does not support Linear, we can skip exponent part\n#if defined(UNITY_COLORSPACE_GAMMA) && (SHADER_TARGET < 30)\n    return (data.a * decodeInstructions.x) * data.rgb;\n#else\n    return DecodeHDR(data, decodeInstructions);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 90,
          "modifiers": "inline",
          "parameters": "half3 a, half3 b",
          "type": "half",
          "name": "DotClamped",
          "code": "inline half DotClamped (half3 a, half3 b)\n{\n    #if (SHADER_TARGET < 30)\n        return saturate(dot(a, b));\n    #else\n        return max(0.0h, dot(a, b));\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 99,
          "modifiers": "inline",
          "parameters": "half3 normal, half3 lightDir",
          "type": "half",
          "name": "LambertTerm",
          "code": "inline half LambertTerm (half3 normal, half3 lightDir)\n{\n    return DotClamped (normal, lightDir);\n}"
        },
        {
          "comment": "",
          "lineNum": 104,
          "modifiers": "inline",
          "parameters": "half3 normal, half3 halfDir",
          "type": "half",
          "name": "BlinnTerm",
          "code": "inline half BlinnTerm (half3 normal, half3 halfDir)\n{\n    return DotClamped (normal, halfDir);\n}"
        },
        {
          "comment": "",
          "lineNum": 109,
          "modifiers": "",
          "parameters": "half roughness",
          "type": "half",
          "name": "RoughnessToSpecPower",
          "code": "half RoughnessToSpecPower (half roughness)\n{\n    return PerceptualRoughnessToSpecPower (roughness);\n}"
        },
        {
          "comment": "// Old Unity_GlossyEnvironment signature. Kept only for backward compatibility and will be removed soon",
          "lineNum": 133,
          "modifiers": "",
          "parameters": "UNITY_ARGS_TEXCUBE(tex), half4 hdr, half3 worldNormal, half perceptualRoughness",
          "type": "half3",
          "name": "Unity_GlossyEnvironment",
          "code": "half3 Unity_GlossyEnvironment (UNITY_ARGS_TEXCUBE(tex), half4 hdr, half3 worldNormal, half perceptualRoughness)\n{\n    Unity_GlossyEnvironmentData g;\n    g.roughness /* perceptualRoughness */ = perceptualRoughness;\n    g.reflUVW   = worldNormal;\n\n    return Unity_GlossyEnvironment (UNITY_PASS_TEXCUBE(tex), hdr, g);\n}"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnityGBuffer.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_GBUFFER_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "//-----------------------------------------------------------------------------\n// This will encode UnityStandardData into GBuffer",
          "lineNum": 19,
          "modifiers": "",
          "parameters": "UnityStandardData data, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2",
          "type": "void",
          "name": "UnityStandardDataToGbuffer",
          "code": "void UnityStandardDataToGbuffer(UnityStandardData data, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2)\n{\n    // RT0: diffuse color (rgb), occlusion (a) - sRGB rendertarget\n    outGBuffer0 = half4(data.diffuseColor, data.occlusion);\n\n    // RT1: spec color (rgb), smoothness (a) - sRGB rendertarget\n    outGBuffer1 = half4(data.specularColor, data.smoothness);\n\n    // RT2: normal (rgb), --unused, very low precision-- (a)\n    outGBuffer2 = half4(data.normalWorld * 0.5f + 0.5f, 1.0f);\n}"
        },
        {
          "comment": "    // RT2: normal (rgb), --unused, very low precision-- (a)\n//-----------------------------------------------------------------------------\n// This decode the Gbuffer in a UnityStandardData struct",
          "lineNum": 32,
          "modifiers": "FromGbuffer",
          "parameters": "half4 inGBuffer0, half4 inGBuffer1, half4 inGBuffer2",
          "type": "UnityStandardData",
          "name": "UnityStandardDataFromGbuffer",
          "code": "UnityStandardData UnityStandardDataFromGbuffer(half4 inGBuffer0, half4 inGBuffer1, half4 inGBuffer2)\n{\n    UnityStandardData data;\n\n    data.diffuseColor   = inGBuffer0.rgb;\n    data.occlusion      = inGBuffer0.a;\n\n    data.specularColor  = inGBuffer1.rgb;\n    data.smoothness     = inGBuffer1.a;\n\n    data.normalWorld    = normalize((float3)inGBuffer2.rgb * 2 - 1);\n\n    return data;\n}"
        },
        {
          "comment": "//-----------------------------------------------------------------------------\n// In some cases like for terrain, the user want to apply a specific weight to the attribute\n// The function below is use for this",
          "lineNum": 49,
          "modifiers": "",
          "parameters": "inout half4 inOutGBuffer0, inout half4 inOutGBuffer1, inout half4 inOutGBuffer2, half alpha",
          "type": "void",
          "name": "UnityStandardDataApplyWeightToGbuffer",
          "code": "void UnityStandardDataApplyWeightToGbuffer(inout half4 inOutGBuffer0, inout half4 inOutGBuffer1, inout half4 inOutGBuffer2, half alpha)\n{\n    // With UnityStandardData current encoding, We can apply the weigth directly on the gbuffer\n    inOutGBuffer0.rgb   *= alpha; // diffuseColor\n    inOutGBuffer1       *= alpha; // SpecularColor and Smoothness\n    inOutGBuffer2.rgb   *= alpha; // Normal\n}"
        }
      ],
      "structs": [
        {
          "comment": "//-----------------------------------------------------------------------------\n// Main structure that store the data from the standard shader (i.e user input)",
          "lineNum": 6,
          "type": "struct",
          "name": "UnityStandardData",
          "modifiers": "",
          "code": "struct UnityStandardData\n{\n    half3   diffuseColor;\n    half    occlusion;\n\n    half3   specularColor;\n    half    smoothness;\n\n    float3  normalWorld;        // normal in world space\n};"
        }
      ],
      "variables": []
    },
    {
      "file": "UnityGlobalIllumination.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_GLOBAL_ILLUMINATION_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 10,
          "modifiers": "inline",
          "parameters": "half3 color, half4 dirTex, half3 normalWorld, bool isRealtimeLightmap, fixed4 realtimeNormalTex, out UnityLight o_light",
          "type": "half3",
          "name": "DecodeDirectionalSpecularLightmap",
          "code": "inline half3 DecodeDirectionalSpecularLightmap (half3 color, half4 dirTex, half3 normalWorld, bool isRealtimeLightmap, fixed4 realtimeNormalTex, out UnityLight o_light)\n{\n    o_light.color = color;\n    o_light.dir = dirTex.xyz * 2 - 1;\n    o_light.ndotl = 0; // Not use;\n\n    // The length of the direction vector is the light's \"directionality\", i.e. 1 for all light coming from this direction,\n    // lower values for more spread out, ambient light.\n    half directionality = max(0.001, length(o_light.dir));\n    o_light.dir /= directionality;\n\n    #ifdef DYNAMICLIGHTMAP_ON\n    if (isRealtimeLightmap)\n    {\n        // Realtime directional lightmaps' intensity needs to be divided by N.L\n        // to get the incoming light intensity. Baked directional lightmaps are already\n        // output like that (including the max() to prevent div by zero).\n        half3 realtimeNormal = realtimeNormalTex.xyz * 2 - 1;\n        o_light.color /= max(0.125, dot(realtimeNormal, o_light.dir));\n    }\n    #endif\n\n    // Split light into the directional and ambient parts, according to the directionality factor.\n    half3 ambient = o_light.color * (1 - directionality);\n    o_light.color = o_light.color * directionality;\n\n    // Technically this is incorrect, but helps hide jagged light edge at the object silhouettes and\n    // makes normalmaps show up.\n    ambient *= saturate(dot(normalWorld, o_light.dir));\n    return ambient;\n}"
        },
        {
          "comment": "",
          "lineNum": 42,
          "modifiers": "inline",
          "parameters": "out UnityLight outLight",
          "type": "void",
          "name": "ResetUnityLight",
          "code": "inline void ResetUnityLight(out UnityLight outLight)\n{\n    outLight.color = half3(0, 0, 0);\n    outLight.dir = half3(0, 1, 0); // Irrelevant direction, just not null\n    outLight.ndotl = 0; // Not used\n}"
        },
        {
          "comment": "",
          "lineNum": 49,
          "modifiers": "inline",
          "parameters": "half3 lightmap, half attenuation, half4 bakedColorTex, half3 normalWorld",
          "type": "half3",
          "name": "SubtractMainLightWithRealtimeAttenuationFromLightmap",
          "code": "inline half3 SubtractMainLightWithRealtimeAttenuationFromLightmap (half3 lightmap, half attenuation, half4 bakedColorTex, half3 normalWorld)\n{\n    // Let's try to make realtime shadows work on a surface, which already contains\n    // baked lighting and shadowing from the main sun light.\n    half3 shadowColor = unity_ShadowColor.rgb;\n    half shadowStrength = _LightShadowData.x;\n\n    // Summary:\n    // 1) Calculate possible value in the shadow by subtracting estimated light contribution from the places occluded by realtime shadow:\n    //      a) preserves other baked lights and light bounces\n    //      b) eliminates shadows on the geometry facing away from the light\n    // 2) Clamp against user defined ShadowColor.\n    // 3) Pick original lightmap value, if it is the darkest one.\n\n\n    // 1) Gives good estimate of illumination as if light would've been shadowed during the bake.\n    //    Preserves bounce and other baked lights\n    //    No shadows on the geometry facing away from the light\n    half ndotl = LambertTerm (normalWorld, _WorldSpaceLightPos0.xyz);\n    half3 estimatedLightContributionMaskedByInverseOfShadow = ndotl * (1- attenuation) * _LightColor0.rgb;\n    half3 subtractedLightmap = lightmap - estimatedLightContributionMaskedByInverseOfShadow;\n\n    // 2) Allows user to define overall ambient of the scene and control situation when realtime shadow becomes too dark.\n    half3 realtimeShadow = max(subtractedLightmap, shadowColor);\n    realtimeShadow = lerp(realtimeShadow, lightmap, shadowStrength);\n\n    // 3) Pick darkest color\n    return min(lightmap, realtimeShadow);\n}"
        },
        {
          "comment": "",
          "lineNum": 79,
          "modifiers": "inline",
          "parameters": "out UnityGI outGI",
          "type": "void",
          "name": "ResetUnityGI",
          "code": "inline void ResetUnityGI(out UnityGI outGI)\n{\n    ResetUnityLight(outGI.light);\n    outGI.indirect.diffuse = 0;\n    outGI.indirect.specular = 0;\n}"
        },
        {
          "comment": "",
          "lineNum": 86,
          "modifiers": "inline  _Base",
          "parameters": "UnityGIInput data, half occlusion, half3 normalWorld",
          "type": "UnityGI",
          "name": "UnityGI_Base",
          "code": "inline UnityGI UnityGI_Base(UnityGIInput data, half occlusion, half3 normalWorld)\n{\n    UnityGI o_gi;\n    ResetUnityGI(o_gi);\n\n    // Base pass with Lightmap support is responsible for handling ShadowMask / blending here for performance reason\n    #if defined(HANDLE_SHADOWS_BLENDING_IN_GI)\n        half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);\n        float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);\n        float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);\n        data.atten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));\n    #endif\n\n    o_gi.light = data.light;\n    o_gi.light.color *= data.atten;\n\n    #if UNITY_SHOULD_SAMPLE_SH\n        o_gi.indirect.diffuse = ShadeSHPerPixel(normalWorld, data.ambient, data.worldPos);\n    #endif\n\n    #if defined(LIGHTMAP_ON)\n        // Baked lightmaps\n        half4 bakedColorTex = UNITY_SAMPLE_TEX2D(unity_Lightmap, data.lightmapUV.xy);\n        half3 bakedColor = DecodeLightmap(bakedColorTex);\n\n        #ifdef DIRLIGHTMAP_COMBINED\n            fixed4 bakedDirTex = UNITY_SAMPLE_TEX2D_SAMPLER (unity_LightmapInd, unity_Lightmap, data.lightmapUV.xy);\n            o_gi.indirect.diffuse += DecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);\n\n            #if defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN)\n                ResetUnityLight(o_gi.light);\n                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap (o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);\n            #endif\n\n        #else // not directional lightmap\n            o_gi.indirect.diffuse += bakedColor;\n\n            #if defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN)\n                ResetUnityLight(o_gi.light);\n                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap(o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);\n            #endif\n\n        #endif\n    #endif\n\n    #ifdef DYNAMICLIGHTMAP_ON\n        // Dynamic lightmaps\n        fixed4 realtimeColorTex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, data.lightmapUV.zw);\n        half3 realtimeColor = DecodeRealtimeLightmap (realtimeColorTex);\n\n        #ifdef DIRLIGHTMAP_COMBINED\n            half4 realtimeDirTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap, data.lightmapUV.zw);\n            o_gi.indirect.diffuse += DecodeDirectionalLightmap (realtimeColor, realtimeDirTex, normalWorld);\n        #else\n            o_gi.indirect.diffuse += realtimeColor;\n        #endif\n    #endif\n\n    o_gi.indirect.diffuse *= occlusion;\n    return o_gi;\n}"
        },
        {
          "comment": "",
          "lineNum": 149,
          "modifiers": "inline",
          "parameters": "UnityGIInput data, half occlusion, Unity_GlossyEnvironmentData glossIn",
          "type": "half3",
          "name": "UnityGI_IndirectSpecular",
          "code": "inline half3 UnityGI_IndirectSpecular(UnityGIInput data, half occlusion, Unity_GlossyEnvironmentData glossIn)\n{\n    half3 specular;\n\n    #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n        // we will tweak reflUVW in glossIn directly (as we pass it to Unity_GlossyEnvironment twice for probe0 and probe1), so keep original to pass into BoxProjectedCubemapDirection\n        half3 originalReflUVW = glossIn.reflUVW;\n        glossIn.reflUVW = BoxProjectedCubemapDirection (originalReflUVW, data.worldPos, data.probePosition[0], data.boxMin[0], data.boxMax[0]);\n    #endif\n\n    #ifdef _GLOSSYREFLECTIONS_OFF\n        specular = unity_IndirectSpecColor.rgb;\n    #else\n        half3 env0 = Unity_GlossyEnvironment (UNITY_PASS_TEXCUBE(unity_SpecCube0), data.probeHDR[0], glossIn);\n        #ifdef UNITY_SPECCUBE_BLENDING\n            const float kBlendFactor = 0.99999;\n            float blendLerp = data.boxMin[0].w;\n            UNITY_BRANCH\n            if (blendLerp < kBlendFactor)\n            {\n                #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n                    glossIn.reflUVW = BoxProjectedCubemapDirection (originalReflUVW, data.worldPos, data.probePosition[1], data.boxMin[1], data.boxMax[1]);\n                #endif\n\n                half3 env1 = Unity_GlossyEnvironment (UNITY_PASS_TEXCUBE_SAMPLER(unity_SpecCube1,unity_SpecCube0), data.probeHDR[1], glossIn);\n                specular = lerp(env1, env0, blendLerp);\n            }\n            else\n            {\n                specular = env0;\n            }\n        #else\n            specular = env0;\n        #endif\n    #endif\n\n    return specular * occlusion;\n}"
        },
        {
          "comment": "// Deprecated old prototype but can't be move to Deprecated.cginc file due to order dependency",
          "lineNum": 189,
          "modifiers": "inline",
          "parameters": "UnityGIInput data, half occlusion, half3 normalWorld, Unity_GlossyEnvironmentData glossIn",
          "type": "half3",
          "name": "UnityGI_IndirectSpecular",
          "code": "inline half3 UnityGI_IndirectSpecular(UnityGIInput data, half occlusion, half3 normalWorld, Unity_GlossyEnvironmentData glossIn)\n{\n    // normalWorld is not used\n    return UnityGI_IndirectSpecular(data, occlusion, glossIn);\n}"
        },
        {
          "comment": "",
          "lineNum": 195,
          "modifiers": "inline",
          "parameters": "UnityGIInput data, half occlusion, half3 normalWorld",
          "type": "UnityGI",
          "name": "UnityGlobalIllumination",
          "code": "inline UnityGI UnityGlobalIllumination (UnityGIInput data, half occlusion, half3 normalWorld)\n{\n    return UnityGI_Base(data, occlusion, normalWorld);\n}"
        },
        {
          "comment": "",
          "lineNum": 200,
          "modifiers": "inline",
          "parameters": "UnityGIInput data, half occlusion, half3 normalWorld, Unity_GlossyEnvironmentData glossIn",
          "type": "UnityGI",
          "name": "UnityGlobalIllumination",
          "code": "inline UnityGI UnityGlobalIllumination (UnityGIInput data, half occlusion, half3 normalWorld, Unity_GlossyEnvironmentData glossIn)\n{\n    UnityGI o_gi = UnityGI_Base(data, occlusion, normalWorld);\n    o_gi.indirect.specular = UnityGI_IndirectSpecular(data, occlusion, glossIn);\n    return o_gi;\n}"
        },
        {
          "comment": "",
          "lineNum": 211,
          "modifiers": "inline",
          "parameters": "UnityGIInput data, half occlusion, half smoothness, half3 normalWorld, bool reflections",
          "type": "UnityGI",
          "name": "UnityGlobalIllumination",
          "code": "inline UnityGI UnityGlobalIllumination (UnityGIInput data, half occlusion, half smoothness, half3 normalWorld, bool reflections)\n{\n    if(reflections)\n    {\n        Unity_GlossyEnvironmentData g = UnityGlossyEnvironmentSetup(smoothness, data.worldViewDir, normalWorld, float3(0, 0, 0));\n        return UnityGlobalIllumination(data, occlusion, normalWorld, g);\n    }\n    else\n    {\n        return UnityGlobalIllumination(data, occlusion, normalWorld);\n    }\n}"
        },
        {
          "comment": "",
          "lineNum": 223,
          "modifiers": "inline",
          "parameters": "UnityGIInput data, half occlusion, half smoothness, half3 normalWorld",
          "type": "UnityGI",
          "name": "UnityGlobalIllumination",
          "code": "inline UnityGI UnityGlobalIllumination (UnityGIInput data, half occlusion, half smoothness, half3 normalWorld)\n{\n#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS\n    // No need to sample reflection probes during deferred G-buffer pass\n    bool sampleReflections = false;\n#else\n    bool sampleReflections = true;\n#endif\n    return UnityGlobalIllumination (data, occlusion, smoothness, normalWorld, sampleReflections);\n}"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnityImageBasedLighting.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_IMAGE_BASED_LIGHTING_INCLUDED"
        },
        {
          "comment": "// ----------------------------------------------------------------------------\n// Include deprecated function",
          "lineNum": 549,
          "code": "#define INCLUDE_UNITY_IMAGE_BASED_LIGHTING_DEPRECATED"
        }
      ],
      "functions": [
        {
          "comment": "//-----------------------------------------------------------------------------\n// Sample generator\n//-----------------------------------------------------------------------------\n// Ref: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html",
          "lineNum": 19,
          "modifiers": "",
          "parameters": "uint bits",
          "type": "uint",
          "name": "ReverseBits32",
          "code": "uint ReverseBits32(uint bits)\n{\n#if 0 // Shader model 5\n    return reversebits(bits);\n#else\n    bits = ( bits << 16) | ( bits >> 16);\n    bits = ((bits & 0x00ff00ff) << 8) | ((bits & 0xff00ff00) >> 8);\n    bits = ((bits & 0x0f0f0f0f) << 4) | ((bits & 0xf0f0f0f0) >> 4);\n    bits = ((bits & 0x33333333) << 2) | ((bits & 0xcccccccc) >> 2);\n    bits = ((bits & 0x55555555) << 1) | ((bits & 0xaaaaaaaa) >> 1);\n    return bits;\n#endif\n}"
        },
        {
          "comment": "//-----------------------------------------------------------------------------\n// Sample generator\n//-----------------------------------------------------------------------------\n// Ref: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n//-----------------------------------------------------------------------------",
          "lineNum": 33,
          "modifiers": "",
          "parameters": "uint bits",
          "type": "float",
          "name": "RadicalInverse_VdC",
          "code": "float RadicalInverse_VdC(uint bits)\n{\n    return float(ReverseBits32(bits)) * 2.3283064365386963e-10; // 0x100000000\n}"
        },
        {
          "comment": "//-----------------------------------------------------------------------------",
          "lineNum": 39,
          "modifiers": "",
          "parameters": "uint i, uint maxSampleCount",
          "type": "float2",
          "name": "Hammersley2d",
          "code": "float2 Hammersley2d(uint i, uint maxSampleCount)\n{\n    return float2(float(i) / float(maxSampleCount), RadicalInverse_VdC(i));\n}"
        },
        {
          "comment": "//-----------------------------------------------------------------------------",
          "lineNum": 45,
          "modifiers": "",
          "parameters": "uint s",
          "type": "float",
          "name": "Hash",
          "code": "float Hash(uint s)\n{\n    s = s ^ 2747636419u;\n    s = s * 2654435769u;\n    s = s ^ (s >> 16);\n    s = s * 2654435769u;\n    s = s ^ (s >> 16);\n    s = s * 2654435769u;\n    return float(s) / 4294967295.0f;\n}"
        },
        {
          "comment": "//-----------------------------------------------------------------------------",
          "lineNum": 57,
          "modifiers": "",
          "parameters": "float2 input",
          "type": "float2",
          "name": "InitRandom",
          "code": "float2 InitRandom(float2 input)\n{\n    float2 r;\n    r.x = Hash(uint(input.x * 4294967295.0f));\n    r.y = Hash(uint(input.y * 4294967295.0f));\n\n    return r;\n}"
        },
        {
          "comment": "// generate an orthonormalBasis from 3d unit vector.",
          "lineNum": 71,
          "modifiers": "",
          "parameters": "float3 N, out float3 tangentX, out float3 tangentY",
          "type": "void",
          "name": "GetLocalFrame",
          "code": "void GetLocalFrame(float3 N, out float3 tangentX, out float3 tangentY)\n{\n    float3 upVector     = abs(N.z) < 0.999f ? float3(0.0f, 0.0f, 1.0f) : float3(1.0f, 0.0f, 0.0f);\n    tangentX            = normalize(cross(upVector, N));\n    tangentY            = cross(N, tangentX);\n}"
        },
        {
          "comment": "// http://orbit.dtu.dk/files/57573287/onb_frisvad_jgt2012.pdf",
          "lineNum": 80,
          "modifiers": "",
          "parameters": "float3 N, out float3 tangentX, out float3 tangentY",
          "type": "void",
          "name": "GetLocalFrame",
          "code": "void GetLocalFrame(float3 N, out float3 tangentX, out float3 tangentY)\n{\n    if (N.z < -0.999f) // Handle the singularity\n    {\n        tangentX = Vec3f (0.0f, -1.0f, 0.0f);\n        tangentY = Vec3f (-1.0f, 0.0f, 0.0f);\n        return ;\n    }\n\n    float a     = 1.0f / (1.0f + N.z);\n    float b     = -N.x * N.y * a ;\n    tangentX    = float3(1.0f - N.x * N.x * a , b, -N.x);\n    tangentY    = float3(b, 1.0f - N.y * N.y * a, -N.y);\n}"
        },
        {
          "comment": "",
          "lineNum": 100,
          "modifiers": "",
          "parameters": "float2 u,                            float3 N,                            float3 tangentX,                            float3 tangentY,                            out float3 L",
          "type": "void",
          "name": "ImportanceSampleCosDir",
          "code": "void ImportanceSampleCosDir(float2 u,\n                            float3 N,\n                            float3 tangentX,\n                            float3 tangentY,\n                            out float3 L)\n{\n    // Cosine sampling - ref: http://www.rorydriscoll.com/2009/01/07/better-sampling/\n    float cosTheta = sqrt(max(0.0f, 1.0f - u.x));\n    float sinTheta = sqrt(u.x);\n    float phi = UNITY_TWO_PI * u.y;\n\n    // Transform from spherical into cartesian\n    L = float3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    // Local to world\n    L = tangentX * L.x + tangentY * L.y + N * L.z;\n}"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------",
          "lineNum": 118,
          "modifiers": "",
          "parameters": "float2 u,                            float3 V,                            float3 N,                            float3 tangentX,                            float3 tangentY,                            float roughness,                            out float3 H,                            out float3 L",
          "type": "void",
          "name": "ImportanceSampleGGXDir",
          "code": "void ImportanceSampleGGXDir(float2 u,\n                            float3 V,\n                            float3 N,\n                            float3 tangentX,\n                            float3 tangentY,\n                            float roughness,\n                            out float3 H,\n                            out float3 L)\n{\n    // GGX NDF sampling\n    float cosThetaH = sqrt((1.0f - u.x) / (1.0f + (roughness * roughness - 1.0f) * u.x));\n    float sinThetaH = sqrt(max(0.0f, 1.0f - cosThetaH * cosThetaH));\n    float phiH      = UNITY_TWO_PI * u.y;\n\n    // Transform from spherical into cartesian\n    H = float3(sinThetaH * cos(phiH), sinThetaH * sin(phiH), cosThetaH);\n    // Local to world\n    H = tangentX * H.x + tangentY * H.y + N * H.z;\n\n    // Convert sample from half angle to incident angle\n    L = 2.0f * dot(V, H) * H - V;\n}"
        },
        {
          "comment": "// ----------------------------------------------------------------------------\n// weightOverPdf return the weight (without the diffuseAlbedo term) over pdf. diffuseAlbedo term must be apply by the caller.",
          "lineNum": 143,
          "modifiers": "",
          "parameters": "float2 u,    float3 N,    float3 tangentX,    float3 tangentY,    out float3 L,    out float NdotL,    out float weightOverPdf",
          "type": "void",
          "name": "ImportanceSampleLambert",
          "code": "void ImportanceSampleLambert(\n    float2 u,\n    float3 N,\n    float3 tangentX,\n    float3 tangentY,\n    out float3 L,\n    out float NdotL,\n    out float weightOverPdf)\n{\n    ImportanceSampleCosDir(u, N, tangentX, tangentY, L);\n\n    NdotL = saturate(dot(N, L));\n\n    // Importance sampling weight for each sample\n    // pdf = N.L / PI\n    // weight = fr * (N.L) with fr = diffuseAlbedo / PI\n    // weight over pdf is:\n    // weightOverPdf = (diffuseAlbedo / PI) * (N.L) / (N.L / PI)\n    // weightOverPdf = diffuseAlbedo\n    // diffuseAlbedo is apply outside the function\n\n    weightOverPdf = 1.0f;\n}"
        },
        {
          "comment": "// ----------------------------------------------------------------------------\n// weightOverPdf return the weight (without the Fresnel term) over pdf. Fresnel term must be apply by the caller.",
          "lineNum": 169,
          "modifiers": "",
          "parameters": "float2 u,    float3 V,    float3 N,    float3 tangentX,    float3 tangentY,    float roughness,    float NdotV,    out float3 L,    out float VdotH,    out float NdotL,    out float weightOverPdf",
          "type": "void",
          "name": "ImportanceSampleGGX",
          "code": "void ImportanceSampleGGX(\n    float2 u,\n    float3 V,\n    float3 N,\n    float3 tangentX,\n    float3 tangentY,\n    float roughness,\n    float NdotV,\n    out float3 L,\n    out float VdotH,\n    out float NdotL,\n    out float weightOverPdf)\n{\n    float3 H;\n    ImportanceSampleGGXDir(u, V, N, tangentX, tangentY, roughness, H, L);\n\n    float NdotH = saturate(dot(N, H));\n    // Note: since L and V are symmetric around H, LdotH == VdotH\n    VdotH = saturate(dot(V, H));\n    NdotL = saturate(dot(N, L));\n\n    // Importance sampling weight for each sample\n    // pdf = D(H) * (N.H) / (4 * (L.H))\n    // weight = fr * (N.L) with fr = F(H) * G(V, L) * D(H) / (4 * (N.L) * (N.V))\n    // weight over pdf is:\n    // weightOverPdf = F(H) * G(V, L) * (L.H) / ((N.H) * (N.V))\n    // weightOverPdf = F(H) * 4 * (N.L) * V(V, L) * (L.H) / (N.H) with V(V, L) = G(V, L) / (4 * (N.L) * (N.V))\n    // F is apply outside the function\n\n    float Vis = SmithJointGGXVisibilityTerm(NdotL, NdotV, roughness);\n    weightOverPdf = 4.0f * Vis * NdotL * VdotH / NdotH;\n}"
        },
        {
          "comment": "// Ref: Moving Frostbite to PBR (Appendix A)",
          "lineNum": 207,
          "modifiers": "",
          "parameters": "out float3 diffuseLighting,                                    UNITY_ARGS_TEXCUBE(tex),                                    float4 texHdrParam,                                     float3 N,                                    float3 diffuseAlbedo,                                    uint sampleCount = 2048",
          "type": "void",
          "name": "IntegrateLambertDiffuseIBLRef",
          "code": "void IntegrateLambertDiffuseIBLRef( out float3 diffuseLighting,\n                                    UNITY_ARGS_TEXCUBE(tex),\n                                    float4 texHdrParam, // Multiplier to apply on hdr texture (in case of rgbm)\n                                    float3 N,\n                                    float3 diffuseAlbedo,\n                                    uint sampleCount = 2048)\n{\n    float3 acc      = float3(0.0f, 0.0f, 0.0f);\n    // Add some jittering on Hammersley2d\n    float2 randNum  = InitRandom(N.xy * 0.5f + 0.5f);\n\n    float3 tangentX, tangentY;\n    GetLocalFrame(N, tangentX, tangentY);\n\n    for (uint i = 0; i < sampleCount; ++i)\n    {\n        float2 u    = Hammersley2d(i, sampleCount);\n        u           = frac(u + randNum + 0.5f);\n\n        float3 L;\n        float NdotL;\n        float weightOverPdf;\n        ImportanceSampleLambert(u, N, tangentX, tangentY, L, NdotL, weightOverPdf);\n\n        if (NdotL > 0.0f)\n        {\n            float4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex, L, 0).rgba;\n            float3 val = DecodeHDR(rgbm, texHdrParam);\n\n            // diffuse Albedo is apply here as describe in ImportanceSampleLambert function\n            acc += diffuseAlbedo * weightOverPdf * val;\n        }\n    }\n\n    diffuseLighting = acc / sampleCount;\n}"
        },
        {
          "comment": "",
          "lineNum": 246,
          "modifiers": "",
          "parameters": "out float3 diffuseLighting,                                    UNITY_ARGS_TEXCUBE(tex),                                    float4 texHdrParam,                                     float3 N,                                    float3 V,                                    float roughness,                                    float3 diffuseAlbedo,                                    uint sampleCount = 2048",
          "type": "void",
          "name": "IntegrateDisneyDiffuseIBLRef",
          "code": "void IntegrateDisneyDiffuseIBLRef(  out float3 diffuseLighting,\n                                    UNITY_ARGS_TEXCUBE(tex),\n                                    float4 texHdrParam, // Multiplier to apply on hdr texture (in case of rgbm)\n                                    float3 N,\n                                    float3 V,\n                                    float roughness,\n                                    float3 diffuseAlbedo,\n                                    uint sampleCount = 2048)\n{\n    float NdotV = dot(N, V);\n    float3 acc  = float3(0.0f, 0.0f, 0.0f);\n    // Add some jittering on Hammersley2d\n    float2 randNum  = InitRandom(N.xy * 0.5f + 0.5f);\n\n    float3 tangentX, tangentY;\n    GetLocalFrame(N, tangentX, tangentY);\n\n    for (uint i = 0; i < sampleCount; ++i)\n    {\n        float2 u    = Hammersley2d(i, sampleCount);\n        u           = frac(u + randNum + 0.5f);\n\n        float3 L;\n        float NdotL;\n        float weightOverPdf;\n        // for Disney we still use a Cosine importance sampling, true Disney importance sampling imply a look up table\n        ImportanceSampleLambert(u, N, tangentX, tangentY, L, NdotL, weightOverPdf);\n\n        if (NdotL > 0.0f)\n        {\n            float4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex, L, 0).rgba;\n            float3 val = DecodeHDR(rgbm, texHdrParam);\n\n            float3 H = normalize(L + V);\n            float LdotH = dot(L, H);\n            // Note: we call DisneyDiffuse that require to multiply by Albedo / PI. Divide by PI is already taken into account\n            // in weightOverPdf of ImportanceSampleLambert call.\n            float disneyDiffuse = DisneyDiffuse(NdotV, NdotL, LdotH, RoughnessToPerceptualRoughness(roughness));\n\n            // diffuse Albedo is apply here as describe in ImportanceSampleLambert function\n            acc += diffuseAlbedo * disneyDiffuse * weightOverPdf * val;\n        }\n    }\n\n    diffuseLighting = acc / sampleCount;\n}"
        },
        {
          "comment": "// ----------------------------------------------------------------------------\n// Ref: Moving Frostbite to PBR (Appendix A)",
          "lineNum": 295,
          "modifiers": "",
          "parameters": "out float3 specularLighting,                                UNITY_ARGS_TEXCUBE(tex),                                float4 texHdrParam,                                 float3 N,                                float3 V,                                float roughness,                                float3 f0,                                float f90,                                uint sampleCount = 2048",
          "type": "void",
          "name": "IntegrateSpecularGGXIBLRef",
          "code": "void IntegrateSpecularGGXIBLRef(out float3 specularLighting,\n                                UNITY_ARGS_TEXCUBE(tex),\n                                float4 texHdrParam, // Multiplier to apply on hdr texture (in case of rgbm)\n                                float3 N,\n                                float3 V,\n                                float roughness,\n                                float3 f0,\n                                float f90,\n                                uint sampleCount = 2048)\n{\n    float NdotV     = saturate(dot(N, V));\n    float3 acc      = float3(0.0f, 0.0f, 0.0f);\n    // Add some jittering on Hammersley2d\n    float2 randNum  = InitRandom(V.xy * 0.5f + 0.5f);\n\n    float3 tangentX, tangentY;\n    GetLocalFrame(N, tangentX, tangentY);\n\n    for (uint i = 0; i < sampleCount; ++i)\n    {\n        float2 u    = Hammersley2d(i, sampleCount);\n        u           = frac(u + randNum + 0.5f);\n\n        float VdotH;\n        float NdotL;\n        float3 L;\n        float weightOverPdf;\n\n        // GGX BRDF\n        ImportanceSampleGGX(u, V, N, tangentX, tangentY, roughness, NdotV,\n                            L, VdotH, NdotL, weightOverPdf);\n\n        if (NdotL > 0.0f)\n        {\n            // Fresnel component is apply here as describe in ImportanceSampleGGX function\n            float3 FweightOverPdf = FresnelLerp(f0, f90, VdotH) * weightOverPdf;\n\n            float4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex, L, 0).rgba;\n            float3 val = DecodeHDR(rgbm, texHdrParam);\n\n            acc += FweightOverPdf * val;\n        }\n    }\n\n    specularLighting = acc / sampleCount;\n}"
        },
        {
          "comment": "// Ref: Listing 18 in \"Moving Frostbite to PBR\" + https://knarkowicz.wordpress.com/2014/12/27/analytical-dfg-term-for-ibl/",
          "lineNum": 347,
          "modifiers": "",
          "parameters": "float3 V, float3 N, float roughness, uint sampleCount",
          "type": "float4",
          "name": "IntegrateDFG",
          "code": "float4 IntegrateDFG(float3 V, float3 N, float roughness, uint sampleCount)\n{\n    float NdotV     = saturate(dot(N, V));\n    float4 acc      = float4(0.0f, 0.0f, 0.0f, 0.0f);\n    // Add some jittering on Hammersley2d\n    float2 randNum  = InitRandom(V.xy * 0.5f + 0.5f);\n\n    float3 tangentX, tangentY;\n    GetLocalFrame(N, tangentX, tangentY);\n\n    for (uint i = 0; i < sampleCount; ++i)\n    {\n        float2 u    = Hammersley2d(i, sampleCount);\n        u           = frac(u + randNum + 0.5f);\n\n        float VdotH;\n        float NdotL;\n        float weightOverPdf;\n\n        float3 L; // Unused\n        ImportanceSampleGGX(u, V, N, tangentX, tangentY, roughness, NdotV,\n                            L, VdotH, NdotL, weightOverPdf);\n\n        if (NdotL > 0.0f)\n        {\n            // Integral is\n            //   1 / NumSample * \\int[  L * fr * (N.L) / pdf ]  with pdf =  D(H) * (N.H) / (4 * (L.H)) and fr = F(H) * G(V, L) * D(H) / (4 * (N.L) * (N.V))\n            // This is split  in two part:\n            //   A) \\int[ L * (N.L) ]\n            //   B) \\int[ F(H) * 4 * (N.L) * V(V, L) * (L.H) / (N.H) ] with V(V, L) = G(V, L) / (4 * (N.L) * (N.V))\n            //      = \\int[ F(H) * weightOverPdf ]\n\n            // Recombine at runtime with: ( f0 * weightOverPdf * (1 - Fc) + f90 * weightOverPdf * Fc ) with Fc =(1 - V.H)^5\n            float Fc            = pow(1.0f - VdotH, 5.0f);\n            acc.x               += (1.0f - Fc) * weightOverPdf;\n            acc.y               += Fc * weightOverPdf;\n        }\n\n        // for Disney we still use a Cosine importance sampling, true Disney importance sampling imply a look up table\n        ImportanceSampleLambert(u, N, tangentX, tangentY, L, NdotL, weightOverPdf);\n\n        if (NdotL > 0.0f)\n        {\n            float3 H = normalize(L + V);\n            float LdotH = dot(L, H);\n            float disneyDiffuse = DisneyDiffuse(NdotV, NdotL, LdotH, RoughnessToPerceptualRoughness(roughness));\n\n            acc.z += disneyDiffuse * weightOverPdf;\n        }\n    }\n\n    return acc / sampleCount;\n}"
        },
        {
          "comment": "// ----------------------------------------------------------------------------\n// Ref: Listing 19 in \"Moving Frostbite to PBR\"\n// IntegrateLD will not work with RGBM cubemap. For now it is use with fp16 cubemap such as those use for real time cubemap.",
          "lineNum": 404,
          "modifiers": "",
          "parameters": "UNITY_ARGS_TEXCUBE(tex),                    float3 V,                    float3 N,                    float roughness,                    float mipmapcount,                    float invOmegaP,                    uint sampleCount,                    bool prefilter = true",
          "type": "float4",
          "name": "IntegrateLD",
          "code": "float4 IntegrateLD( UNITY_ARGS_TEXCUBE(tex),\n                    float3 V,\n                    float3 N,\n                    float roughness,\n                    float mipmapcount,\n                    float invOmegaP,\n                    uint sampleCount,\n                    bool prefilter = true) // static bool\n{\n    float3 acc          = float3(0.0f, 0.0f, 0.0f);\n    float  accWeight    = 0;\n\n    float2 randNum  = InitRandom(V.xy * 0.5f + 0.5f);\n\n    float3 tangentX, tangentY;\n    GetLocalFrame(N, tangentX, tangentY);\n\n    for (uint i = 0; i < sampleCount; ++i)\n    {\n        float2 u    = Hammersley2d(i, sampleCount);\n        u           = frac(u + randNum + 0.5f);\n\n        float3 H;\n        float3 L;\n        ImportanceSampleGGXDir(u, V, N, tangentX, tangentY, roughness, H, L);\n\n        float NdotL = saturate(dot(N,L));\n\n        float mipLevel;\n\n        if (!prefilter) // BRDF importance sampling\n        {\n            mipLevel = 0.0f;\n        }\n        else // Prefiltered BRDF importance sampling\n        {\n            float NdotH = saturate(dot(N, H));\n            // Note: since L and V are symmetric around H, LdotH == VdotH\n            float LdotH = saturate(dot(L, H));\n\n            // Use pre - filtered importance sampling (i.e use lower mipmap\n            // level for fetching sample with low probability in order\n            // to reduce the variance ).\n            // ( Reference : GPU Gem3: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch20.html)\n            //\n            // Since we pre - integrate the result for normal direction ,\n            // N == V and then NdotH == LdotH . This is why the BRDF pdf\n            // can be simplifed from :\n            // pdf = D * NdotH /(4* LdotH ) to pdf = D / 4;\n            //\n            // - OmegaS : Solid angle associated to a sample\n            // - OmegaP : Solid angle associated to a pixel of the cubemap\n\n            float pdf       = GGXTerm(NdotH, roughness) * NdotH / (4 * LdotH);\n            float omegaS    = 1.0f / (sampleCount * pdf);                           // Solid angle associated to a sample\n            // invOmegaP is precomputed on CPU and provide as a parameter of the function\n            // float omegaP = UNITY_FOUR_PI / (6.0f * cubemapWidth * cubemapWidth); // Solid angle associated to a pixel of the cubemap\n            // Clamp is not necessary as the hardware will do it.\n            // mipLevel     = clamp(0.5f * log2(omegaS * invOmegaP), 0, mipmapcount);\n            mipLevel        = 0.5f * log2(omegaS * invOmegaP); // Clamp is not necessary as the hardware will do it.\n        }\n\n        if (NdotL > 0.0f)\n        {\n            // No rgbm format here, only fp16\n            float3 val = UNITY_SAMPLE_TEXCUBE_LOD(tex, L, mipLevel).rgba;\n\n            // See p63 equation (53) of moving Frostbite to PBR v2 for the extra NdotL here (both in weight and value)\n            acc             += val * NdotL;\n            accWeight       += NdotL;\n        }\n    }\n\n    return float4(acc * (1.0f / accWeight), 1.0f);\n}"
        },
        {
          "comment": "",
          "lineNum": 497,
          "modifiers": "",
          "parameters": "half Smoothness, half3 worldViewDir, half3 Normal, half3 fresnel0",
          "type": "Unity_GlossyEnvironmentData",
          "name": "UnityGlossyEnvironmentSetup",
          "code": "Unity_GlossyEnvironmentData UnityGlossyEnvironmentSetup(half Smoothness, half3 worldViewDir, half3 Normal, half3 fresnel0)\n{\n    Unity_GlossyEnvironmentData g;\n\n    g.roughness /* perceptualRoughness */   = SmoothnessToPerceptualRoughness(Smoothness);\n    g.reflUVW   = reflect(-worldViewDir, Normal);\n\n    return g;\n}"
        },
        {
          "comment": "// ----------------------------------------------------------------------------",
          "lineNum": 508,
          "modifiers": "",
          "parameters": "half perceptualRoughness",
          "type": "half",
          "name": "perceptualRoughnessToMipmapLevel",
          "code": "half perceptualRoughnessToMipmapLevel(half perceptualRoughness)\n{\n    return perceptualRoughness * UNITY_SPECCUBE_LOD_STEPS;\n}"
        },
        {
          "comment": "// ----------------------------------------------------------------------------",
          "lineNum": 514,
          "modifiers": "",
          "parameters": "half mipmapLevel",
          "type": "half",
          "name": "mipmapLevelToPerceptualRoughness",
          "code": "half mipmapLevelToPerceptualRoughness(half mipmapLevel)\n{\n    return mipmapLevel / UNITY_SPECCUBE_LOD_STEPS;\n}"
        },
        {
          "comment": "// ----------------------------------------------------------------------------",
          "lineNum": 520,
          "modifiers": "",
          "parameters": "UNITY_ARGS_TEXCUBE(tex), half4 hdr, Unity_GlossyEnvironmentData glossIn",
          "type": "half3",
          "name": "Unity_GlossyEnvironment",
          "code": "half3 Unity_GlossyEnvironment (UNITY_ARGS_TEXCUBE(tex), half4 hdr, Unity_GlossyEnvironmentData glossIn)\n{\n    half perceptualRoughness = glossIn.roughness /* perceptualRoughness */ ;\n\n// TODO: CAUTION: remap from Morten may work only with offline convolution, see impact with runtime convolution!\n// For now disabled\n#if 0\n    float m = PerceptualRoughnessToRoughness(perceptualRoughness); // m is the real roughness parameter\n    const float fEps = 1.192092896e-07F;        // smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)\n    float n =  (2.0/max(fEps, m*m))-2.0;        // remap to spec power. See eq. 21 in --> https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\n\n    n /= 4;                                     // remap from n_dot_h formulatino to n_dot_r. See section \"Pre-convolved Cube Maps vs Path Tracers\" --> https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html\n\n    perceptualRoughness = pow( 2/(n+2), 0.25);      // remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)\n#else\n    // MM: came up with a surprisingly close approximation to what the #if 0'ed out code above does.\n    perceptualRoughness = perceptualRoughness*(1.7 - 0.7*perceptualRoughness);\n#endif\n\n\n    half mip = perceptualRoughnessToMipmapLevel(perceptualRoughness);\n    half3 R = glossIn.reflUVW;\n    half4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex, R, mip);\n\n    return DecodeHDR(rgbm, hdr);\n}"
        }
      ],
      "structs": [
        {
          "comment": "// ----------------------------------------------------------------------------\n// GlossyEnvironment - Function to integrate the specular lighting with default sky or reflection probes\n// ----------------------------------------------------------------------------",
          "lineNum": 485,
          "type": "struct",
          "name": "Unity_GlossyEnvironmentData",
          "modifiers": "",
          "code": "struct Unity_GlossyEnvironmentData\n{\n    // - Deferred case have one cubemap\n    // - Forward case can have two blended cubemap (unusual should be deprecated).\n\n    // Surface properties use for cubemap integration\n    half    roughness; // CAUTION: This is perceptualRoughness but because of compatibility this name can't be change :(\n    half3   reflUVW;\n};"
        }
      ],
      "variables": []
    },
    {
      "file": "UnityInstancing.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_INSTANCING_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 15,
          "code": "    #define UNITY_SUPPORT_INSTANCING"
        },
        {
          "comment": "",
          "lineNum": 19,
          "code": "    #define UNITY_SUPPORT_INSTANCING"
        },
        {
          "comment": "    // Treat instancing as not supported for surface shader analysis step -- it does not affect what is being read/written by the shader anyway.\n    // in analysis pass we force array size to be 1",
          "lineNum": 32,
          "code": "    #define UNITY_FORCE_MAX_INSTANCE_COUNT 1"
        },
        {
          "comment": "",
          "lineNum": 36,
          "code": "    #define UNITY_SUPPORT_STEREO_INSTANCING"
        },
        {
          "comment": "// These platforms support dynamically adjusting the instancing CB size according to the current batch.",
          "lineNum": 41,
          "code": "    #define UNITY_INSTANCING_SUPPORT_FLEXIBLE_ARRAY_SIZE"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// instancing paths\n// - UNITY_INSTANCING_ENABLED               Defined if instancing path is taken.\n// - UNITY_PROCEDURAL_INSTANCING_ENABLED    Defined if procedural instancing path is taken.\n// - UNITY_STEREO_INSTANCING_ENABLED        Defined if stereo instancing path is taken.",
          "lineNum": 54,
          "code": "    #define UNITY_INSTANCING_ENABLED"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// instancing paths\n// - UNITY_INSTANCING_ENABLED               Defined if instancing path is taken.\n// - UNITY_PROCEDURAL_INSTANCING_ENABLED    Defined if procedural instancing path is taken.\n// - UNITY_STEREO_INSTANCING_ENABLED        Defined if stereo instancing path is taken.",
          "lineNum": 57,
          "code": "    #define UNITY_PROCEDURAL_INSTANCING_ENABLED"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// instancing paths\n// - UNITY_INSTANCING_ENABLED               Defined if instancing path is taken.\n// - UNITY_PROCEDURAL_INSTANCING_ENABLED    Defined if procedural instancing path is taken.\n// - UNITY_STEREO_INSTANCING_ENABLED        Defined if stereo instancing path is taken.",
          "lineNum": 60,
          "code": "    #define UNITY_STEREO_INSTANCING_ENABLED"
        },
        {
          "comment": "    // These platforms have constant buffers disabled normally, but not here (see CBUFFER_START/CBUFFER_END in HLSLSupport.cginc).",
          "lineNum": 65,
          "code": "    #define UNITY_INSTANCING_CBUFFER_SCOPE_BEGIN(name)  cbuffer name {"
        },
        {
          "comment": "    // These platforms have constant buffers disabled normally, but not here (see CBUFFER_START/CBUFFER_END in HLSLSupport.cginc).",
          "lineNum": 66,
          "code": "    #define UNITY_INSTANCING_CBUFFER_SCOPE_END          }"
        },
        {
          "comment": "    // These platforms have constant buffers disabled normally, but not here (see CBUFFER_START/CBUFFER_END in HLSLSupport.cginc).",
          "lineNum": 68,
          "code": "    #define UNITY_INSTANCING_CBUFFER_SCOPE_BEGIN(name)  CBUFFER_START(name)"
        },
        {
          "comment": "    // These platforms have constant buffers disabled normally, but not here (see CBUFFER_START/CBUFFER_END in HLSLSupport.cginc).",
          "lineNum": 69,
          "code": "    #define UNITY_INSTANCING_CBUFFER_SCOPE_END          CBUFFER_END"
        },
        {
          "comment": "",
          "lineNum": 92,
          "code": "        #define DEFAULT_UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID;"
        },
        {
          "comment": "",
          "lineNum": 93,
          "code": "        #define UNITY_GET_INSTANCE_ID(input)    _GETINSTANCEID(input)"
        },
        {
          "comment": "",
          "lineNum": 95,
          "code": "        #define DEFAULT_UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;"
        },
        {
          "comment": "",
          "lineNum": 96,
          "code": "        #define UNITY_GET_INSTANCE_ID(input)    input.instanceID"
        },
        {
          "comment": "",
          "lineNum": 100,
          "code": "    #define DEFAULT_UNITY_VERTEX_INPUT_INSTANCE_ID"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 115,
          "code": "    #define DEFAULT_UNITY_VERTEX_OUTPUT_STEREO                          uint stereoTargetEyeIndexSV : SV_RenderTargetArrayIndex; uint stereoTargetEyeIndex : BLENDINDICES0;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 116,
          "code": "    #define DEFAULT_UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output)       output.stereoTargetEyeIndexSV = unity_StereoEyeIndex; output.stereoTargetEyeIndex = unity_StereoEyeIndex;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 118,
          "code": "    #define DEFAULT_UNITY_VERTEX_OUTPUT_STEREO                          uint stereoTargetEyeIndex : SV_RenderTargetArrayIndex;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 119,
          "code": "    #define DEFAULT_UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output)       output.stereoTargetEyeIndex = unity_StereoEyeIndex"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 121,
          "code": "    #define DEFAULT_UNITY_VERTEX_OUTPUT_STEREO_EYE_INDEX                uint stereoTargetEyeIndex : BLENDINDICES0;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 122,
          "code": "    #define DEFAULT_UNITY_INITIALIZE_OUTPUT_STEREO_EYE_INDEX(output)    output.stereoTargetEyeIndex = unity_StereoEyeIndex;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 123,
          "code": "    #define DEFAULT_UNITY_TRANSFER_VERTEX_OUTPUT_STEREO(input, output)  output.stereoTargetEyeIndex = input.stereoTargetEyeIndex;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 124,
          "code": "    #define DEFAULT_UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input) unity_StereoEyeIndex = input.stereoTargetEyeIndex;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX",
          "lineNum": 126,
          "code": "    #define DEFAULT_UNITY_VERTEX_OUTPUT_STEREO float stereoTargetEyeIndex : BLENDWEIGHT0;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 128,
          "code": "    #define DEFAULT_UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output) output.stereoTargetEyeIndex = unity_StereoEyeIndices[unity_StereoEyeIndex].x;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 129,
          "code": "    #define DEFAULT_UNITY_TRANSFER_VERTEX_OUTPUT_STEREO(input, output) output.stereoTargetEyeIndex = input.stereoTargetEyeIndex;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 131,
          "code": "        #define DEFAULT_UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input)"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 133,
          "code": "        #define DEFAULT_UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input) unity_StereoEyeIndex.x = input.stereoTargetEyeIndex;"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 136,
          "code": "    #define DEFAULT_UNITY_VERTEX_OUTPUT_STEREO"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 137,
          "code": "    #define DEFAULT_UNITY_VERTEX_OUTPUT_STEREO_EYE_INDEX"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 138,
          "code": "    #define DEFAULT_UNITY_INITIALIZE_OUTPUT_STEREO_EYE_INDEX(output)"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 139,
          "code": "    #define DEFAULT_UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output)"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 140,
          "code": "    #define DEFAULT_UNITY_TRANSFER_VERTEX_OUTPUT_STEREO(input, output)"
        },
        {
          "comment": "////////////////////////////////////////////////////////\n// basic stereo instancing setups\n// - UNITY_VERTEX_OUTPUT_STEREO             Declare stereo target eye field in vertex shader output struct.\n// - UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO  Assign the stereo target eye.\n// - UNITY_TRANSFER_VERTEX_OUTPUT_STEREO    Copy stero target from input struct to output struct. Used in vertex shader.\n// - UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX\n    // HACK: Workaround for Mali shader compiler issues with directly using GL_ViewID_OVR (GL_OVR_multiview). This array just contains the values 0 and 1.",
          "lineNum": 141,
          "code": "    #define DEFAULT_UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input)"
        },
        {
          "comment": "                // We must calculate the stereo eye index differently for GLES3\n                // because otherwise,  the unity shader compiler will emit a bitfieldInsert function.\n                // bitfieldInsert requires support for glsl version 400 or later.  Therefore the\n                // generated glsl code will fail to compile on lower end devices.  By changing the\n                // way we calculate the stereo eye index,  we can help the shader compiler to avoid\n                // emitting the bitfieldInsert function and thereby increase the number of devices we\n                // can run stereo instancing on.\n                // stereo eye index is automatically figured out from the instance ID",
          "lineNum": 201,
          "code": "        #define DEFAULT_UNITY_SETUP_INSTANCE_ID(input)          { UnitySetupInstanceID(UNITY_GET_INSTANCE_ID(input)); UnitySetupCompoundMatrices(); }"
        },
        {
          "comment": "                // We must calculate the stereo eye index differently for GLES3\n                // because otherwise,  the unity shader compiler will emit a bitfieldInsert function.\n                // bitfieldInsert requires support for glsl version 400 or later.  Therefore the\n                // generated glsl code will fail to compile on lower end devices.  By changing the\n                // way we calculate the stereo eye index,  we can help the shader compiler to avoid\n                // emitting the bitfieldInsert function and thereby increase the number of devices we\n                // can run stereo instancing on.\n                // stereo eye index is automatically figured out from the instance ID",
          "lineNum": 203,
          "code": "    #define UNITY_TRANSFER_INSTANCE_ID(input, output)   output.instanceID = UNITY_GET_INSTANCE_ID(input)"
        },
        {
          "comment": "                // We must calculate the stereo eye index differently for GLES3\n                // because otherwise,  the unity shader compiler will emit a bitfieldInsert function.\n                // bitfieldInsert requires support for glsl version 400 or later.  Therefore the\n                // generated glsl code will fail to compile on lower end devices.  By changing the\n                // way we calculate the stereo eye index,  we can help the shader compiler to avoid\n                // emitting the bitfieldInsert function and thereby increase the number of devices we\n                // can run stereo instancing on.\n                // stereo eye index is automatically figured out from the instance ID",
          "lineNum": 205,
          "code": "    #define DEFAULT_UNITY_SETUP_INSTANCE_ID(input)"
        },
        {
          "comment": "                // We must calculate the stereo eye index differently for GLES3\n                // because otherwise,  the unity shader compiler will emit a bitfieldInsert function.\n                // bitfieldInsert requires support for glsl version 400 or later.  Therefore the\n                // generated glsl code will fail to compile on lower end devices.  By changing the\n                // way we calculate the stereo eye index,  we can help the shader compiler to avoid\n                // emitting the bitfieldInsert function and thereby increase the number of devices we\n                // can run stereo instancing on.\n                // stereo eye index is automatically figured out from the instance ID",
          "lineNum": 206,
          "code": "    #define UNITY_TRANSFER_INSTANCE_ID(input, output)"
        },
        {
          "comment": "",
          "lineNum": 218,
          "code": "        #define UNITY_INSTANCED_ARRAY_SIZE  UNITY_FORCE_MAX_INSTANCE_COUNT"
        },
        {
          "comment": "",
          "lineNum": 220,
          "code": "        #define UNITY_INSTANCED_ARRAY_SIZE  2 // minimum array size that ensures dynamic indexing"
        },
        {
          "comment": "",
          "lineNum": 222,
          "code": "        #define UNITY_INSTANCED_ARRAY_SIZE  UNITY_MAX_INSTANCE_COUNT"
        },
        {
          "comment": "",
          "lineNum": 225,
          "code": "            #define UNITY_INSTANCED_ARRAY_SIZE  250"
        },
        {
          "comment": "",
          "lineNum": 227,
          "code": "            #define UNITY_INSTANCED_ARRAY_SIZE  500"
        },
        {
          "comment": "",
          "lineNum": 231,
          "code": "    #define UNITY_INSTANCING_BUFFER_START(buf)      UNITY_INSTANCING_CBUFFER_SCOPE_BEGIN(UnityInstancing_##buf) struct {"
        },
        {
          "comment": "",
          "lineNum": 232,
          "code": "    #define UNITY_INSTANCING_BUFFER_END(arr)        } arr##Array[UNITY_INSTANCED_ARRAY_SIZE]; UNITY_INSTANCING_CBUFFER_SCOPE_END"
        },
        {
          "comment": "",
          "lineNum": 233,
          "code": "    #define UNITY_DEFINE_INSTANCED_PROP(type, var)  type var;"
        },
        {
          "comment": "",
          "lineNum": 234,
          "code": "    #define UNITY_ACCESS_INSTANCED_PROP(arr, var)   arr##Array[unity_InstanceID].var"
        },
        {
          "comment": "    // Put worldToObject array to a separate CB if UNITY_ASSUME_UNIFORM_SCALING is defined. Most of the time it will not be used.",
          "lineNum": 238,
          "code": "        #define UNITY_WORLDTOOBJECTARRAY_CB 1"
        },
        {
          "comment": "    // Put worldToObject array to a separate CB if UNITY_ASSUME_UNIFORM_SCALING is defined. Most of the time it will not be used.",
          "lineNum": 240,
          "code": "        #define UNITY_WORLDTOOBJECTARRAY_CB 0"
        },
        {
          "comment": "",
          "lineNum": 244,
          "code": "        #define UNITY_USE_LODFADE_ARRAY"
        },
        {
          "comment": "",
          "lineNum": 248,
          "code": "        #define UNITY_USE_RENDERINGLAYER_ARRAY"
        },
        {
          "comment": "",
          "lineNum": 254,
          "code": "            #define UNITY_USE_LIGHTMAPST_ARRAY"
        },
        {
          "comment": "",
          "lineNum": 257,
          "code": "            #define UNITY_USE_DYNAMICLIGHTMAPST_ARRAY"
        },
        {
          "comment": "",
          "lineNum": 263,
          "code": "            #define UNITY_USE_SHCOEFFS_ARRAYS"
        },
        {
          "comment": "",
          "lineNum": 266,
          "code": "            #define UNITY_USE_PROBESOCCLUSION_ARRAY"
        },
        {
          "comment": "            // the quantized fade value (unity_LODFade.y) is automatically used for cross-fading instances",
          "lineNum": 280,
          "code": "            #define unity_LODFade UNITY_ACCESS_INSTANCED_PROP(unity_Builtins0, unity_LODFadeArray).xyxx"
        },
        {
          "comment": "            // the quantized fade value (unity_LODFade.y) is automatically used for cross-fading instances",
          "lineNum": 284,
          "code": "            #define unity_RenderingLayer UNITY_ACCESS_INSTANCED_PROP(unity_Builtins0, unity_RenderingLayerArray).xxxx"
        },
        {
          "comment": "            // the quantized fade value (unity_LODFade.y) is automatically used for cross-fading instances",
          "lineNum": 295,
          "code": "            #define unity_LODFade UNITY_ACCESS_INSTANCED_PROP(unity_Builtins1, unity_LODFadeArray).xyxx"
        },
        {
          "comment": "            // the quantized fade value (unity_LODFade.y) is automatically used for cross-fading instances",
          "lineNum": 299,
          "code": "            #define unity_RenderingLayer UNITY_ACCESS_INSTANCED_PROP(unity_Builtins1, unity_RenderingLayerArray).xxxx"
        },
        {
          "comment": "",
          "lineNum": 306,
          "code": "            #define unity_LightmapST UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_LightmapSTArray)"
        },
        {
          "comment": "",
          "lineNum": 310,
          "code": "            #define unity_DynamicLightmapST UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_DynamicLightmapSTArray)"
        },
        {
          "comment": "",
          "lineNum": 320,
          "code": "            #define unity_SHAr UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_SHArArray)"
        },
        {
          "comment": "",
          "lineNum": 321,
          "code": "            #define unity_SHAg UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_SHAgArray)"
        },
        {
          "comment": "",
          "lineNum": 322,
          "code": "            #define unity_SHAb UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_SHAbArray)"
        },
        {
          "comment": "",
          "lineNum": 323,
          "code": "            #define unity_SHBr UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_SHBrArray)"
        },
        {
          "comment": "",
          "lineNum": 324,
          "code": "            #define unity_SHBg UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_SHBgArray)"
        },
        {
          "comment": "",
          "lineNum": 325,
          "code": "            #define unity_SHBb UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_SHBbArray)"
        },
        {
          "comment": "",
          "lineNum": 326,
          "code": "            #define unity_SHC  UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_SHCArray)"
        },
        {
          "comment": "",
          "lineNum": 330,
          "code": "            #define unity_ProbesOcclusion UNITY_ACCESS_INSTANCED_PROP(unity_Builtins2, unity_ProbesOcclusionArray)"
        },
        {
          "comment": "",
          "lineNum": 335,
          "code": "        #define unity_ObjectToWorld     UNITY_ACCESS_INSTANCED_PROP(unity_Builtins0, unity_ObjectToWorldArray)"
        },
        {
          "comment": "",
          "lineNum": 336,
          "code": "        #define MERGE_UNITY_BUILTINS_INDEX(X) unity_Builtins##X"
        },
        {
          "comment": "",
          "lineNum": 337,
          "code": "        #define unity_WorldToObject     UNITY_ACCESS_INSTANCED_PROP(MERGE_UNITY_BUILTINS_INDEX(UNITY_WORLDTOOBJECTARRAY_CB), unity_WorldToObjectArray)"
        },
        {
          "comment": "",
          "lineNum": 347,
          "code": "        #define UnityObjectToClipPos UnityObjectToClipPosInstanced"
        },
        {
          "comment": "    // in procedural mode we don't need cbuffer, and properties are not uniforms",
          "lineNum": 354,
          "code": "        #define UNITY_INSTANCING_BUFFER_START(buf)"
        },
        {
          "comment": "    // in procedural mode we don't need cbuffer, and properties are not uniforms",
          "lineNum": 355,
          "code": "        #define UNITY_INSTANCING_BUFFER_END(arr)"
        },
        {
          "comment": "    // in procedural mode we don't need cbuffer, and properties are not uniforms",
          "lineNum": 356,
          "code": "        #define UNITY_DEFINE_INSTANCED_PROP(type, var)      static type var;"
        },
        {
          "comment": "    // in procedural mode we don't need cbuffer, and properties are not uniforms",
          "lineNum": 358,
          "code": "        #define UNITY_INSTANCING_BUFFER_START(buf)          CBUFFER_START(buf)"
        },
        {
          "comment": "    // in procedural mode we don't need cbuffer, and properties are not uniforms",
          "lineNum": 359,
          "code": "        #define UNITY_INSTANCING_BUFFER_END(arr)            CBUFFER_END"
        },
        {
          "comment": "    // in procedural mode we don't need cbuffer, and properties are not uniforms",
          "lineNum": 360,
          "code": "        #define UNITY_DEFINE_INSTANCED_PROP(type, var)      type var;"
        },
        {
          "comment": "",
          "lineNum": 363,
          "code": "    #define UNITY_ACCESS_INSTANCED_PROP(arr, var)           var"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 388,
          "code": "        #define UNITY_MATRIX_MVP    unity_MatrixMVP_Instanced"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 389,
          "code": "        #define UNITY_MATRIX_MV     unity_MatrixMV_Instanced"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 390,
          "code": "        #define UNITY_MATRIX_T_MV   unity_MatrixTMV_Instanced"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 391,
          "code": "        #define UNITY_MATRIX_IT_MV  unity_MatrixITMV_Instanced"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 170,
          "modifiers": "",
          "parameters": "uint inputInstanceID",
          "type": "void",
          "name": "UnitySetupInstanceID",
          "code": "    void UnitySetupInstanceID(uint inputInstanceID)\n    {\n        #ifdef UNITY_STEREO_INSTANCING_ENABLED\n            #if defined(SHADER_API_GLES3)\n                // We must calculate the stereo eye index differently for GLES3\n                // because otherwise,  the unity shader compiler will emit a bitfieldInsert function.\n                // bitfieldInsert requires support for glsl version 400 or later.  Therefore the\n                // generated glsl code will fail to compile on lower end devices.  By changing the\n                // way we calculate the stereo eye index,  we can help the shader compiler to avoid\n                // emitting the bitfieldInsert function and thereby increase the number of devices we\n                // can run stereo instancing on.\n                unity_StereoEyeIndex = round(fmod(inputInstanceID, 2.0));\n                unity_InstanceID = unity_BaseInstanceID + (inputInstanceID >> 1);\n            #else\n                // stereo eye index is automatically figured out from the instance ID\n                unity_StereoEyeIndex = inputInstanceID & 0x01;\n                unity_InstanceID = unity_BaseInstanceID + (inputInstanceID >> 1);\n            #endif\n        #else\n            unity_InstanceID = inputInstanceID + unity_BaseInstanceID;\n        #endif\n    }"
        },
        {
          "comment": "                // We must calculate the stereo eye index differently for GLES3\n                // because otherwise,  the unity shader compiler will emit a bitfieldInsert function.\n                // bitfieldInsert requires support for glsl version 400 or later.  Therefore the\n                // generated glsl code will fail to compile on lower end devices.  By changing the\n                // way we calculate the stereo eye index,  we can help the shader compiler to avoid\n                // emitting the bitfieldInsert function and thereby increase the number of devices we\n                // can run stereo instancing on.\n                // stereo eye index is automatically figured out from the instance ID",
          "lineNum": 192,
          "modifiers": "",
          "parameters": ");    #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED        #ifndef UNITY_INSTANCING_PROCEDURAL_FUNC            #error \"UNITY_INSTANCING_PROCEDURAL_FUNC must be defined.\"        #else            void UNITY_INSTANCING_PROCEDURAL_FUNC();             #define DEFAULT_UNITY_SETUP_INSTANCE_ID(input)      { UnitySetupInstanceID(UNITY_GET_INSTANCE_ID(input)); UNITY_INSTANCING_PROCEDURAL_FUNC(); UnitySetupCompoundMatrices(",
          "type": "void",
          "name": "UnitySetupCompoundMatrices",
          "code": "    void UnitySetupCompoundMatrices();\n    #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n        #ifndef UNITY_INSTANCING_PROCEDURAL_FUNC\n            #error \"UNITY_INSTANCING_PROCEDURAL_FUNC must be defined.\"\n        #else\n            void UNITY_INSTANCING_PROCEDURAL_FUNC(); // forward declaration of the procedural function\n            #define DEFAULT_UNITY_SETUP_INSTANCE_ID(input)      { UnitySetupInstanceID(UNITY_GET_INSTANCE_ID(input)); UNITY_INSTANCING_PROCEDURAL_FUNC(); UnitySetupCompoundMatrices(); }"
        },
        {
          "comment": "",
          "lineNum": 339,
          "modifiers": "inline",
          "parameters": "in float3 pos",
          "type": "float4",
          "name": "UnityObjectToClipPosInstanced",
          "code": "        inline float4 UnityObjectToClipPosInstanced(in float3 pos)\n        {\n            return mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(pos, 1.0)));\n        }"
        },
        {
          "comment": "",
          "lineNum": 343,
          "modifiers": "inline",
          "parameters": "float4 pos",
          "type": "float4",
          "name": "UnityObjectToClipPosInstanced",
          "code": "        inline float4 UnityObjectToClipPosInstanced(float4 pos)\n        {\n            return UnityObjectToClipPosInstanced(pos.xyz);\n        }"
        },
        {
          "comment": "",
          "lineNum": 370,
          "modifiers": "",
          "parameters": "",
          "type": "void",
          "name": "UnitySetupCompoundMatrices",
          "code": "        void UnitySetupCompoundMatrices() {}"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 377,
          "modifiers": "",
          "parameters": "",
          "type": "void",
          "name": "UnitySetupCompoundMatrices",
          "code": "        void UnitySetupCompoundMatrices()\n        {\n            unity_MatrixMVP_Instanced = mul(unity_MatrixVP, unity_ObjectToWorld);\n            unity_MatrixMV_Instanced = mul(unity_MatrixV, unity_ObjectToWorld);\n            unity_MatrixTMV_Instanced = transpose(unity_MatrixMV_Instanced);\n            unity_MatrixITMV_Instanced = transpose(mul(unity_WorldToObject, unity_MatrixInvV));\n        }"
        }
      ],
      "structs": [],
      "variables": [
        {
          "comment": "    // A global instance ID variable that functions can directly access.",
          "lineNum": 79,
          "modifiers": "static",
          "type": "uint",
          "name": "unity_InstanceID;",
          "code": "static uint unity_InstanceID;"
        },
        {
          "comment": "    // Don't make UnityDrawCallInfo an actual CB on GL",
          "lineNum": 85,
          "modifiers": "",
          "type": "int",
          "name": "unity_BaseInstanceID;",
          "code": "int unity_BaseInstanceID;"
        },
        {
          "comment": "    // Don't make UnityDrawCallInfo an actual CB on GL",
          "lineNum": 86,
          "modifiers": "",
          "type": "int",
          "name": "unity_InstanceCount;",
          "code": "int unity_InstanceCount;"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 373,
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixMVP_Instanced;",
          "code": "static float4x4 unity_MatrixMVP_Instanced;"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 374,
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixMV_Instanced;",
          "code": "static float4x4 unity_MatrixMV_Instanced;"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 375,
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixTMV_Instanced;",
          "code": "static float4x4 unity_MatrixTMV_Instanced;"
        },
        {
          "comment": "        // The following matrix evaluations depend on the static var unity_InstanceID & unity_StereoEyeIndex. They need to be initialized after UnitySetupInstanceID.",
          "lineNum": 376,
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixITMV_Instanced;",
          "code": "static float4x4 unity_MatrixITMV_Instanced;"
        }
      ]
    },
    {
      "file": "UnityLightingCommon.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_LIGHTING_COMMON_INCLUDED"
        }
      ],
      "functions": [],
      "structs": [
        {
          "comment": "",
          "lineNum": 7,
          "type": "struct",
          "name": "UnityLight",
          "modifiers": "",
          "code": "struct UnityLight\n{\n    half3 color;\n    half3 dir;\n    half  ndotl; // Deprecated: Ndotl is now calculated on the fly and is no longer stored. Do not used it.\n};"
        },
        {
          "comment": "",
          "lineNum": 14,
          "type": "struct",
          "name": "UnityIndirect",
          "modifiers": "",
          "code": "struct UnityIndirect\n{\n    half3 diffuse;\n    half3 specular;\n};"
        },
        {
          "comment": "",
          "lineNum": 20,
          "type": "struct",
          "name": "UnityGI",
          "modifiers": "",
          "code": "struct UnityGI\n{\n    UnityLight light;\n    UnityIndirect indirect;\n};"
        },
        {
          "comment": "",
          "lineNum": 26,
          "type": "struct",
          "name": "UnityGIInput",
          "modifiers": "",
          "code": "struct UnityGIInput\n{\n    UnityLight light; // pixel light, sent from the engine\n\n    float3 worldPos;\n    half3 worldViewDir;\n    half atten;\n    half3 ambient;\n\n    // interpolated lightmap UVs are passed as full float precision data to fragment shaders\n    // so lightmapUV (which is used as a tmp inside of lightmap fragment shaders) should\n    // also be full float precision to avoid data loss before sampling a texture.\n    float4 lightmapUV; // .xy = static lightmap UV, .zw = dynamic lightmap UV\n\n    #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION) || defined(UNITY_ENABLE_REFLECTION_BUFFERS)\n    float4 boxMin[2];\n    #endif\n    #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    float4 boxMax[2];\n    float4 probePosition[2];\n    #endif\n    // HDR cubemap properties, use to decompress HDR texture\n    float4 probeHDR[2];\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 4,
          "modifiers": "",
          "type": "fixed4",
          "name": "_LightColor0;",
          "code": "fixed4 _LightColor0;"
        },
        {
          "comment": "",
          "lineNum": 5,
          "modifiers": "",
          "type": "fixed4",
          "name": "_SpecColor;",
          "code": "fixed4 _SpecColor;"
        }
      ]
    },
    {
      "file": "UnityMetaPass.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_META_PASS_INCLUDED"
        },
        {
          "comment": "//Visualization defines\n// Should be kept in sync with the EditorVisualizationMode enum in EditorCameraDrawing.cpp",
          "lineNum": 35,
          "code": "#define EDITORVIZ_PBR_VALIDATION_ALBEDO         0"
        },
        {
          "comment": "//Visualization defines\n// Should be kept in sync with the EditorVisualizationMode enum in EditorCameraDrawing.cpp",
          "lineNum": 36,
          "code": "#define EDITORVIZ_PBR_VALIDATION_METALSPECULAR  1"
        },
        {
          "comment": "//Visualization defines\n// Should be kept in sync with the EditorVisualizationMode enum in EditorCameraDrawing.cpp",
          "lineNum": 37,
          "code": "#define EDITORVIZ_TEXTURE                       2"
        },
        {
          "comment": "//Visualization defines\n// Should be kept in sync with the EditorVisualizationMode enum in EditorCameraDrawing.cpp",
          "lineNum": 38,
          "code": "#define EDITORVIZ_SHOWLIGHTMASK                 3"
        },
        {
          "comment": "//Visualization defines\n// Should be kept in sync with the EditorVisualizationMode enum in EditorCameraDrawing.cpp\n// Old names...",
          "lineNum": 40,
          "code": "#define PBR_VALIDATION_ALBEDO EDITORVIZ_PBR_VALIDATION_ALBEDO"
        },
        {
          "comment": "//Visualization defines\n// Should be kept in sync with the EditorVisualizationMode enum in EditorCameraDrawing.cpp\n// Old names...",
          "lineNum": 41,
          "code": "#define PBR_VALIDATION_METALSPECULAR EDITORVIZ_PBR_VALIDATION_METALSPECULAR"
        },
        {
          "comment": "",
          "lineNum": 60,
          "code": "#define unity_EditorViz_ChannelSelect unity_EditorViz_ColorMul"
        },
        {
          "comment": "",
          "lineNum": 61,
          "code": "#define unity_EditorViz_Color         unity_EditorViz_ColorAdd"
        },
        {
          "comment": "",
          "lineNum": 62,
          "code": "#define unity_EditorViz_LightType     unity_EditorViz_UVIndex"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 79,
          "modifiers": "",
          "parameters": "float offset, half dominantColor, half colorone, half colortwo",
          "type": "half3",
          "name": "UnityMeta_RGBToHSVHelper",
          "code": "half3 UnityMeta_RGBToHSVHelper(float offset, half dominantColor, half colorone, half colortwo)\n{\n    half H, S, V;\n    V = dominantColor;\n\n    if (V != 0.0)\n    {\n        half small = 0.0;\n        if (colorone > colortwo)\n            small = colortwo;\n        else\n            small = colorone;\n\n        half diff = V - small;\n\n        if (diff != 0)\n        {\n            S = diff / V;\n            H = offset + ((colorone - colortwo)/diff);\n        }\n        else\n        {\n            S = 0;\n            H = offset + (colorone - colortwo);\n        }\n\n        H /= 6.0;\n\n        if (H < 6.0)\n        {\n            H += 1.0;\n        }\n    }\n    else\n    {\n        S = 0;\n        H = 0;\n    }\n    return half3(H, S, V);\n}"
        },
        {
          "comment": "",
          "lineNum": 120,
          "modifiers": "",
          "parameters": "half3 rgbColor",
          "type": "half3",
          "name": "UnityMeta_RGBToHSV",
          "code": "half3 UnityMeta_RGBToHSV(half3 rgbColor)\n{\n    // when blue is highest valued\n    if((rgbColor.b > rgbColor.g) && (rgbColor.b > rgbColor.r))\n        return UnityMeta_RGBToHSVHelper(4.0, rgbColor.b, rgbColor.r, rgbColor.g);\n    //when green is highest valued\n    else if(rgbColor.g > rgbColor.r)\n        return UnityMeta_RGBToHSVHelper(2.0, rgbColor.g, rgbColor.b, rgbColor.r);\n    //when red is highest valued\n    else\n        return UnityMeta_RGBToHSVHelper(0.0, rgbColor.r, rgbColor.g, rgbColor.b);\n}"
        },
        {
          "comment": "// Pass 0 - Albedo",
          "lineNum": 134,
          "modifiers": "",
          "parameters": "UnityMetaInput IN",
          "type": "half4",
          "name": "UnityMeta_pbrAlbedo",
          "code": "half4 UnityMeta_pbrAlbedo(UnityMetaInput IN)\n{\n    half3 SpecularColor = IN.SpecularColor;\n    half3 baseColor = IN.Albedo;\n\n    if (IsGammaSpace())\n    {\n        baseColor = half3( GammaToLinearSpaceExact(baseColor.x), GammaToLinearSpaceExact(baseColor.y), GammaToLinearSpaceExact(baseColor.z) ); //GammaToLinearSpace(baseColor);\n        SpecularColor = GammaToLinearSpace(SpecularColor);\n    }\n\n    half3 unTouched = LinearRgbToLuminance(baseColor).xxx; // if no errors, leave color as it was in render\n\n    bool isMetal = dot(SpecularColor, float3(0.3333,0.3333,0.3333)) >= conductorMin;\n    // When checking full range we do not take the luminance but the mean because often in game blue color are highlight as too low whereas this is what we are looking for.\n    half value = _CheckAlbedo ? LinearRgbToLuminance(baseColor) : dot(baseColor, half3(0.3333, 0.3333, 0.3333));\n\n     // Check if we are pure metal with black albedo\n    if (_CheckPureMetal && isMetal && value != 0.0)\n        return unity_MaterialValidatePureMetalColor;\n\n    if (_CheckAlbedo == 0)\n    {\n        // If we have a metallic object, don't complain about low albedo\n        if (!isMetal && value < albedoMin)\n        {\n            return unity_MaterialValidateLowColor;\n        }\n        else if (value > albedoMax)\n        {\n            return unity_MaterialValidateHighColor;\n        }\n        else\n        {\n            return half4(unTouched, 0);\n        }\n    }\n    else\n    {\n        if (_AlbedoMinLuminance > value)\n        {\n             return unity_MaterialValidateLowColor;\n        }\n        else if (_AlbedoMaxLuminance < value)\n        {\n             return unity_MaterialValidateHighColor;\n        }\n        else\n        {\n            half3 hsv = UnityMeta_RGBToHSV(IN.Albedo);\n            half hue = hsv.r;\n            half sat = hsv.g;\n\n            half3 compHSV = UnityMeta_RGBToHSV(_AlbedoCompareColor.rgb);\n            half compHue = compHSV.r;\n            half compSat = compHSV.g;\n\n            if ((compSat - _AlbedoSaturationTolerance > sat) || ((compHue - _AlbedoHueTolerance > hue) && (compHue - _AlbedoHueTolerance + 1.0 > hue)))\n            {\n                return unity_MaterialValidateLowColor;\n            }\n            else if ((sat > compSat + _AlbedoSaturationTolerance) || ((hue > compHue + _AlbedoHueTolerance) && (hue > compHue + _AlbedoHueTolerance - 1.0)))\n            {\n                return unity_MaterialValidateHighColor;\n            }\n            else\n            {\n                return half4(unTouched, 0);\n            }\n        }\n    }\n\n    return half4(1.0, 0, 0, 1);\n}"
        },
        {
          "comment": "// Pass 1 - Metal Specular",
          "lineNum": 210,
          "modifiers": "",
          "parameters": "UnityMetaInput IN",
          "type": "half4",
          "name": "UnityMeta_pbrMetalspec",
          "code": "half4 UnityMeta_pbrMetalspec(UnityMetaInput IN)\n{\n    half3 SpecularColor = IN.SpecularColor;\n    half4 baseColor = half4(IN.Albedo, 0);\n\n    if (IsGammaSpace())\n    {\n        baseColor.xyz = GammaToLinearSpace(baseColor.xyz);\n        SpecularColor = GammaToLinearSpace(SpecularColor);\n    }\n\n    // Take the mean of three channel, works ok.\n    half value = dot(SpecularColor, half3(0.3333,0.3333,0.3333));\n    bool isMetal = value >= conductorMin;\n\n    half4 outColor = half4(LinearRgbToLuminance(baseColor.xyz).xxx, 1.0f);\n\n    if (value < conductorMin)\n    {\n         outColor = unity_MaterialValidateLowColor;\n    }\n    else if (value > conductorMax)\n    {\n        outColor = unity_MaterialValidateHighColor;\n    }\n    else if (isMetal)\n    {\n         // If we are here we supposed the users want to have a metal, so check if we have a pure metal (black albedo) or not\n        // if it is not a pure metal, highlight it\n        if (_CheckPureMetal)\n            outColor = dot(baseColor.xyz, half3(1,1,1)) == 0 ? outColor : unity_MaterialValidatePureMetalColor;\n    }\n\n    return outColor;\n}"
        },
        {
          "comment": "",
          "lineNum": 248,
          "modifiers": "",
          "parameters": "int uvIndex, float2 uv0, float2 uv1, float2 uv2, float4 st",
          "type": "float2",
          "name": "UnityMetaVizUV",
          "code": "float2 UnityMetaVizUV(int uvIndex, float2 uv0, float2 uv1, float2 uv2, float4 st)\n{\n    if (uvIndex == 0)\n        return uv0 * st.xy + st.zw;\n    else if (uvIndex == 1)\n        return uv1 * st.xy + st.zw;\n    else\n        return uv2 * st.xy + st.zw;\n}"
        },
        {
          "comment": "",
          "lineNum": 258,
          "modifiers": "",
          "parameters": "float4 vertex, float2 uv1, float2 uv2, float4 lightmapST, float4 dynlightmapST",
          "type": "float4",
          "name": "UnityMetaVertexPosition",
          "code": "float4 UnityMetaVertexPosition(float4 vertex, float2 uv1, float2 uv2, float4 lightmapST, float4 dynlightmapST)\n{\n#if !defined(EDITOR_VISUALIZATION)\n    if (unity_MetaVertexControl.x)\n    {\n        vertex.xy = uv1 * lightmapST.xy + lightmapST.zw;\n        // OpenGL right now needs to actually use incoming vertex position,\n        // so use it in a very dummy way\n        vertex.z = vertex.z > 0 ? 1.0e-4f : 0.0f;\n    }\n    if (unity_MetaVertexControl.y)\n    {\n        vertex.xy = uv2 * dynlightmapST.xy + dynlightmapST.zw;\n        // OpenGL right now needs to actually use incoming vertex position,\n        // so use it in a very dummy way\n        vertex.z = vertex.z > 0 ? 1.0e-4f : 0.0f;\n    }\n    return mul(UNITY_MATRIX_VP, float4(vertex.xyz, 1.0));\n#else\n    return UnityObjectToClipPos(vertex);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 285,
          "modifiers": "",
          "parameters": "UnityMetaInput IN",
          "type": "half4",
          "name": "UnityMetaFragment",
          "code": "half4 UnityMetaFragment (UnityMetaInput IN)\n{\n    half4 res = 0;\n#if !defined(EDITOR_VISUALIZATION)\n    if (unity_MetaFragmentControl.x)\n    {\n        res = half4(IN.Albedo,1);\n\n        // d3d9 shader compiler doesn't like NaNs and infinity.\n        unity_OneOverOutputBoost = saturate(unity_OneOverOutputBoost);\n\n        // Apply Albedo Boost from LightmapSettings.\n        res.rgb = clamp(pow(res.rgb, unity_OneOverOutputBoost), 0, unity_MaxOutputValue);\n    }\n    if (unity_MetaFragmentControl.y)\n    {\n        half3 emission;\n        if (unity_UseLinearSpace)\n            emission = IN.Emission;\n        else\n            emission = GammaToLinearSpace(IN.Emission);\n\n        res = half4(emission, 1.0);\n    }\n#else\n    if ( unity_VisualizationMode == EDITORVIZ_PBR_VALIDATION_ALBEDO)\n    {\n        res = UnityMeta_pbrAlbedo(IN);\n    }\n    else if (unity_VisualizationMode == EDITORVIZ_PBR_VALIDATION_METALSPECULAR)\n    {\n        res = UnityMeta_pbrMetalspec(IN);\n    }\n    else if (unity_VisualizationMode == EDITORVIZ_TEXTURE)\n    {\n        res = tex2D(unity_EditorViz_Texture, IN.VizUV);\n\n        if (unity_EditorViz_Decode_HDR.x > 0)\n            res = half4(DecodeHDR(res, unity_EditorViz_Decode_HDR), 1);\n\n        if (unity_EditorViz_ConvertToLinearSpace)\n            res.rgb = LinearToGammaSpace(res.rgb);\n\n        res *= unity_EditorViz_ColorMul;\n        res += unity_EditorViz_ColorAdd;\n    }\n    else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)\n    {\n        float result = dot(unity_EditorViz_ChannelSelect, tex2D(unity_EditorViz_Texture, IN.VizUV).rgba);\n        if (result == 0)\n            discard;\n\n        float atten = 1;\n        if (unity_EditorViz_LightType == 0)\n        {\n            // directional:  no attenuation\n        }\n        else if (unity_EditorViz_LightType == 1)\n        {\n            // point\n            atten = tex2D(unity_EditorViz_LightTexture, dot(IN.LightCoord.xyz, IN.LightCoord.xyz).xx).r;\n        }\n        else if (unity_EditorViz_LightType == 2)\n        {\n            // spot\n            atten = tex2D(unity_EditorViz_LightTexture, dot(IN.LightCoord.xyz, IN.LightCoord.xyz).xx).r;\n            float cookie = tex2D(unity_EditorViz_LightTextureB, IN.LightCoord.xy / IN.LightCoord.w + 0.5).w;\n            atten *= (IN.LightCoord.z > 0) * cookie;\n        }\n        clip(atten - 0.001f);\n\n        res = float4(unity_EditorViz_Color.xyz * result, unity_EditorViz_Color.w);\n    }\n#endif // EDITOR_VISUALIZATION\n    return res;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 20,
          "type": "struct",
          "name": "UnityMetaInput",
          "modifiers": "",
          "code": "struct UnityMetaInput\n{\n    half3 Albedo;\n    half3 Emission;\n    half3 SpecularColor;\n#ifdef EDITOR_VISUALIZATION\n    float2 VizUV;\n    float4 LightCoord;\n#endif\n};"
        }
      ],
      "variables": [
        {
          "comment": "    // x = use uv1 as raster position\n    // y = use uv2 as raster position",
          "lineNum": 8,
          "modifiers": "",
          "type": "bool4",
          "name": "unity_MetaVertexControl;",
          "code": "bool4 unity_MetaVertexControl;"
        },
        {
          "comment": "    // x = return albedo\n    // y = return normal",
          "lineNum": 12,
          "modifiers": "",
          "type": "bool4",
          "name": "unity_MetaFragmentControl;",
          "code": "bool4 unity_MetaFragmentControl;"
        },
        {
          "comment": "    // Control which VisualizationMode we will\n    // display in the editor",
          "lineNum": 16,
          "modifiers": "",
          "type": "int",
          "name": "unity_VisualizationMode;",
          "code": "int unity_VisualizationMode;"
        },
        {
          "comment": "",
          "lineNum": 43,
          "modifiers": "uniform   = 0",
          "type": "int",
          "name": "_CheckPureMetal",
          "code": "uniform int _CheckPureMetal = 0;// flag to check only full metal, not partial metal, known because it has metallic features and pure black albedo"
        },
        {
          "comment": "",
          "lineNum": 44,
          "modifiers": "uniform   = 0",
          "type": "int",
          "name": "_CheckAlbedo",
          "code": "uniform int _CheckAlbedo = 0; // if 0, pass through untouched color"
        },
        {
          "comment": "",
          "lineNum": 45,
          "assignment": "= half4(0.0, 0.0, 0.0, 0.0);",
          "modifiers": "uniform",
          "type": "half4",
          "name": "_AlbedoCompareColor",
          "code": "uniform half4 _AlbedoCompareColor = half4(0.0, 0.0, 0.0, 0.0);"
        },
        {
          "comment": "",
          "lineNum": 46,
          "modifiers": "uniform   = 0.0",
          "type": "half",
          "name": "_AlbedoMinLuminance",
          "code": "uniform half _AlbedoMinLuminance = 0.0;"
        },
        {
          "comment": "",
          "lineNum": 47,
          "modifiers": "uniform   = 1.0",
          "type": "half",
          "name": "_AlbedoMaxLuminance",
          "code": "uniform half _AlbedoMaxLuminance = 1.0;"
        },
        {
          "comment": "",
          "lineNum": 48,
          "modifiers": "uniform   = 0.1",
          "type": "half",
          "name": "_AlbedoHueTolerance",
          "code": "uniform half _AlbedoHueTolerance = 0.1;"
        },
        {
          "comment": "",
          "lineNum": 49,
          "modifiers": "uniform   = 0.1",
          "type": "half",
          "name": "_AlbedoSaturationTolerance",
          "code": "uniform half _AlbedoSaturationTolerance = 0.1;"
        },
        {
          "comment": "",
          "lineNum": 51,
          "modifiers": "uniform",
          "type": "sampler2D",
          "name": "unity_EditorViz_Texture;",
          "code": "uniform sampler2D unity_EditorViz_Texture;"
        },
        {
          "comment": "",
          "lineNum": 52,
          "modifiers": "uniform",
          "type": "half4",
          "name": "unity_EditorViz_Texture_ST;",
          "code": "uniform half4 unity_EditorViz_Texture_ST;"
        },
        {
          "comment": "",
          "lineNum": 53,
          "modifiers": "uniform",
          "type": "int",
          "name": "unity_EditorViz_UVIndex;",
          "code": "uniform int unity_EditorViz_UVIndex;"
        },
        {
          "comment": "",
          "lineNum": 54,
          "modifiers": "uniform",
          "type": "half4",
          "name": "unity_EditorViz_Decode_HDR;",
          "code": "uniform half4 unity_EditorViz_Decode_HDR;"
        },
        {
          "comment": "",
          "lineNum": 55,
          "modifiers": "uniform",
          "type": "bool",
          "name": "unity_EditorViz_ConvertToLinearSpace;",
          "code": "uniform bool unity_EditorViz_ConvertToLinearSpace;"
        },
        {
          "comment": "",
          "lineNum": 56,
          "modifiers": "uniform",
          "type": "half4",
          "name": "unity_EditorViz_ColorMul;",
          "code": "uniform half4 unity_EditorViz_ColorMul;"
        },
        {
          "comment": "",
          "lineNum": 57,
          "modifiers": "uniform",
          "type": "half4",
          "name": "unity_EditorViz_ColorAdd;",
          "code": "uniform half4 unity_EditorViz_ColorAdd;"
        },
        {
          "comment": "",
          "lineNum": 58,
          "modifiers": "uniform",
          "type": "sampler2D",
          "name": "unity_EditorViz_LightTexture;",
          "code": "uniform sampler2D unity_EditorViz_LightTexture;"
        },
        {
          "comment": "",
          "lineNum": 59,
          "modifiers": "uniform",
          "type": "sampler2D",
          "name": "unity_EditorViz_LightTextureB;",
          "code": "uniform sampler2D unity_EditorViz_LightTextureB;"
        },
        {
          "comment": "",
          "lineNum": 63,
          "modifiers": "uniform",
          "type": "float4x4",
          "name": "unity_EditorViz_WorldToLight;",
          "code": "uniform float4x4 unity_EditorViz_WorldToLight;"
        },
        {
          "comment": "",
          "lineNum": 65,
          "assignment": "= half4(1.0f, 0.0f, 0.0f, 0.0f);",
          "modifiers": "uniform",
          "type": "half4",
          "name": "unity_MaterialValidateLowColor",
          "code": "uniform half4 unity_MaterialValidateLowColor = half4(1.0f, 0.0f, 0.0f, 0.0f);"
        },
        {
          "comment": "",
          "lineNum": 66,
          "assignment": "= half4(0.0f, 0.0f, 1.0f, 0.0f);",
          "modifiers": "uniform",
          "type": "half4",
          "name": "unity_MaterialValidateHighColor",
          "code": "uniform half4 unity_MaterialValidateHighColor = half4(0.0f, 0.0f, 1.0f, 0.0f);"
        },
        {
          "comment": "",
          "lineNum": 67,
          "assignment": "= half4(1.0f, 1.0f, 0.0f, 0.0f);",
          "modifiers": "uniform",
          "type": "half4",
          "name": "unity_MaterialValidatePureMetalColor",
          "code": "uniform half4 unity_MaterialValidatePureMetalColor = half4(1.0f, 1.0f, 0.0f, 0.0f);"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 70,
          "modifiers": "static const   = 0.02",
          "type": "float",
          "name": "dieletricMin",
          "code": "static const float dieletricMin = 0.02;"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 71,
          "modifiers": "static const   = 0.07",
          "type": "float",
          "name": "dieletricMax",
          "code": "static const float dieletricMax = 0.07;"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 72,
          "modifiers": "static const        = 0.07",
          "type": "float",
          "name": "gemsMin",
          "code": "static const float gemsMin      = 0.07;"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 73,
          "modifiers": "static const        = 0.22",
          "type": "float",
          "name": "gemsMax",
          "code": "static const float gemsMax      = 0.22;"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 74,
          "modifiers": "static const   = 0.45",
          "type": "float",
          "name": "conductorMin",
          "code": "static const float conductorMin = 0.45;"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 75,
          "modifiers": "static const   = 1.00",
          "type": "float",
          "name": "conductorMax",
          "code": "static const float conductorMax = 1.00;"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 76,
          "modifiers": "static const      = 0.012",
          "type": "float",
          "name": "albedoMin",
          "code": "static const float albedoMin    = 0.012;"
        },
        {
          "comment": "// Define bounds value in linear RGB for fresnel0 values",
          "lineNum": 77,
          "modifiers": "static const      = 0.9",
          "type": "float",
          "name": "albedoMax",
          "code": "static const float albedoMax    = 0.9;"
        },
        {
          "comment": "",
          "lineNum": 281,
          "modifiers": "",
          "type": "float",
          "name": "unity_OneOverOutputBoost;",
          "code": "float unity_OneOverOutputBoost;"
        },
        {
          "comment": "",
          "lineNum": 282,
          "modifiers": "",
          "type": "float",
          "name": "unity_MaxOutputValue;",
          "code": "float unity_MaxOutputValue;"
        },
        {
          "comment": "",
          "lineNum": 283,
          "modifiers": "",
          "type": "float",
          "name": "unity_UseLinearSpace;",
          "code": "float unity_UseLinearSpace;"
        }
      ]
    },
    {
      "file": "UnityPBSLighting.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_PBS_LIGHTING_INCLUDED"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------\n// Default BRDF to use:\n    // still add safe net for low shader models, otherwise we might end up with shaders failing to compile",
          "lineNum": 15,
          "code": "        #define UNITY_BRDF_PBS BRDF3_Unity_PBS"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------\n// Default BRDF to use:\n    // still add safe net for low shader models, otherwise we might end up with shaders failing to compile",
          "lineNum": 17,
          "code": "        #define UNITY_BRDF_PBS BRDF3_Unity_PBS"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------\n// Default BRDF to use:\n    // still add safe net for low shader models, otherwise we might end up with shaders failing to compile",
          "lineNum": 19,
          "code": "        #define UNITY_BRDF_PBS BRDF2_Unity_PBS"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------\n// Default BRDF to use:\n    // still add safe net for low shader models, otherwise we might end up with shaders failing to compile",
          "lineNum": 21,
          "code": "        #define UNITY_BRDF_PBS BRDF1_Unity_PBS"
        },
        {
          "comment": "",
          "lineNum": 32,
          "code": "    #define UNITY_BRDF_GI BRDF_Unity_Indirect"
        },
        {
          "comment": "",
          "lineNum": 40,
          "code": "#define UNITY_GLOSSY_ENV_FROM_SURFACE(x, s, data)               \\\n    Unity_GlossyEnvironmentData g;                              \\\n    g.roughness /* perceptualRoughness */   = SmoothnessToPerceptualRoughness(s.Smoothness); \\\n    g.reflUVW = reflect(-data.worldViewDir, s.Normal);  \\\n"
        },
        {
          "comment": "",
          "lineNum": 47,
          "code": "    #define UNITY_GI(x, s, data) x = UnityGlobalIllumination (data, s.Occlusion, s.Normal);"
        },
        {
          "comment": "",
          "lineNum": 49,
          "code": "    #define UNITY_GI(x, s, data)                                \\\n        UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);              \\\n        x = UnityGlobalIllumination (data, s.Occlusion, s.Normal, g);"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 35,
          "modifiers": "inline",
          "parameters": "half3 baseColor, half3 specColor, half oneMinusReflectivity, half smoothness, half3 normal, half3 viewDir, half occlusion, UnityGI gi",
          "type": "half3",
          "name": "BRDF_Unity_Indirect",
          "code": "inline half3 BRDF_Unity_Indirect (half3 baseColor, half3 specColor, half oneMinusReflectivity, half smoothness, half3 normal, half3 viewDir, half occlusion, UnityGI gi)\n{\n    return half3(0,0,0);\n}"
        },
        {
          "comment": "",
          "lineNum": 73,
          "modifiers": "inline",
          "parameters": "SurfaceOutputStandard s, float3 viewDir, UnityGI gi",
          "type": "half4",
          "name": "LightingStandard",
          "code": "inline half4 LightingStandard (SurfaceOutputStandard s, float3 viewDir, UnityGI gi)\n{\n    s.Normal = normalize(s.Normal);\n\n    half oneMinusReflectivity;\n    half3 specColor;\n    s.Albedo = DiffuseAndSpecularFromMetallic (s.Albedo, s.Metallic, /*out*/ specColor, /*out*/ oneMinusReflectivity);\n\n    // shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)\n    // this is necessary to handle transparency in physically correct way - only diffuse component gets affected by alpha\n    half outputAlpha;\n    s.Albedo = PreMultiplyAlpha (s.Albedo, s.Alpha, oneMinusReflectivity, /*out*/ outputAlpha);\n\n    half4 c = UNITY_BRDF_PBS (s.Albedo, specColor, oneMinusReflectivity, s.Smoothness, s.Normal, viewDir, gi.light, gi.indirect);\n    c.a = outputAlpha;\n    return c;\n}"
        },
        {
          "comment": "",
          "lineNum": 91,
          "modifiers": "inline",
          "parameters": "SurfaceOutputStandard s, float3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2",
          "type": "half4",
          "name": "LightingStandard_Deferred",
          "code": "inline half4 LightingStandard_Deferred (SurfaceOutputStandard s, float3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2)\n{\n    half oneMinusReflectivity;\n    half3 specColor;\n    s.Albedo = DiffuseAndSpecularFromMetallic (s.Albedo, s.Metallic, /*out*/ specColor, /*out*/ oneMinusReflectivity);\n\n    half4 c = UNITY_BRDF_PBS (s.Albedo, specColor, oneMinusReflectivity, s.Smoothness, s.Normal, viewDir, gi.light, gi.indirect);\n\n    UnityStandardData data;\n    data.diffuseColor   = s.Albedo;\n    data.occlusion      = s.Occlusion;\n    data.specularColor  = specColor;\n    data.smoothness     = s.Smoothness;\n    data.normalWorld    = s.Normal;\n\n    UnityStandardDataToGbuffer(data, outGBuffer0, outGBuffer1, outGBuffer2);\n\n    half4 emission = half4(s.Emission + c.rgb, 1);\n    return emission;\n}"
        },
        {
          "comment": "",
          "lineNum": 112,
          "modifiers": "inline",
          "parameters": "SurfaceOutputStandard s,    UnityGIInput data,    inout UnityGI gi",
          "type": "void",
          "name": "LightingStandard_GI",
          "code": "inline void LightingStandard_GI (\n    SurfaceOutputStandard s,\n    UnityGIInput data,\n    inout UnityGI gi)\n{\n#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS\n    gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);\n#else\n    Unity_GlossyEnvironmentData g = UnityGlossyEnvironmentSetup(s.Smoothness, data.worldViewDir, s.Normal, lerp(unity_ColorSpaceDielectricSpec.rgb, s.Albedo, s.Metallic));\n    gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 139,
          "modifiers": "inline",
          "parameters": "SurfaceOutputStandardSpecular s, float3 viewDir, UnityGI gi",
          "type": "half4",
          "name": "LightingStandardSpecular",
          "code": "inline half4 LightingStandardSpecular (SurfaceOutputStandardSpecular s, float3 viewDir, UnityGI gi)\n{\n    s.Normal = normalize(s.Normal);\n\n    // energy conservation\n    half oneMinusReflectivity;\n    s.Albedo = EnergyConservationBetweenDiffuseAndSpecular (s.Albedo, s.Specular, /*out*/ oneMinusReflectivity);\n\n    // shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)\n    // this is necessary to handle transparency in physically correct way - only diffuse component gets affected by alpha\n    half outputAlpha;\n    s.Albedo = PreMultiplyAlpha (s.Albedo, s.Alpha, oneMinusReflectivity, /*out*/ outputAlpha);\n\n    half4 c = UNITY_BRDF_PBS (s.Albedo, s.Specular, oneMinusReflectivity, s.Smoothness, s.Normal, viewDir, gi.light, gi.indirect);\n    c.a = outputAlpha;\n    return c;\n}"
        },
        {
          "comment": "",
          "lineNum": 157,
          "modifiers": "inline",
          "parameters": "SurfaceOutputStandardSpecular s, float3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2",
          "type": "half4",
          "name": "LightingStandardSpecular_Deferred",
          "code": "inline half4 LightingStandardSpecular_Deferred (SurfaceOutputStandardSpecular s, float3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2)\n{\n    // energy conservation\n    half oneMinusReflectivity;\n    s.Albedo = EnergyConservationBetweenDiffuseAndSpecular (s.Albedo, s.Specular, /*out*/ oneMinusReflectivity);\n\n    half4 c = UNITY_BRDF_PBS (s.Albedo, s.Specular, oneMinusReflectivity, s.Smoothness, s.Normal, viewDir, gi.light, gi.indirect);\n\n    UnityStandardData data;\n    data.diffuseColor   = s.Albedo;\n    data.occlusion      = s.Occlusion;\n    data.specularColor  = s.Specular;\n    data.smoothness     = s.Smoothness;\n    data.normalWorld    = s.Normal;\n\n    UnityStandardDataToGbuffer(data, outGBuffer0, outGBuffer1, outGBuffer2);\n\n    half4 emission = half4(s.Emission + c.rgb, 1);\n    return emission;\n}"
        },
        {
          "comment": "",
          "lineNum": 178,
          "modifiers": "inline",
          "parameters": "SurfaceOutputStandardSpecular s,    UnityGIInput data,    inout UnityGI gi",
          "type": "void",
          "name": "LightingStandardSpecular_GI",
          "code": "inline void LightingStandardSpecular_GI (\n    SurfaceOutputStandardSpecular s,\n    UnityGIInput data,\n    inout UnityGI gi)\n{\n#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS\n    gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);\n#else\n    Unity_GlossyEnvironmentData g = UnityGlossyEnvironmentSetup(s.Smoothness, data.worldViewDir, s.Normal, s.Specular);\n    gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);\n#endif\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 60,
          "type": "struct",
          "name": "SurfaceOutputStandard",
          "modifiers": "",
          "code": "struct SurfaceOutputStandard\n{\n    fixed3 Albedo;      // base (diffuse or specular) color\n    float3 Normal;      // tangent space normal, if written\n    half3 Emission;\n    half Metallic;      // 0=non-metal, 1=metal\n    // Smoothness is the user facing name, it should be perceptual smoothness but user should not have to deal with it.\n    // Everywhere in the code you meet smoothness it is perceptual smoothness\n    half Smoothness;    // 0=rough, 1=smooth\n    half Occlusion;     // occlusion (default 1)\n    fixed Alpha;        // alpha for transparencies\n};"
        },
        {
          "comment": "",
          "lineNum": 128,
          "type": "struct",
          "name": "SurfaceOutputStandardSpecular",
          "modifiers": "",
          "code": "struct SurfaceOutputStandardSpecular\n{\n    fixed3 Albedo;      // diffuse color\n    fixed3 Specular;    // specular color\n    float3 Normal;      // tangent space normal, if written\n    half3 Emission;\n    half Smoothness;    // 0=rough, 1=smooth\n    half Occlusion;     // occlusion (default 1)\n    fixed Alpha;        // alpha for transparencies\n};"
        }
      ],
      "variables": []
    },
    {
      "file": "UnityShaderUtilities.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_SHADER_UTILITIES_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 8,
          "modifiers": "",
          "parameters": "float3 worldPos, float ipd",
          "type": "float3",
          "name": "ODSOffset",
          "code": "float3 ODSOffset(float3 worldPos, float ipd)\n{\n    //based on google's omni-directional stereo rendering thread\n    const float EPSILON = 2.4414e-4;\n    float3 worldUp = float3(0.0, 1.0, 0.0);\n    float3 camOffset = worldPos.xyz - _WorldSpaceCameraPos.xyz;\n    float4 direction = float4(camOffset.xyz, dot(camOffset.xyz, camOffset.xyz));\n    direction.w = max(EPSILON, direction.w);\n    direction *= rsqrt(direction.w);\n\n    float3 tangent = cross(direction.xyz, worldUp.xyz);\n    if (dot(tangent, tangent) < EPSILON)\n        return float3(0, 0, 0);\n    tangent = normalize(tangent);\n\n    float directionMinusIPD = max(EPSILON, direction.w*direction.w - ipd*ipd);\n    float a = ipd * ipd / direction.w;\n    float b = ipd / direction.w * sqrt(directionMinusIPD);\n    float3 offset = -a*direction + b*tangent;\n    return offset;\n}"
        },
        {
          "comment": "",
          "lineNum": 30,
          "modifiers": "inline",
          "parameters": "float3 inPos",
          "type": "float4",
          "name": "UnityObjectToClipPosODS",
          "code": "inline float4 UnityObjectToClipPosODS(float3 inPos)\n{\n    float4 clipPos;\n    float3 posWorld = mul(unity_ObjectToWorld, float4(inPos, 1.0)).xyz;\n#if defined(STEREO_CUBEMAP_RENDER_ON)\n    float3 offset = ODSOffset(posWorld, unity_HalfStereoSeparation.x);\n    clipPos = mul(UNITY_MATRIX_VP, float4(posWorld + offset, 1.0));\n#else\n    clipPos = mul(UNITY_MATRIX_VP, float4(posWorld, 1.0));\n#endif\n    return clipPos;\n}"
        },
        {
          "comment": "// Tranforms position from object to homogenous space",
          "lineNum": 44,
          "modifiers": "inline",
          "parameters": "in float3 pos",
          "type": "float4",
          "name": "UnityObjectToClipPos",
          "code": "inline float4 UnityObjectToClipPos(in float3 pos)\n{\n#if defined(STEREO_CUBEMAP_RENDER_ON)\n    return UnityObjectToClipPosODS(pos);\n#else\n    // More efficient than computing M*VP matrix product\n    return mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(pos, 1.0)));\n#endif\n}"
        },
        {
          "comment": "// Tranforms position from object to homogenous space\n    // More efficient than computing M*VP matrix product",
          "lineNum": 53,
          "modifiers": "inline",
          "parameters": "float4 pos",
          "type": "float4",
          "name": "UnityObjectToClipPos",
          "code": "inline float4 UnityObjectToClipPos(float4 pos) // overload for float4; avoids \"implicit truncation\" warning for existing shaders\n{\n    return UnityObjectToClipPos(pos.xyz);\n}"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnityShaderVariables.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_SHADER_VARIABLES_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 7,
          "code": "#define USING_DIRECTIONAL_LIGHT"
        },
        {
          "comment": "",
          "lineNum": 11,
          "code": "#define USING_STEREO_MATRICES"
        },
        {
          "comment": "",
          "lineNum": 15,
          "code": "    #define glstate_matrix_projection unity_StereoMatrixP[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 16,
          "code": "    #define unity_MatrixV unity_StereoMatrixV[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 17,
          "code": "    #define unity_MatrixInvV unity_StereoMatrixInvV[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 18,
          "code": "    #define unity_MatrixVP unity_StereoMatrixVP[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 20,
          "code": "    #define unity_CameraProjection unity_StereoCameraProjection[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 21,
          "code": "    #define unity_CameraInvProjection unity_StereoCameraInvProjection[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 22,
          "code": "    #define unity_WorldToCamera unity_StereoWorldToCamera[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 23,
          "code": "    #define unity_CameraToWorld unity_StereoCameraToWorld[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 24,
          "code": "    #define _WorldSpaceCameraPos unity_StereoWorldSpaceCameraPos[unity_StereoEyeIndex]"
        },
        {
          "comment": "",
          "lineNum": 27,
          "code": "#define UNITY_MATRIX_P glstate_matrix_projection"
        },
        {
          "comment": "",
          "lineNum": 28,
          "code": "#define UNITY_MATRIX_V unity_MatrixV"
        },
        {
          "comment": "",
          "lineNum": 29,
          "code": "#define UNITY_MATRIX_I_V unity_MatrixInvV"
        },
        {
          "comment": "",
          "lineNum": 30,
          "code": "#define UNITY_MATRIX_VP unity_MatrixVP"
        },
        {
          "comment": "",
          "lineNum": 31,
          "code": "#define UNITY_MATRIX_M unity_ObjectToWorld"
        },
        {
          "comment": "",
          "lineNum": 33,
          "code": "#define UNITY_LIGHTMODEL_AMBIENT (glstate_lightmodel_ambient * 2)"
        },
        {
          "comment": "",
          "lineNum": 196,
          "code": "    #define unity_StereoEyeIndex UNITY_VIEWID"
        },
        {
          "comment": "// UNITY_LIGHT_PROBE_PROXY_VOLUME is used as a shader keyword coming from tier settings and may be also disabled with nolppv pragma.\n// We need to convert it to 0/1 and doing a second check for safety.\n    // Requires quite modern graphics support (3D float textures with filtering)\n    // Note: Keep this in synch with the list from LightProbeProxyVolume::HasHardwareSupport && SurfaceCompiler::IsLPPVAvailableForAnyTargetPlatform",
          "lineNum": 295,
          "code": "        #define UNITY_LIGHT_PROBE_PROXY_VOLUME 1"
        },
        {
          "comment": "// UNITY_LIGHT_PROBE_PROXY_VOLUME is used as a shader keyword coming from tier settings and may be also disabled with nolppv pragma.\n// We need to convert it to 0/1 and doing a second check for safety.\n    // Requires quite modern graphics support (3D float textures with filtering)\n    // Note: Keep this in synch with the list from LightProbeProxyVolume::HasHardwareSupport && SurfaceCompiler::IsLPPVAvailableForAnyTargetPlatform",
          "lineNum": 297,
          "code": "        #define UNITY_LIGHT_PROBE_PROXY_VOLUME 0"
        },
        {
          "comment": "// UNITY_LIGHT_PROBE_PROXY_VOLUME is used as a shader keyword coming from tier settings and may be also disabled with nolppv pragma.\n// We need to convert it to 0/1 and doing a second check for safety.\n    // Requires quite modern graphics support (3D float textures with filtering)\n    // Note: Keep this in synch with the list from LightProbeProxyVolume::HasHardwareSupport && SurfaceCompiler::IsLPPVAvailableForAnyTargetPlatform",
          "lineNum": 300,
          "code": "    #define UNITY_LIGHT_PROBE_PROXY_VOLUME 0"
        },
        {
          "comment": "// make them macros so that they can be redefined in UnityInstancing.cginc",
          "lineNum": 323,
          "code": "#define UNITY_MATRIX_MVP    unity_MatrixMVP"
        },
        {
          "comment": "// make them macros so that they can be redefined in UnityInstancing.cginc",
          "lineNum": 324,
          "code": "#define UNITY_MATRIX_MV     unity_MatrixMV"
        },
        {
          "comment": "// make them macros so that they can be redefined in UnityInstancing.cginc",
          "lineNum": 325,
          "code": "#define UNITY_MATRIX_T_MV   unity_MatrixTMV"
        },
        {
          "comment": "// make them macros so that they can be redefined in UnityInstancing.cginc",
          "lineNum": 326,
          "code": "#define UNITY_MATRIX_IT_MV  unity_MatrixITMV"
        },
        {
          "comment": "// There used to be fixed function-like texture matrices, defined as UNITY_MATRIX_TEXTUREn. These are gone now; and are just defined to identity.",
          "lineNum": 332,
          "code": "#define UNITY_MATRIX_TEXTURE0 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)"
        },
        {
          "comment": "// There used to be fixed function-like texture matrices, defined as UNITY_MATRIX_TEXTUREn. These are gone now; and are just defined to identity.",
          "lineNum": 333,
          "code": "#define UNITY_MATRIX_TEXTURE1 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)"
        },
        {
          "comment": "// There used to be fixed function-like texture matrices, defined as UNITY_MATRIX_TEXTUREn. These are gone now; and are just defined to identity.",
          "lineNum": 334,
          "code": "#define UNITY_MATRIX_TEXTURE2 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)"
        },
        {
          "comment": "// There used to be fixed function-like texture matrices, defined as UNITY_MATRIX_TEXTUREn. These are gone now; and are just defined to identity.",
          "lineNum": 335,
          "code": "#define UNITY_MATRIX_TEXTURE3 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)"
        }
      ],
      "functions": [],
      "structs": [],
      "variables": [
        {
          "comment": "    // Time (t = time since current level load) values from Unity",
          "lineNum": 40,
          "modifiers": "",
          "type": "float4",
          "name": "_Time;",
          "code": "float4 _Time; // (t/20, t, t*2, t*3)"
        },
        {
          "comment": "    // Time (t = time since current level load) values from Unity",
          "lineNum": 41,
          "modifiers": "",
          "type": "float4",
          "name": "_SinTime;",
          "code": "float4 _SinTime; // sin(t/8), sin(t/4), sin(t/2), sin(t)"
        },
        {
          "comment": "    // Time (t = time since current level load) values from Unity",
          "lineNum": 42,
          "modifiers": "",
          "type": "float4",
          "name": "_CosTime;",
          "code": "float4 _CosTime; // cos(t/8), cos(t/4), cos(t/2), cos(t)"
        },
        {
          "comment": "    // Time (t = time since current level load) values from Unity",
          "lineNum": 43,
          "modifiers": "",
          "type": "float4",
          "name": "unity_DeltaTime;",
          "code": "float4 unity_DeltaTime; // dt, 1/dt, smoothdt, 1/smoothdt"
        },
        {
          "comment": "",
          "lineNum": 46,
          "modifiers": "",
          "type": "float3",
          "name": "_WorldSpaceCameraPos;",
          "code": "float3 _WorldSpaceCameraPos;"
        },
        {
          "comment": "    // x = 1 or -1 (-1 if projection is flipped)\n    // y = near plane\n    // z = far plane\n    // w = 1/far plane",
          "lineNum": 53,
          "modifiers": "",
          "type": "float4",
          "name": "_ProjectionParams;",
          "code": "float4 _ProjectionParams;"
        },
        {
          "comment": "    // x = width\n    // y = height\n    // z = 1 + 1.0/width\n    // w = 1 + 1.0/height",
          "lineNum": 59,
          "modifiers": "",
          "type": "float4",
          "name": "_ScreenParams;",
          "code": "float4 _ScreenParams;"
        },
        {
          "comment": "    // Values used to linearize the Z buffer (http://www.humus.name/temp/Linearize%20depth.txt)\n    // x = 1-far/near\n    // y = far/near\n    // z = x/far\n    // w = y/far\n    // or in case of a reversed depth buffer (UNITY_REVERSED_Z is 1)\n    // x = -1+far/near\n    // y = 1\n    // z = x/far\n    // w = 1/far",
          "lineNum": 71,
          "modifiers": "",
          "type": "float4",
          "name": "_ZBufferParams;",
          "code": "float4 _ZBufferParams;"
        },
        {
          "comment": "    // x = orthographic camera's width\n    // y = orthographic camera's height\n    // z = unused\n    // w = 1.0 if camera is ortho, 0.0 if perspective",
          "lineNum": 77,
          "modifiers": "",
          "type": "float4",
          "name": "unity_OrthoParams;",
          "code": "float4 unity_OrthoParams;"
        },
        {
          "comment": "    // x = orthographic camera's width\n    // y = orthographic camera's height\n    // z = unused\n    // w = 1.0 if camera is ortho, 0.0 if perspective\n    //x-component is the half stereo separation value, which a positive for right eye and negative for left eye. The y,z,w components are unused.",
          "lineNum": 80,
          "modifiers": "",
          "type": "float4",
          "name": "unity_HalfStereoSeparation;",
          "code": "float4 unity_HalfStereoSeparation;"
        },
        {
          "comment": "",
          "lineNum": 86,
          "modifiers": "",
          "type": "float4",
          "name": "unity_CameraWorldClipPlanes[6];",
          "code": "float4 unity_CameraWorldClipPlanes[6];"
        },
        {
          "comment": "    // Projection matrices of the camera. Note that this might be different from projection matrix\n    // that is set right now, e.g. while rendering shadows the matrices below are still the projection\n    // of original camera.",
          "lineNum": 92,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_CameraProjection;",
          "code": "float4x4 unity_CameraProjection;"
        },
        {
          "comment": "    // Projection matrices of the camera. Note that this might be different from projection matrix\n    // that is set right now, e.g. while rendering shadows the matrices below are still the projection\n    // of original camera.",
          "lineNum": 93,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_CameraInvProjection;",
          "code": "float4x4 unity_CameraInvProjection;"
        },
        {
          "comment": "    // Projection matrices of the camera. Note that this might be different from projection matrix\n    // that is set right now, e.g. while rendering shadows the matrices below are still the projection\n    // of original camera.",
          "lineNum": 94,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_WorldToCamera;",
          "code": "float4x4 unity_WorldToCamera;"
        },
        {
          "comment": "    // Projection matrices of the camera. Note that this might be different from projection matrix\n    // that is set right now, e.g. while rendering shadows the matrices below are still the projection\n    // of original camera.",
          "lineNum": 95,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_CameraToWorld;",
          "code": "float4x4 unity_CameraToWorld;"
        },
        {
          "comment": "",
          "lineNum": 106,
          "modifiers": "",
          "type": "half4",
          "name": "_WorldSpaceLightPos0;",
          "code": "half4 _WorldSpaceLightPos0;"
        },
        {
          "comment": "",
          "lineNum": 108,
          "modifiers": "",
          "type": "float4",
          "name": "_WorldSpaceLightPos0;",
          "code": "float4 _WorldSpaceLightPos0;"
        },
        {
          "comment": "",
          "lineNum": 111,
          "modifiers": "",
          "type": "float4",
          "name": "_LightPositionRange;",
          "code": "float4 _LightPositionRange; // xyz = pos, w = 1/range"
        },
        {
          "comment": "",
          "lineNum": 112,
          "modifiers": "",
          "type": "float4",
          "name": "_LightProjectionParams;",
          "code": "float4 _LightProjectionParams; // for point light projection: x = zfar / (znear - zfar), y = (znear * zfar) / (znear - zfar), z=shadow bias, w=shadow scale bias"
        },
        {
          "comment": "",
          "lineNum": 114,
          "modifiers": "",
          "type": "float4",
          "name": "unity_4LightPosX0;",
          "code": "float4 unity_4LightPosX0;"
        },
        {
          "comment": "",
          "lineNum": 115,
          "modifiers": "",
          "type": "float4",
          "name": "unity_4LightPosY0;",
          "code": "float4 unity_4LightPosY0;"
        },
        {
          "comment": "",
          "lineNum": 116,
          "modifiers": "",
          "type": "float4",
          "name": "unity_4LightPosZ0;",
          "code": "float4 unity_4LightPosZ0;"
        },
        {
          "comment": "",
          "lineNum": 117,
          "modifiers": "",
          "type": "half4",
          "name": "unity_4LightAtten0;",
          "code": "half4 unity_4LightAtten0;"
        },
        {
          "comment": "",
          "lineNum": 119,
          "modifiers": "",
          "type": "half4",
          "name": "unity_LightColor[8];",
          "code": "half4 unity_LightColor[8];"
        },
        {
          "comment": "",
          "lineNum": 122,
          "modifiers": "",
          "type": "float4",
          "name": "unity_LightPosition[8];",
          "code": "float4 unity_LightPosition[8]; // view-space vertex light positions (position,1), or (-direction,0) for directional lights."
        },
        {
          "comment": "    // x = cos(spotAngle/2) or -1 for non-spot\n    // y = 1/cos(spotAngle/4) or 1 for non-spot\n    // z = quadratic attenuation\n    // w = range*range",
          "lineNum": 127,
          "modifiers": "",
          "type": "half4",
          "name": "unity_LightAtten[8];",
          "code": "half4 unity_LightAtten[8];"
        },
        {
          "comment": "    // x = cos(spotAngle/2) or -1 for non-spot\n    // y = 1/cos(spotAngle/4) or 1 for non-spot\n    // z = quadratic attenuation\n    // w = range*range",
          "lineNum": 128,
          "modifiers": "",
          "type": "float4",
          "name": "unity_SpotDirection[8];",
          "code": "float4 unity_SpotDirection[8]; // view-space spot light directions, or (0,0,1,0) for non-spot"
        },
        {
          "comment": "    // SH lighting environment",
          "lineNum": 131,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SHAr;",
          "code": "half4 unity_SHAr;"
        },
        {
          "comment": "    // SH lighting environment",
          "lineNum": 132,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SHAg;",
          "code": "half4 unity_SHAg;"
        },
        {
          "comment": "    // SH lighting environment",
          "lineNum": 133,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SHAb;",
          "code": "half4 unity_SHAb;"
        },
        {
          "comment": "    // SH lighting environment",
          "lineNum": 134,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SHBr;",
          "code": "half4 unity_SHBr;"
        },
        {
          "comment": "    // SH lighting environment",
          "lineNum": 135,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SHBg;",
          "code": "half4 unity_SHBg;"
        },
        {
          "comment": "    // SH lighting environment",
          "lineNum": 136,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SHBb;",
          "code": "half4 unity_SHBb;"
        },
        {
          "comment": "    // SH lighting environment",
          "lineNum": 137,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SHC;",
          "code": "half4 unity_SHC;"
        },
        {
          "comment": "    // part of Light because it can be used outside of shadow distance",
          "lineNum": 140,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_OcclusionMaskSelector;",
          "code": "fixed4 unity_OcclusionMaskSelector;"
        },
        {
          "comment": "    // part of Light because it can be used outside of shadow distance",
          "lineNum": 141,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_ProbesOcclusion;",
          "code": "fixed4 unity_ProbesOcclusion;"
        },
        {
          "comment": "",
          "lineNum": 145,
          "modifiers": "unity_LightColor1, unity_LightColor2, unity_LightColor3",
          "type": "half3",
          "name": "unity_LightColor0,",
          "code": "half3 unity_LightColor0, unity_LightColor1, unity_LightColor2, unity_LightColor3; // keeping those only for any existing shaders; remove in 4.0"
        },
        {
          "comment": "",
          "lineNum": 152,
          "modifiers": "",
          "type": "float4",
          "name": "unity_ShadowSplitSpheres[4];",
          "code": "float4 unity_ShadowSplitSpheres[4];"
        },
        {
          "comment": "",
          "lineNum": 153,
          "modifiers": "",
          "type": "float4",
          "name": "unity_ShadowSplitSqRadii;",
          "code": "float4 unity_ShadowSplitSqRadii;"
        },
        {
          "comment": "",
          "lineNum": 154,
          "modifiers": "",
          "type": "float4",
          "name": "unity_LightShadowBias;",
          "code": "float4 unity_LightShadowBias;"
        },
        {
          "comment": "",
          "lineNum": 155,
          "modifiers": "",
          "type": "float4",
          "name": "_LightSplitsNear;",
          "code": "float4 _LightSplitsNear;"
        },
        {
          "comment": "",
          "lineNum": 156,
          "modifiers": "",
          "type": "float4",
          "name": "_LightSplitsFar;",
          "code": "float4 _LightSplitsFar;"
        },
        {
          "comment": "",
          "lineNum": 157,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_WorldToShadow[4];",
          "code": "float4x4 unity_WorldToShadow[4];"
        },
        {
          "comment": "",
          "lineNum": 158,
          "modifiers": "",
          "type": "half4",
          "name": "_LightShadowData;",
          "code": "half4 _LightShadowData;"
        },
        {
          "comment": "",
          "lineNum": 159,
          "modifiers": "",
          "type": "float4",
          "name": "unity_ShadowFadeCenterAndType;",
          "code": "float4 unity_ShadowFadeCenterAndType;"
        },
        {
          "comment": "",
          "lineNum": 165,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_ObjectToWorld;",
          "code": "float4x4 unity_ObjectToWorld;"
        },
        {
          "comment": "",
          "lineNum": 166,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_WorldToObject;",
          "code": "float4x4 unity_WorldToObject;"
        },
        {
          "comment": "",
          "lineNum": 167,
          "modifiers": "",
          "type": "float4",
          "name": "unity_LODFade;",
          "code": "float4 unity_LODFade; // x is the fade value ranging within [0,1]. y is x quantized into 16 levels"
        },
        {
          "comment": "",
          "lineNum": 168,
          "modifiers": "",
          "type": "float4",
          "name": "unity_WorldTransformParams;",
          "code": "float4 unity_WorldTransformParams; // w is usually 1.0, or -1.0 for odd-negative scale transforms"
        },
        {
          "comment": "",
          "lineNum": 169,
          "modifiers": "",
          "type": "float4",
          "name": "unity_RenderingLayer;",
          "code": "float4 unity_RenderingLayer;"
        },
        {
          "comment": "",
          "lineNum": 174,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoMatrixP[2];",
          "code": "float4x4 unity_StereoMatrixP[2];"
        },
        {
          "comment": "",
          "lineNum": 175,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoMatrixV[2];",
          "code": "float4x4 unity_StereoMatrixV[2];"
        },
        {
          "comment": "",
          "lineNum": 176,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoMatrixInvV[2];",
          "code": "float4x4 unity_StereoMatrixInvV[2];"
        },
        {
          "comment": "",
          "lineNum": 177,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoMatrixVP[2];",
          "code": "float4x4 unity_StereoMatrixVP[2];"
        },
        {
          "comment": "",
          "lineNum": 179,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoCameraProjection[2];",
          "code": "float4x4 unity_StereoCameraProjection[2];"
        },
        {
          "comment": "",
          "lineNum": 180,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoCameraInvProjection[2];",
          "code": "float4x4 unity_StereoCameraInvProjection[2];"
        },
        {
          "comment": "",
          "lineNum": 181,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoWorldToCamera[2];",
          "code": "float4x4 unity_StereoWorldToCamera[2];"
        },
        {
          "comment": "",
          "lineNum": 182,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_StereoCameraToWorld[2];",
          "code": "float4x4 unity_StereoCameraToWorld[2];"
        },
        {
          "comment": "",
          "lineNum": 184,
          "modifiers": "",
          "type": "float3",
          "name": "unity_StereoWorldSpaceCameraPos[2];",
          "code": "float3 unity_StereoWorldSpaceCameraPos[2];"
        },
        {
          "comment": "",
          "lineNum": 185,
          "modifiers": "",
          "type": "float4",
          "name": "unity_StereoScaleOffset[2];",
          "code": "float4 unity_StereoScaleOffset[2];"
        },
        {
          "comment": "",
          "lineNum": 191,
          "modifiers": "",
          "type": "float4",
          "name": "unity_StereoEyeIndices[2];",
          "code": "float4 unity_StereoEyeIndices[2];"
        },
        {
          "comment": "",
          "lineNum": 199,
          "modifiers": "static",
          "type": "uint",
          "name": "unity_StereoEyeIndex;",
          "code": "static uint unity_StereoEyeIndex;"
        },
        {
          "comment": "",
          "lineNum": 202,
          "modifiers": "",
          "type": "int",
          "name": "unity_StereoEyeIndex;",
          "code": "int unity_StereoEyeIndex;"
        },
        {
          "comment": "",
          "lineNum": 207,
          "modifiers": "",
          "type": "float4x4",
          "name": "glstate_matrix_transpose_modelview0;",
          "code": "float4x4 glstate_matrix_transpose_modelview0;"
        },
        {
          "comment": "",
          "lineNum": 215,
          "modifiers": "",
          "type": "fixed4",
          "name": "glstate_lightmodel_ambient;",
          "code": "fixed4 glstate_lightmodel_ambient;"
        },
        {
          "comment": "",
          "lineNum": 216,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_AmbientSky;",
          "code": "fixed4 unity_AmbientSky;"
        },
        {
          "comment": "",
          "lineNum": 217,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_AmbientEquator;",
          "code": "fixed4 unity_AmbientEquator;"
        },
        {
          "comment": "",
          "lineNum": 218,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_AmbientGround;",
          "code": "fixed4 unity_AmbientGround;"
        },
        {
          "comment": "",
          "lineNum": 219,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_IndirectSpecColor;",
          "code": "fixed4 unity_IndirectSpecColor;"
        },
        {
          "comment": "",
          "lineNum": 222,
          "modifiers": "",
          "type": "float4x4",
          "name": "glstate_matrix_projection;",
          "code": "float4x4 glstate_matrix_projection;"
        },
        {
          "comment": "",
          "lineNum": 223,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_MatrixV;",
          "code": "float4x4 unity_MatrixV;"
        },
        {
          "comment": "",
          "lineNum": 224,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_MatrixInvV;",
          "code": "float4x4 unity_MatrixInvV;"
        },
        {
          "comment": "",
          "lineNum": 225,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_MatrixVP;",
          "code": "float4x4 unity_MatrixVP;"
        },
        {
          "comment": "",
          "lineNum": 226,
          "modifiers": "",
          "type": "int",
          "name": "unity_StereoEyeIndex;",
          "code": "int unity_StereoEyeIndex;"
        },
        {
          "comment": "",
          "lineNum": 229,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_ShadowColor;",
          "code": "fixed4 unity_ShadowColor;"
        },
        {
          "comment": "",
          "lineNum": 236,
          "modifiers": "",
          "type": "fixed4",
          "name": "unity_FogColor;",
          "code": "fixed4 unity_FogColor;"
        },
        {
          "comment": "    // x = density / sqrt(ln(2)), useful for Exp2 mode\n    // y = density / ln(2), useful for Exp mode\n    // z = -1/(end-start), useful for Linear mode\n    // w = end/(end-start), useful for Linear mode",
          "lineNum": 241,
          "modifiers": "",
          "type": "float4",
          "name": "unity_FogParams;",
          "code": "float4 unity_FogParams;"
        },
        {
          "comment": "",
          "lineNum": 261,
          "modifiers": "",
          "type": "float4",
          "name": "unity_LightmapST;",
          "code": "float4 unity_LightmapST;"
        },
        {
          "comment": "",
          "lineNum": 262,
          "modifiers": "",
          "type": "float4",
          "name": "unity_DynamicLightmapST;",
          "code": "float4 unity_DynamicLightmapST;"
        },
        {
          "comment": "",
          "lineNum": 273,
          "modifiers": "",
          "type": "float4",
          "name": "unity_SpecCube0_BoxMax;",
          "code": "float4 unity_SpecCube0_BoxMax;"
        },
        {
          "comment": "",
          "lineNum": 274,
          "modifiers": "",
          "type": "float4",
          "name": "unity_SpecCube0_BoxMin;",
          "code": "float4 unity_SpecCube0_BoxMin;"
        },
        {
          "comment": "",
          "lineNum": 275,
          "modifiers": "",
          "type": "float4",
          "name": "unity_SpecCube0_ProbePosition;",
          "code": "float4 unity_SpecCube0_ProbePosition;"
        },
        {
          "comment": "",
          "lineNum": 276,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SpecCube0_HDR;",
          "code": "half4  unity_SpecCube0_HDR;"
        },
        {
          "comment": "",
          "lineNum": 278,
          "modifiers": "",
          "type": "float4",
          "name": "unity_SpecCube1_BoxMax;",
          "code": "float4 unity_SpecCube1_BoxMax;"
        },
        {
          "comment": "",
          "lineNum": 279,
          "modifiers": "",
          "type": "float4",
          "name": "unity_SpecCube1_BoxMin;",
          "code": "float4 unity_SpecCube1_BoxMin;"
        },
        {
          "comment": "",
          "lineNum": 280,
          "modifiers": "",
          "type": "float4",
          "name": "unity_SpecCube1_ProbePosition;",
          "code": "float4 unity_SpecCube1_ProbePosition;"
        },
        {
          "comment": "",
          "lineNum": 281,
          "modifiers": "",
          "type": "half4",
          "name": "unity_SpecCube1_HDR;",
          "code": "half4  unity_SpecCube1_HDR;"
        },
        {
          "comment": "        // x = Disabled(0)/Enabled(1)\n        // y = Computation are done in global space(0) or local space(1)\n        // z = Texel size on U texture coordinate",
          "lineNum": 310,
          "modifiers": "",
          "type": "float4",
          "name": "unity_ProbeVolumeParams;",
          "code": "float4 unity_ProbeVolumeParams;"
        },
        {
          "comment": "",
          "lineNum": 312,
          "modifiers": "",
          "type": "float4x4",
          "name": "unity_ProbeVolumeWorldToObject;",
          "code": "float4x4 unity_ProbeVolumeWorldToObject;"
        },
        {
          "comment": "",
          "lineNum": 313,
          "modifiers": "",
          "type": "float3",
          "name": "unity_ProbeVolumeSizeInv;",
          "code": "float3 unity_ProbeVolumeSizeInv;"
        },
        {
          "comment": "",
          "lineNum": 314,
          "modifiers": "",
          "type": "float3",
          "name": "unity_ProbeVolumeMin;",
          "code": "float3 unity_ProbeVolumeMin;"
        },
        {
          "comment": "",
          "lineNum": 318,
          "assignment": "= mul(unity_MatrixVP, unity_ObjectToWorld);",
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixMVP",
          "code": "static float4x4 unity_MatrixMVP = mul(unity_MatrixVP, unity_ObjectToWorld);"
        },
        {
          "comment": "",
          "lineNum": 319,
          "assignment": "= mul(unity_MatrixV, unity_ObjectToWorld);",
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixMV",
          "code": "static float4x4 unity_MatrixMV = mul(unity_MatrixV, unity_ObjectToWorld);"
        },
        {
          "comment": "",
          "lineNum": 320,
          "assignment": "= transpose(unity_MatrixMV);",
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixTMV",
          "code": "static float4x4 unity_MatrixTMV = transpose(unity_MatrixMV);"
        },
        {
          "comment": "",
          "lineNum": 321,
          "assignment": "= transpose(mul(unity_WorldToObject, unity_MatrixInvV));",
          "modifiers": "static",
          "type": "float4x4",
          "name": "unity_MatrixITMV",
          "code": "static float4x4 unity_MatrixITMV = transpose(mul(unity_WorldToObject, unity_MatrixInvV));"
        }
      ]
    },
    {
      "file": "UnityShadowLibrary.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_BUILTIN_SHADOW_LIBRARY_INCLUDED"
        },
        {
          "comment": "// Shadowmap helpers.",
          "lineNum": 6,
          "code": "    #define HANDLE_SHADOWS_BLENDING_IN_GI 1"
        },
        {
          "comment": "",
          "lineNum": 9,
          "code": "#define unityShadowCoord float"
        },
        {
          "comment": "",
          "lineNum": 10,
          "code": "#define unityShadowCoord2 float2"
        },
        {
          "comment": "",
          "lineNum": 11,
          "code": "#define unityShadowCoord3 float3"
        },
        {
          "comment": "",
          "lineNum": 12,
          "code": "#define unityShadowCoord4 float4"
        },
        {
          "comment": "",
          "lineNum": 13,
          "code": "#define unityShadowCoord4x4 float4x4"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 15,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias);   half    UnitySampleShadowmap_PCF5x5(float4 coord, float3 receiverPlaneDepthBias);   half    UnitySampleShadowmap_PCF3x3(float4 coord, float3 receiverPlaneDepthBias);   float3  UnityGetReceiverPlaneDepthBias(float3 shadowCoord, float biasbiasMultiply); #if defined (SHADOWS_DEPTH) && defined (SPOT)        #if !defined(SHADOWMAPSAMPLER_DEFINED)        UNITY_DECLARE_SHADOWMAP(_ShadowMapTexture);        #define SHADOWMAPSAMPLER_DEFINED    #endif        #if defined (SHADOWS_SOFT)        float4 _ShadowOffsets[4];        float4 _ShadowMapTexture_TexelSize;        #define SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED    #endifinline fixed UnitySampleShadowmap (float4 shadowCoord",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF7x7",
          "code": "half    UnitySampleShadowmap_PCF7x7(float4 coord, float3 receiverPlaneDepthBias);   // Samples the shadowmap based on PCF filtering (7x7 kernel)\nhalf    UnitySampleShadowmap_PCF5x5(float4 coord, float3 receiverPlaneDepthBias);   // Samples the shadowmap based on PCF filtering (5x5 kernel)\nhalf    UnitySampleShadowmap_PCF3x3(float4 coord, float3 receiverPlaneDepthBias);   // Samples the shadowmap based on PCF filtering (3x3 kernel)\nfloat3  UnityGetReceiverPlaneDepthBias(float3 shadowCoord, float biasbiasMultiply); // Receiver plane depth bias\n\n// ------------------------------------------------------------------\n// Spot light shadows\n// ------------------------------------------------------------------\n\n#if defined (SHADOWS_DEPTH) && defined (SPOT)\n\n    // declare shadowmap\n    #if !defined(SHADOWMAPSAMPLER_DEFINED)\n        UNITY_DECLARE_SHADOWMAP(_ShadowMapTexture);\n        #define SHADOWMAPSAMPLER_DEFINED\n    #endif\n\n    // shadow sampling offsets and texel size\n    #if defined (SHADOWS_SOFT)\n        float4 _ShadowOffsets[4];\n        float4 _ShadowMapTexture_TexelSize;\n        #define SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED\n    #endif\n\ninline fixed UnitySampleShadowmap (float4 shadowCoord)\n{\n    #if defined (SHADOWS_SOFT)\n\n        half shadow = 1;\n\n        // No hardware comparison sampler (ie some mobile + xbox360) : simple 4 tap PCF\n        #if !defined (SHADOWS_NATIVE)\n            float3 coord = shadowCoord.xyz / shadowCoord.w;\n            float4 shadowVals;\n            shadowVals.x = SAMPLE_DEPTH_TEXTURE(_ShadowMapTexture, coord + _ShadowOffsets[0].xy);\n            shadowVals.y = SAMPLE_DEPTH_TEXTURE(_ShadowMapTexture, coord + _ShadowOffsets[1].xy);\n            shadowVals.z = SAMPLE_DEPTH_TEXTURE(_ShadowMapTexture, coord + _ShadowOffsets[2].xy);\n            shadowVals.w = SAMPLE_DEPTH_TEXTURE(_ShadowMapTexture, coord + _ShadowOffsets[3].xy);\n            half4 shadows = (shadowVals < coord.zzzz) ? _LightShadowData.rrrr : 1.0f;\n            shadow = dot(shadows, 0.25f);\n        #else\n            // Mobile with comparison sampler : 4-tap linear comparison filter\n            #if defined(SHADER_API_MOBILE)\n                float3 coord = shadowCoord.xyz / shadowCoord.w;\n                half4 shadows;\n                shadows.x = UNITY_SAMPLE_SHADOW(_ShadowMapTexture, coord + _ShadowOffsets[0]);\n                shadows.y = UNITY_SAMPLE_SHADOW(_ShadowMapTexture, coord + _ShadowOffsets[1]);\n                shadows.z = UNITY_SAMPLE_SHADOW(_ShadowMapTexture, coord + _ShadowOffsets[2]);\n                shadows.w = UNITY_SAMPLE_SHADOW(_ShadowMapTexture, coord + _ShadowOffsets[3]);\n                shadow = dot(shadows, 0.25f);\n            // Everything else\n            #else\n                float3 coord = shadowCoord.xyz / shadowCoord.w;\n                float3 receiverPlaneDepthBias = UnityGetReceiverPlaneDepthBias(coord, 1.0f);\n                shadow = UnitySampleShadowmap_PCF3x3(float4(coord, 1), receiverPlaneDepthBias);\n            #endif\n        shadow = lerp(_LightShadowData.r, 1.0f, shadow);\n        #endif\n    #else\n        // 1-tap shadows\n        #if defined (SHADOWS_NATIVE)\n            half shadow = UNITY_SAMPLE_SHADOW_PROJ(_ShadowMapTexture, shadowCoord);\n            shadow = lerp(_LightShadowData.r, 1.0f, shadow);\n        #else\n            half shadow = SAMPLE_DEPTH_TEXTURE_PROJ(_ShadowMapTexture, UNITY_PROJ_COORD(shadowCoord)) < (shadowCoord.z / shadowCoord.w) ? _LightShadowData.r : 1.0;\n        #endif\n\n    #endif\n\n    return shadow;\n}"
        },
        {
          "comment": "",
          "lineNum": 99,
          "modifiers": "inline",
          "parameters": "float3 vec",
          "type": "float",
          "name": "SampleCubeDistance",
          "code": "    inline float SampleCubeDistance (float3 vec)\n    {\n        return UnityDecodeCubeShadowDepth(UNITY_SAMPLE_TEXCUBE_LOD(_ShadowMapTexture, vec, 0));\n    }"
        },
        {
          "comment": "",
          "lineNum": 106,
          "modifiers": "inline",
          "parameters": "float3 vec",
          "type": "half",
          "name": "UnitySampleShadowmap",
          "code": "inline half UnitySampleShadowmap (float3 vec)\n{\n    #if defined(SHADOWS_CUBE_IN_DEPTH_TEX)\n        float3 absVec = abs(vec);\n        float dominantAxis = max(max(absVec.x, absVec.y), absVec.z); // TODO use max3() instead\n        dominantAxis = max(0.00001, dominantAxis - _LightProjectionParams.z); // shadow bias from point light is apllied here.\n        dominantAxis *= _LightProjectionParams.w; // bias\n        float mydist = -_LightProjectionParams.x + _LightProjectionParams.y/dominantAxis; // project to shadow map clip space [0; 1]\n\n        #if defined(UNITY_REVERSED_Z)\n        mydist = 1.0 - mydist; // depth buffers are reversed! Additionally we can move this to CPP code!\n        #endif\n    #else\n        float mydist = length(vec) * _LightPositionRange.w;\n        mydist *= _LightProjectionParams.w; // bias\n    #endif\n\n    #if defined (SHADOWS_SOFT)\n        float z = 1.0/128.0;\n        float4 shadowVals;\n        // No hardware comparison sampler (ie some mobile + xbox360) : simple 4 tap PCF\n        #if defined (SHADOWS_CUBE_IN_DEPTH_TEX)\n            shadowVals.x = UNITY_SAMPLE_TEXCUBE_SHADOW(_ShadowMapTexture, float4(vec+float3( z, z, z), mydist));\n            shadowVals.y = UNITY_SAMPLE_TEXCUBE_SHADOW(_ShadowMapTexture, float4(vec+float3(-z,-z, z), mydist));\n            shadowVals.z = UNITY_SAMPLE_TEXCUBE_SHADOW(_ShadowMapTexture, float4(vec+float3(-z, z,-z), mydist));\n            shadowVals.w = UNITY_SAMPLE_TEXCUBE_SHADOW(_ShadowMapTexture, float4(vec+float3( z,-z,-z), mydist));\n            half shadow = dot(shadowVals, 0.25);\n            return lerp(_LightShadowData.r, 1.0, shadow);\n        #else\n            shadowVals.x = SampleCubeDistance (vec+float3( z, z, z));\n            shadowVals.y = SampleCubeDistance (vec+float3(-z,-z, z));\n            shadowVals.z = SampleCubeDistance (vec+float3(-z, z,-z));\n            shadowVals.w = SampleCubeDistance (vec+float3( z,-z,-z));\n            half4 shadows = (shadowVals < mydist.xxxx) ? _LightShadowData.rrrr : 1.0f;\n            return dot(shadows, 0.25);\n        #endif\n    #else\n        #if defined (SHADOWS_CUBE_IN_DEPTH_TEX)\n            half shadow = UNITY_SAMPLE_TEXCUBE_SHADOW(_ShadowMapTexture, float4(vec, mydist));\n            return lerp(_LightShadowData.r, 1.0, shadow);\n        #else\n            half shadowVal = UnityDecodeCubeShadowDepth(UNITY_SAMPLE_TEXCUBE(_ShadowMapTexture, vec));\n            half shadow = shadowVal < mydist ? _LightShadowData.r : 1.0;\n            return shadow;\n        #endif\n    #endif\n\n}"
        },
        {
          "comment": "",
          "lineNum": 163,
          "modifiers": "",
          "parameters": "float3 worldPos",
          "type": "half4",
          "name": "LPPV_SampleProbeOcclusion",
          "code": "half4 LPPV_SampleProbeOcclusion(float3 worldPos)\n{\n    const float transformToLocal = unity_ProbeVolumeParams.y;\n    const float texelSizeX = unity_ProbeVolumeParams.z;\n\n    //The SH coefficients textures and probe occlusion are packed into 1 atlas.\n    //-------------------------\n    //| ShR | ShG | ShB | Occ |\n    //-------------------------\n\n    float3 position = (transformToLocal == 1.0f) ? mul(unity_ProbeVolumeWorldToObject, float4(worldPos, 1.0)).xyz : worldPos;\n\n    //Get a tex coord between 0 and 1\n    float3 texCoord = (position - unity_ProbeVolumeMin.xyz) * unity_ProbeVolumeSizeInv.xyz;\n\n    // Sample fourth texture in the atlas\n    // We need to compute proper U coordinate to sample.\n    // Clamp the coordinate otherwize we'll have leaking between ShB coefficients and Probe Occlusion(Occ) info\n    texCoord.x = max(texCoord.x * 0.25f + 0.75f, 0.75f + 0.5f * texelSizeX);\n\n    return UNITY_SAMPLE_TEX3D_SAMPLER(unity_ProbeVolumeSH, unity_ProbeVolumeSH, texCoord);\n}"
        },
        {
          "comment": "// ------------------------------------------------------------------\n// Used by the forward rendering path",
          "lineNum": 190,
          "modifiers": "",
          "parameters": "float2 lightmapUV, float3 worldPos",
          "type": "fixed",
          "name": "UnitySampleBakedOcclusion",
          "code": "fixed UnitySampleBakedOcclusion (float2 lightmapUV, float3 worldPos)\n{\n    #if defined (SHADOWS_SHADOWMASK)\n        #if defined(LIGHTMAP_ON)\n            fixed4 rawOcclusionMask = UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);\n        #else\n            fixed4 rawOcclusionMask = fixed4(1.0, 1.0, 1.0, 1.0);\n            #if UNITY_LIGHT_PROBE_PROXY_VOLUME\n                if (unity_ProbeVolumeParams.x == 1.0)\n                    rawOcclusionMask = LPPV_SampleProbeOcclusion(worldPos);\n                else\n                    rawOcclusionMask = UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);\n            #else\n                rawOcclusionMask = UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);\n            #endif\n        #endif\n        return saturate(dot(rawOcclusionMask, unity_OcclusionMaskSelector));\n\n    #else\n\n        //In forward dynamic objects can only get baked occlusion from LPPV, light probe occlusion is done on the CPU by attenuating the light color.\n        fixed atten = 1.0f;\n        #if defined(UNITY_INSTANCING_ENABLED) && defined(UNITY_USE_SHCOEFFS_ARRAYS)\n            // ...unless we are doing instancing, and the attenuation is packed into SHC array's .w component.\n            atten = unity_SHC.w;\n        #endif\n\n        #if UNITY_LIGHT_PROBE_PROXY_VOLUME && !defined(LIGHTMAP_ON) && !UNITY_STANDARD_SIMPLE\n            fixed4 rawOcclusionMask = atten.xxxx;\n            if (unity_ProbeVolumeParams.x == 1.0)\n                rawOcclusionMask = LPPV_SampleProbeOcclusion(worldPos);\n            return saturate(dot(rawOcclusionMask, unity_OcclusionMaskSelector));\n        #endif\n\n        return atten;\n    #endif\n}"
        },
        {
          "comment": "// ------------------------------------------------------------------\n// Used by the deferred rendering path (in the gbuffer pass)",
          "lineNum": 230,
          "modifiers": "",
          "parameters": "float2 lightmapUV, float3 worldPos",
          "type": "fixed4",
          "name": "UnityGetRawBakedOcclusions",
          "code": "fixed4 UnityGetRawBakedOcclusions(float2 lightmapUV, float3 worldPos)\n{\n    #if defined (SHADOWS_SHADOWMASK)\n        #if defined(LIGHTMAP_ON)\n            return UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);\n        #else\n            half4 probeOcclusion = unity_ProbesOcclusion;\n\n            #if UNITY_LIGHT_PROBE_PROXY_VOLUME\n                if (unity_ProbeVolumeParams.x == 1.0)\n                    probeOcclusion = LPPV_SampleProbeOcclusion(worldPos);\n            #endif\n\n            return probeOcclusion;\n        #endif\n    #else\n        return fixed4(1.0, 1.0, 1.0, 1.0);\n    #endif\n}"
        },
        {
          "comment": "// ------------------------------------------------------------------\n// Used by both the forward and the deferred rendering path",
          "lineNum": 252,
          "modifiers": "",
          "parameters": "half realtimeShadowAttenuation, half bakedShadowAttenuation, half fade",
          "type": "half",
          "name": "UnityMixRealtimeAndBakedShadows",
          "code": "half UnityMixRealtimeAndBakedShadows(half realtimeShadowAttenuation, half bakedShadowAttenuation, half fade)\n{\n    // -- Static objects --\n    // FWD BASE PASS\n    // ShadowMask mode          = LIGHTMAP_ON + SHADOWS_SHADOWMASK + LIGHTMAP_SHADOW_MIXING\n    // Distance shadowmask mode = LIGHTMAP_ON + SHADOWS_SHADOWMASK\n    // Subtractive mode         = LIGHTMAP_ON + LIGHTMAP_SHADOW_MIXING\n    // Pure realtime direct lit = LIGHTMAP_ON\n\n    // FWD ADD PASS\n    // ShadowMask mode          = SHADOWS_SHADOWMASK + LIGHTMAP_SHADOW_MIXING\n    // Distance shadowmask mode = SHADOWS_SHADOWMASK\n    // Pure realtime direct lit = LIGHTMAP_ON\n\n    // DEFERRED LIGHTING PASS\n    // ShadowMask mode          = LIGHTMAP_ON + SHADOWS_SHADOWMASK + LIGHTMAP_SHADOW_MIXING\n    // Distance shadowmask mode = LIGHTMAP_ON + SHADOWS_SHADOWMASK\n    // Pure realtime direct lit = LIGHTMAP_ON\n\n    // -- Dynamic objects --\n    // FWD BASE PASS + FWD ADD ASS\n    // ShadowMask mode          = LIGHTMAP_SHADOW_MIXING\n    // Distance shadowmask mode = N/A\n    // Subtractive mode         = LIGHTMAP_SHADOW_MIXING (only matter for LPPV. Light probes occlusion being done on CPU)\n    // Pure realtime direct lit = N/A\n\n    // DEFERRED LIGHTING PASS\n    // ShadowMask mode          = SHADOWS_SHADOWMASK + LIGHTMAP_SHADOW_MIXING\n    // Distance shadowmask mode = SHADOWS_SHADOWMASK\n    // Pure realtime direct lit = N/A\n\n    #if !defined(SHADOWS_DEPTH) && !defined(SHADOWS_SCREEN) && !defined(SHADOWS_CUBE)\n        #if defined(LIGHTMAP_ON) && defined (LIGHTMAP_SHADOW_MIXING) && !defined (SHADOWS_SHADOWMASK)\n            //In subtractive mode when there is no shadow we kill the light contribution as direct as been baked in the lightmap.\n            return 0.0;\n        #else\n            return bakedShadowAttenuation;\n        #endif\n    #endif\n\n    #if (SHADER_TARGET <= 20) || UNITY_STANDARD_SIMPLE\n        //no fading nor blending on SM 2.0 because of instruction count limit.\n        #if defined(SHADOWS_SHADOWMASK) || defined(LIGHTMAP_SHADOW_MIXING)\n            return min(realtimeShadowAttenuation, bakedShadowAttenuation);\n        #else\n            return realtimeShadowAttenuation;\n        #endif\n    #endif\n\n    #if defined(LIGHTMAP_SHADOW_MIXING)\n        //Subtractive or shadowmask mode\n        realtimeShadowAttenuation = saturate(realtimeShadowAttenuation + fade);\n        return min(realtimeShadowAttenuation, bakedShadowAttenuation);\n    #endif\n\n    //In distance shadowmask or realtime shadow fadeout we lerp toward the baked shadows (bakedShadowAttenuation will be 1 if no baked shadows)\n    return lerp(realtimeShadowAttenuation, bakedShadowAttenuation, fade);\n}"
        },
        {
          "comment": "",
          "lineNum": 315,
          "modifiers": "",
          "parameters": "float3 wpos, float z",
          "type": "float",
          "name": "UnityComputeShadowFadeDistance",
          "code": "float UnityComputeShadowFadeDistance(float3 wpos, float z)\n{\n    float sphereDist = distance(wpos, unity_ShadowFadeCenterAndType.xyz);\n    return lerp(z, sphereDist, unity_ShadowFadeCenterAndType.w);\n}"
        },
        {
          "comment": "// ------------------------------------------------------------------",
          "lineNum": 322,
          "modifiers": "",
          "parameters": "float fadeDist",
          "type": "half",
          "name": "UnityComputeShadowFade",
          "code": "half UnityComputeShadowFade(float fadeDist)\n{\n    return saturate(fadeDist * _LightShadowData.z + _LightShadowData.w);\n}"
        },
        {
          "comment": "",
          "lineNum": 338,
          "modifiers": "",
          "parameters": "float3 shadowCoord, float biasMultiply",
          "type": "float3",
          "name": "UnityGetReceiverPlaneDepthBias",
          "code": "float3 UnityGetReceiverPlaneDepthBias(float3 shadowCoord, float biasMultiply)\n{\n    // Should receiver plane bias be used? This estimates receiver slope using derivatives,\n    // and tries to tilt the PCF kernel along it. However, when doing it in screenspace from the depth texture\n    // (ie all light in deferred and directional light in both forward and deferred), the derivatives are wrong\n    // on edges or intersections of objects, leading to shadow artifacts. Thus it is disabled by default.\n    float3 biasUVZ = 0;\n\n#if defined(UNITY_USE_RECEIVER_PLANE_BIAS) && defined(SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED)\n    float3 dx = ddx(shadowCoord);\n    float3 dy = ddy(shadowCoord);\n\n    biasUVZ.x = dy.y * dx.z - dx.y * dy.z;\n    biasUVZ.y = dx.x * dy.z - dy.x * dx.z;\n    biasUVZ.xy *= biasMultiply / ((dx.x * dy.y) - (dx.y * dy.x));\n\n    // Static depth biasing to make up for incorrect fractional sampling on the shadow map grid.\n    const float UNITY_RECEIVER_PLANE_MIN_FRACTIONAL_ERROR = 0.01f;\n    float fractionalSamplingError = dot(_ShadowMapTexture_TexelSize.xy, abs(biasUVZ.xy));\n    biasUVZ.z = -min(fractionalSamplingError, UNITY_RECEIVER_PLANE_MIN_FRACTIONAL_ERROR);\n    #if defined(UNITY_REVERSED_Z)\n        biasUVZ.z *= -1;\n    #endif\n#endif\n\n    return biasUVZ;\n}"
        },
        {
          "comment": "",
          "lineNum": 370,
          "modifiers": "",
          "parameters": "float2 baseUV, float2 deltaUV, float depth, float3 receiverPlaneDepthBias",
          "type": "float3",
          "name": "UnityCombineShadowcoordComponents",
          "code": "float3 UnityCombineShadowcoordComponents(float2 baseUV, float2 deltaUV, float depth, float3 receiverPlaneDepthBias)\n{\n    float3 uv = float3(baseUV + deltaUV, depth + receiverPlaneDepthBias.z);\n    uv.z += dot(deltaUV, receiverPlaneDepthBias.xy);\n    return uv;\n}"
        },
        {
          "comment": "",
          "lineNum": 390,
          "modifiers": "",
          "parameters": "float triangleHeight",
          "type": "float",
          "name": "_UnityInternalGetAreaAboveFirstTexelUnderAIsocelesRectangleTriangle",
          "code": "float _UnityInternalGetAreaAboveFirstTexelUnderAIsocelesRectangleTriangle(float triangleHeight)\n{\n    return triangleHeight - 0.5;\n}"
        },
        {
          "comment": "",
          "lineNum": 404,
          "modifiers": "",
          "parameters": "float offset, out float4 computedArea, out float4 computedAreaUncut",
          "type": "void",
          "name": "_UnityInternalGetAreaPerTexel_3TexelsWideTriangleFilter",
          "code": "void _UnityInternalGetAreaPerTexel_3TexelsWideTriangleFilter(float offset, out float4 computedArea, out float4 computedAreaUncut)\n{\n    //Compute the exterior areas\n    float offset01SquaredHalved = (offset + 0.5) * (offset + 0.5) * 0.5;\n    computedAreaUncut.x = computedArea.x = offset01SquaredHalved - offset;\n    computedAreaUncut.w = computedArea.w = offset01SquaredHalved;\n\n    //Compute the middle areas\n    //For Y : We find the area in Y of as if the left section of the isoceles triangle would\n    //intersect the axis between Y and Z (ie where offset = 0).\n    computedAreaUncut.y = _UnityInternalGetAreaAboveFirstTexelUnderAIsocelesRectangleTriangle(1.5 - offset);\n    //This area is superior to the one we are looking for if (offset < 0) thus we need to\n    //subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\n    float clampedOffsetLeft = min(offset,0);\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\n\n    //We do the same for the Z but with the right part of the isoceles triangle\n    computedAreaUncut.z = _UnityInternalGetAreaAboveFirstTexelUnderAIsocelesRectangleTriangle(1.5 + offset);\n    float clampedOffsetRight = max(offset,0);\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\n}"
        },
        {
          "comment": "",
          "lineNum": 432,
          "modifiers": "",
          "parameters": "float offset, out float4 computedWeight",
          "type": "void",
          "name": "_UnityInternalGetWeightPerTexel_3TexelsWideTriangleFilter",
          "code": "void _UnityInternalGetWeightPerTexel_3TexelsWideTriangleFilter(float offset, out float4 computedWeight)\n{\n    float4 dummy;\n    _UnityInternalGetAreaPerTexel_3TexelsWideTriangleFilter(offset, computedWeight, dummy);\n    computedWeight *= 0.44444;//0.44 == 1/(the triangle area)\n}"
        },
        {
          "comment": "",
          "lineNum": 446,
          "modifiers": "",
          "parameters": "float offset, out float3 texelsWeightsA, out float3 texelsWeightsB",
          "type": "void",
          "name": "_UnityInternalGetWeightPerTexel_5TexelsWideTriangleFilter",
          "code": "void _UnityInternalGetWeightPerTexel_5TexelsWideTriangleFilter(float offset, out float3 texelsWeightsA, out float3 texelsWeightsB)\n{\n    //See _UnityInternalGetAreaPerTexel_3TexelTriangleFilter for details.\n    float4 computedArea_From3texelTriangle;\n    float4 computedAreaUncut_From3texelTriangle;\n    _UnityInternalGetAreaPerTexel_3TexelsWideTriangleFilter(offset, computedArea_From3texelTriangle, computedAreaUncut_From3texelTriangle);\n\n    //Triangle slop is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\n    //the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\n    //0.16 is 1/(the triangle area)\n    texelsWeightsA.x = 0.16 * (computedArea_From3texelTriangle.x);\n    texelsWeightsA.y = 0.16 * (computedAreaUncut_From3texelTriangle.y);\n    texelsWeightsA.z = 0.16 * (computedArea_From3texelTriangle.y + 1);\n    texelsWeightsB.x = 0.16 * (computedArea_From3texelTriangle.z + 1);\n    texelsWeightsB.y = 0.16 * (computedAreaUncut_From3texelTriangle.z);\n    texelsWeightsB.z = 0.16 * (computedArea_From3texelTriangle.w);\n}"
        },
        {
          "comment": "",
          "lineNum": 471,
          "modifiers": "",
          "parameters": "float offset, out float4 texelsWeightsA, out float4 texelsWeightsB",
          "type": "void",
          "name": "_UnityInternalGetWeightPerTexel_7TexelsWideTriangleFilter",
          "code": "void _UnityInternalGetWeightPerTexel_7TexelsWideTriangleFilter(float offset, out float4 texelsWeightsA, out float4 texelsWeightsB)\n{\n    //See _UnityInternalGetAreaPerTexel_3TexelTriangleFilter for details.\n    float4 computedArea_From3texelTriangle;\n    float4 computedAreaUncut_From3texelTriangle;\n    _UnityInternalGetAreaPerTexel_3TexelsWideTriangleFilter(offset, computedArea_From3texelTriangle, computedAreaUncut_From3texelTriangle);\n\n    //Triangle slop is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\n    //the 7 texel wide triangle can be seen as the 3 texel wide one but shifted up by two unit/texel.\n    //0.081632 is 1/(the triangle area)\n    texelsWeightsA.x = 0.081632 * (computedArea_From3texelTriangle.x);\n    texelsWeightsA.y = 0.081632 * (computedAreaUncut_From3texelTriangle.y);\n    texelsWeightsA.z = 0.081632 * (computedAreaUncut_From3texelTriangle.y + 1);\n    texelsWeightsA.w = 0.081632 * (computedArea_From3texelTriangle.y + 2);\n    texelsWeightsB.x = 0.081632 * (computedArea_From3texelTriangle.z + 2);\n    texelsWeightsB.y = 0.081632 * (computedAreaUncut_From3texelTriangle.z + 1);\n    texelsWeightsB.z = 0.081632 * (computedAreaUncut_From3texelTriangle.z);\n    texelsWeightsB.w = 0.081632 * (computedArea_From3texelTriangle.w);\n}"
        },
        {
          "comment": "",
          "lineNum": 498,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF3x3NoHardwareSupport",
          "code": "half UnitySampleShadowmap_PCF3x3NoHardwareSupport(float4 coord, float3 receiverPlaneDepthBias)\n{\n    half shadow = 1;\n\n#ifdef SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED\n    // when we don't have hardware PCF sampling, then the above 5x5 optimized PCF really does not work.\n    // Fallback to a simple 3x3 sampling with averaged results.\n    float2 base_uv = coord.xy;\n    float2 ts = _ShadowMapTexture_TexelSize.xy;\n    shadow = 0;\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(-ts.x, -ts.y), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(0, -ts.y), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(ts.x, -ts.y), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(-ts.x, 0), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(0, 0), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(ts.x, 0), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(-ts.x, ts.y), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(0, ts.y), coord.z, receiverPlaneDepthBias));\n    shadow += UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(ts.x, ts.y), coord.z, receiverPlaneDepthBias));\n    shadow /= 9.0;\n#endif\n\n    return shadow;\n}"
        },
        {
          "comment": "",
          "lineNum": 526,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF3x3Tent",
          "code": "half UnitySampleShadowmap_PCF3x3Tent(float4 coord, float3 receiverPlaneDepthBias)\n{\n    half shadow = 1;\n\n#ifdef SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED\n\n    #ifndef SHADOWS_NATIVE\n        // when we don't have hardware PCF sampling, fallback to a simple 3x3 sampling with averaged results.\n        return UnitySampleShadowmap_PCF3x3NoHardwareSupport(coord, receiverPlaneDepthBias);\n    #endif\n\n    // tent base is 3x3 base thus covering from 9 to 12 texels, thus we need 4 bilinear PCF fetches\n    float2 tentCenterInTexelSpace = coord.xy * _ShadowMapTexture_TexelSize.zw;\n    float2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\n    float2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\n\n    // find the weight of each texel based\n    float4 texelsWeightsU, texelsWeightsV;\n    _UnityInternalGetWeightPerTexel_3TexelsWideTriangleFilter(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsU);\n    _UnityInternalGetWeightPerTexel_3TexelsWideTriangleFilter(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsV);\n\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\n    float2 fetchesWeightsU = texelsWeightsU.xz + texelsWeightsU.yw;\n    float2 fetchesWeightsV = texelsWeightsV.xz + texelsWeightsV.yw;\n\n    // move the PCF bilinear fetches to respect texels weights\n    float2 fetchesOffsetsU = texelsWeightsU.yw / fetchesWeightsU.xy + float2(-1.5,0.5);\n    float2 fetchesOffsetsV = texelsWeightsV.yw / fetchesWeightsV.xy + float2(-1.5,0.5);\n    fetchesOffsetsU *= _ShadowMapTexture_TexelSize.xx;\n    fetchesOffsetsV *= _ShadowMapTexture_TexelSize.yy;\n\n    // fetch !\n    float2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * _ShadowMapTexture_TexelSize.xy;\n    shadow =  fetchesWeightsU.x * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.x * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n#endif\n\n    return shadow;\n}"
        },
        {
          "comment": "",
          "lineNum": 571,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF5x5Tent",
          "code": "half UnitySampleShadowmap_PCF5x5Tent(float4 coord, float3 receiverPlaneDepthBias)\n{\n    half shadow = 1;\n\n#ifdef SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED\n\n    #ifndef SHADOWS_NATIVE\n        // when we don't have hardware PCF sampling, fallback to a simple 3x3 sampling with averaged results.\n        return UnitySampleShadowmap_PCF3x3NoHardwareSupport(coord, receiverPlaneDepthBias);\n    #endif\n\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\n    float2 tentCenterInTexelSpace = coord.xy * _ShadowMapTexture_TexelSize.zw;\n    float2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\n    float2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\n\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\n    float3 texelsWeightsU_A, texelsWeightsU_B;\n    float3 texelsWeightsV_A, texelsWeightsV_B;\n    _UnityInternalGetWeightPerTexel_5TexelsWideTriangleFilter(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsU_A, texelsWeightsU_B);\n    _UnityInternalGetWeightPerTexel_5TexelsWideTriangleFilter(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsV_A, texelsWeightsV_B);\n\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\n    float3 fetchesWeightsU = float3(texelsWeightsU_A.xz, texelsWeightsU_B.y) + float3(texelsWeightsU_A.y, texelsWeightsU_B.xz);\n    float3 fetchesWeightsV = float3(texelsWeightsV_A.xz, texelsWeightsV_B.y) + float3(texelsWeightsV_A.y, texelsWeightsV_B.xz);\n\n    // move the PCF bilinear fetches to respect texels weights\n    float3 fetchesOffsetsU = float3(texelsWeightsU_A.y, texelsWeightsU_B.xz) / fetchesWeightsU.xyz + float3(-2.5,-0.5,1.5);\n    float3 fetchesOffsetsV = float3(texelsWeightsV_A.y, texelsWeightsV_B.xz) / fetchesWeightsV.xyz + float3(-2.5,-0.5,1.5);\n    fetchesOffsetsU *= _ShadowMapTexture_TexelSize.xxx;\n    fetchesOffsetsV *= _ShadowMapTexture_TexelSize.yyy;\n\n    // fetch !\n    float2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * _ShadowMapTexture_TexelSize.xy;\n    shadow  = fetchesWeightsU.x * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.z * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.z, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.x * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.z * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.z, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.x * fetchesWeightsV.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.z), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.z), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.z * fetchesWeightsV.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.z, fetchesOffsetsV.z), coord.z, receiverPlaneDepthBias));\n#endif\n\n    return shadow;\n}"
        },
        {
          "comment": "",
          "lineNum": 622,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF7x7Tent",
          "code": "half UnitySampleShadowmap_PCF7x7Tent(float4 coord, float3 receiverPlaneDepthBias)\n{\n    half shadow = 1;\n\n#ifdef SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED\n\n    #ifndef SHADOWS_NATIVE\n        // when we don't have hardware PCF sampling, fallback to a simple 3x3 sampling with averaged results.\n        return UnitySampleShadowmap_PCF3x3NoHardwareSupport(coord, receiverPlaneDepthBias);\n    #endif\n\n    // tent base is 7x7 base thus covering from 49 to 64 texels, thus we need 16 bilinear PCF fetches\n    float2 tentCenterInTexelSpace = coord.xy * _ShadowMapTexture_TexelSize.zw;\n    float2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\n    float2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\n\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\n    float4 texelsWeightsU_A, texelsWeightsU_B;\n    float4 texelsWeightsV_A, texelsWeightsV_B;\n    _UnityInternalGetWeightPerTexel_7TexelsWideTriangleFilter(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsU_A, texelsWeightsU_B);\n    _UnityInternalGetWeightPerTexel_7TexelsWideTriangleFilter(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsV_A, texelsWeightsV_B);\n\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\n    float4 fetchesWeightsU = float4(texelsWeightsU_A.xz, texelsWeightsU_B.xz) + float4(texelsWeightsU_A.yw, texelsWeightsU_B.yw);\n    float4 fetchesWeightsV = float4(texelsWeightsV_A.xz, texelsWeightsV_B.xz) + float4(texelsWeightsV_A.yw, texelsWeightsV_B.yw);\n\n    // move the PCF bilinear fetches to respect texels weights\n    float4 fetchesOffsetsU = float4(texelsWeightsU_A.yw, texelsWeightsU_B.yw) / fetchesWeightsU.xyzw + float4(-3.5,-1.5,0.5,2.5);\n    float4 fetchesOffsetsV = float4(texelsWeightsV_A.yw, texelsWeightsV_B.yw) / fetchesWeightsV.xyzw + float4(-3.5,-1.5,0.5,2.5);\n    fetchesOffsetsU *= _ShadowMapTexture_TexelSize.xxxx;\n    fetchesOffsetsV *= _ShadowMapTexture_TexelSize.yyyy;\n\n    // fetch !\n    float2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * _ShadowMapTexture_TexelSize.xy;\n    shadow  = fetchesWeightsU.x * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.z * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.z, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.w * fetchesWeightsV.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.w, fetchesOffsetsV.x), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.x * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.z * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.z, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.w * fetchesWeightsV.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.w, fetchesOffsetsV.y), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.x * fetchesWeightsV.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.z), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.z), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.z * fetchesWeightsV.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.z, fetchesOffsetsV.z), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.w * fetchesWeightsV.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.w, fetchesOffsetsV.z), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.x * fetchesWeightsV.w * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.x, fetchesOffsetsV.w), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.y * fetchesWeightsV.w * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.y, fetchesOffsetsV.w), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.z * fetchesWeightsV.w * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.z, fetchesOffsetsV.w), coord.z, receiverPlaneDepthBias));\n    shadow += fetchesWeightsU.w * fetchesWeightsV.w * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(bilinearFetchOrigin, float2(fetchesOffsetsU.w, fetchesOffsetsV.w), coord.z, receiverPlaneDepthBias));\n#endif\n\n    return shadow;\n}"
        },
        {
          "comment": "",
          "lineNum": 683,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF3x3Gaussian",
          "code": "half UnitySampleShadowmap_PCF3x3Gaussian(float4 coord, float3 receiverPlaneDepthBias)\n{\n    half shadow = 1;\n\n#ifdef SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED\n\n    #ifndef SHADOWS_NATIVE\n        // when we don't have hardware PCF sampling, fallback to a simple 3x3 sampling with averaged results.\n        return UnitySampleShadowmap_PCF3x3NoHardwareSupport(coord, receiverPlaneDepthBias);\n    #endif\n\n    const float2 offset = float2(0.5, 0.5);\n    float2 uv = (coord.xy * _ShadowMapTexture_TexelSize.zw) + offset;\n    float2 base_uv = (floor(uv) - offset) * _ShadowMapTexture_TexelSize.xy;\n    float2 st = frac(uv);\n\n    float2 uw = float2(3 - 2 * st.x, 1 + 2 * st.x);\n    float2 u = float2((2 - st.x) / uw.x - 1, (st.x) / uw.y + 1);\n    u *= _ShadowMapTexture_TexelSize.x;\n\n    float2 vw = float2(3 - 2 * st.y, 1 + 2 * st.y);\n    float2 v = float2((2 - st.y) / vw.x - 1, (st.y) / vw.y + 1);\n    v *= _ShadowMapTexture_TexelSize.y;\n\n    half sum = 0;\n\n    sum += uw[0] * vw[0] * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u[0], v[0]), coord.z, receiverPlaneDepthBias));\n    sum += uw[1] * vw[0] * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u[1], v[0]), coord.z, receiverPlaneDepthBias));\n    sum += uw[0] * vw[1] * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u[0], v[1]), coord.z, receiverPlaneDepthBias));\n    sum += uw[1] * vw[1] * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u[1], v[1]), coord.z, receiverPlaneDepthBias));\n\n    shadow = sum / 16.0f;\n#endif\n\n    return shadow;\n}"
        },
        {
          "comment": "",
          "lineNum": 726,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF5x5Gaussian",
          "code": "half UnitySampleShadowmap_PCF5x5Gaussian(float4 coord, float3 receiverPlaneDepthBias)\n{\n    half shadow = 1;\n\n#ifdef SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED\n\n    #ifndef SHADOWS_NATIVE\n        // when we don't have hardware PCF sampling, fallback to a simple 3x3 sampling with averaged results.\n        return UnitySampleShadowmap_PCF3x3NoHardwareSupport(coord, receiverPlaneDepthBias);\n    #endif\n\n    const float2 offset = float2(0.5, 0.5);\n    float2 uv = (coord.xy * _ShadowMapTexture_TexelSize.zw) + offset;\n    float2 base_uv = (floor(uv) - offset) * _ShadowMapTexture_TexelSize.xy;\n    float2 st = frac(uv);\n\n    float3 uw = float3(4 - 3 * st.x, 7, 1 + 3 * st.x);\n    float3 u = float3((3 - 2 * st.x) / uw.x - 2, (3 + st.x) / uw.y, st.x / uw.z + 2);\n    u *= _ShadowMapTexture_TexelSize.x;\n\n    float3 vw = float3(4 - 3 * st.y, 7, 1 + 3 * st.y);\n    float3 v = float3((3 - 2 * st.y) / vw.x - 2, (3 + st.y) / vw.y, st.y / vw.z + 2);\n    v *= _ShadowMapTexture_TexelSize.y;\n\n    half sum = 0.0f;\n\n    half3 accum = uw * vw.x;\n    sum += accum.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.x, v.x), coord.z, receiverPlaneDepthBias));\n    sum += accum.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.y, v.x), coord.z, receiverPlaneDepthBias));\n    sum += accum.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.z, v.x), coord.z, receiverPlaneDepthBias));\n\n    accum = uw * vw.y;\n    sum += accum.x *  UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.x, v.y), coord.z, receiverPlaneDepthBias));\n    sum += accum.y *  UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.y, v.y), coord.z, receiverPlaneDepthBias));\n    sum += accum.z *  UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.z, v.y), coord.z, receiverPlaneDepthBias));\n\n    accum = uw * vw.z;\n    sum += accum.x * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.x, v.z), coord.z, receiverPlaneDepthBias));\n    sum += accum.y * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.y, v.z), coord.z, receiverPlaneDepthBias));\n    sum += accum.z * UNITY_SAMPLE_SHADOW(_ShadowMapTexture, UnityCombineShadowcoordComponents(base_uv, float2(u.z, v.z), coord.z, receiverPlaneDepthBias));\n    shadow = sum / 144.0f;\n\n#endif\n\n    return shadow;\n}"
        },
        {
          "comment": "",
          "lineNum": 773,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF3x3",
          "code": "half UnitySampleShadowmap_PCF3x3(float4 coord, float3 receiverPlaneDepthBias)\n{\n    return UnitySampleShadowmap_PCF3x3Tent(coord, receiverPlaneDepthBias);\n}"
        },
        {
          "comment": "",
          "lineNum": 778,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF5x5",
          "code": "half UnitySampleShadowmap_PCF5x5(float4 coord, float3 receiverPlaneDepthBias)\n{\n    return UnitySampleShadowmap_PCF5x5Tent(coord, receiverPlaneDepthBias);\n}"
        },
        {
          "comment": "",
          "lineNum": 783,
          "modifiers": "",
          "parameters": "float4 coord, float3 receiverPlaneDepthBias",
          "type": "half",
          "name": "UnitySampleShadowmap_PCF7x7",
          "code": "half UnitySampleShadowmap_PCF7x7(float4 coord, float3 receiverPlaneDepthBias)\n{\n    return UnitySampleShadowmap_PCF7x7Tent(coord, receiverPlaneDepthBias);\n}"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnitySprites.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_SPRITES_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 15,
          "code": "    #define _RendererColor  UNITY_ACCESS_INSTANCED_PROP(PerDrawSprite, unity_SpriteRendererColorArray)"
        },
        {
          "comment": "",
          "lineNum": 16,
          "code": "    #define _Flip           UNITY_ACCESS_INSTANCED_PROP(PerDrawSprite, unity_SpriteFlipArray)"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 47,
          "modifiers": "inline",
          "parameters": "in float3 pos, in fixed2 flip",
          "type": "float4",
          "name": "UnityFlipSprite",
          "code": "inline float4 UnityFlipSprite(in float3 pos, in fixed2 flip)\n{\n    return float4(pos.xy * flip, pos.z, 1.0);\n}"
        },
        {
          "comment": "",
          "lineNum": 52,
          "modifiers": "",
          "parameters": "appdata_t IN",
          "type": "v2f",
          "name": "SpriteVert",
          "code": "v2f SpriteVert(appdata_t IN)\n{\n    v2f OUT;\n\n    UNITY_SETUP_INSTANCE_ID (IN);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);\n\n    OUT.vertex = UnityFlipSprite(IN.vertex, _Flip);\n    OUT.vertex = UnityObjectToClipPos(OUT.vertex);\n    OUT.texcoord = IN.texcoord;\n    OUT.color = IN.color * _Color * _RendererColor;\n\n    #ifdef PIXELSNAP_ON\n    OUT.vertex = UnityPixelSnap (OUT.vertex);\n    #endif\n\n    return OUT;\n}"
        },
        {
          "comment": "",
          "lineNum": 74,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "fixed4",
          "name": "SampleSpriteTexture",
          "code": "fixed4 SampleSpriteTexture (float2 uv)\n{\n    fixed4 color = tex2D (_MainTex, uv);\n\n#if ETC1_EXTERNAL_ALPHA\n    fixed4 alpha = tex2D (_AlphaTex, uv);\n    color.a = lerp (color.a, alpha.r, _EnableExternalAlpha);\n#endif\n\n    return color;\n}"
        },
        {
          "comment": "",
          "lineNum": 86,
          "modifiers": "",
          "parameters": "v2f IN",
          "type": "fixed4",
          "name": "SpriteFrag",
          "code": "fixed4 SpriteFrag(v2f IN) : SV_Target\n{\n    fixed4 c = SampleSpriteTexture (IN.texcoord) * IN.color;\n    c.rgb *= c.a;\n    return c;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 31,
          "type": "struct",
          "name": "appdata_t",
          "modifiers": "",
          "code": "struct appdata_t\n{\n    float4 vertex   : POSITION;\n    float4 color    : COLOR;\n    float2 texcoord : TEXCOORD0;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 39,
          "type": "struct",
          "name": "v2f",
          "modifiers": "",
          "code": "struct v2f\n{\n    float4 vertex   : SV_POSITION;\n    fixed4 color    : COLOR;\n    float2 texcoord : TEXCOORD0;\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "",
          "type": "fixed4",
          "name": "_RendererColor;",
          "code": "fixed4 _RendererColor;"
        },
        {
          "comment": "",
          "lineNum": 23,
          "modifiers": "",
          "type": "fixed2",
          "name": "_Flip;",
          "code": "fixed2 _Flip;"
        },
        {
          "comment": "",
          "lineNum": 25,
          "modifiers": "",
          "type": "float",
          "name": "_EnableExternalAlpha;",
          "code": "float _EnableExternalAlpha;"
        },
        {
          "comment": "// Material Color.",
          "lineNum": 29,
          "modifiers": "",
          "type": "fixed4",
          "name": "_Color;",
          "code": "fixed4 _Color;"
        },
        {
          "comment": "",
          "lineNum": 71,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 72,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_AlphaTex;",
          "code": "sampler2D _AlphaTex;"
        }
      ]
    },
    {
      "file": "UnityStandardBRDF.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_BRDF_INCLUDED"
        },
        {
          "comment": "// Include deprecated function",
          "lineNum": 462,
          "code": "#define INCLUDE_UNITY_STANDARD_BRDF_DEPRECATED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 12,
          "modifiers": "",
          "parameters": "float perceptualRoughness",
          "type": "float",
          "name": "PerceptualRoughnessToRoughness",
          "code": "float PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}"
        },
        {
          "comment": "",
          "lineNum": 17,
          "modifiers": "",
          "parameters": "half roughness",
          "type": "half",
          "name": "RoughnessToPerceptualRoughness",
          "code": "half RoughnessToPerceptualRoughness(half roughness)\n{\n    return sqrt(roughness);\n}"
        },
        {
          "comment": "// Smoothness is the user facing name\n// it should be perceptualSmoothness but we don't want the user to have to deal with this name",
          "lineNum": 24,
          "modifiers": "",
          "parameters": "half smoothness",
          "type": "half",
          "name": "SmoothnessToRoughness",
          "code": "half SmoothnessToRoughness(half smoothness)\n{\n    return (1 - smoothness) * (1 - smoothness);\n}"
        },
        {
          "comment": "",
          "lineNum": 29,
          "modifiers": "",
          "parameters": "float smoothness",
          "type": "float",
          "name": "SmoothnessToPerceptualRoughness",
          "code": "float SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}"
        },
        {
          "comment": "",
          "lineNum": 36,
          "modifiers": "inline",
          "parameters": "half x",
          "type": "half",
          "name": "Pow4",
          "code": "inline half Pow4 (half x)\n{\n    return x*x*x*x;\n}"
        },
        {
          "comment": "",
          "lineNum": 41,
          "modifiers": "inline",
          "parameters": "float2 x",
          "type": "float2",
          "name": "Pow4",
          "code": "inline float2 Pow4 (float2 x)\n{\n    return x*x*x*x;\n}"
        },
        {
          "comment": "",
          "lineNum": 46,
          "modifiers": "inline",
          "parameters": "half3 x",
          "type": "half3",
          "name": "Pow4",
          "code": "inline half3 Pow4 (half3 x)\n{\n    return x*x*x*x;\n}"
        },
        {
          "comment": "",
          "lineNum": 51,
          "modifiers": "inline",
          "parameters": "half4 x",
          "type": "half4",
          "name": "Pow4",
          "code": "inline half4 Pow4 (half4 x)\n{\n    return x*x*x*x;\n}"
        },
        {
          "comment": "// Pow5 uses the same amount of instructions as generic pow(), but has 2 advantages:\n// 1) better instruction pipelining\n// 2) no need to worry about NaNs",
          "lineNum": 59,
          "modifiers": "inline",
          "parameters": "half x",
          "type": "half",
          "name": "Pow5",
          "code": "inline half Pow5 (half x)\n{\n    return x*x * x*x * x;\n}"
        },
        {
          "comment": "",
          "lineNum": 64,
          "modifiers": "inline",
          "parameters": "half2 x",
          "type": "half2",
          "name": "Pow5",
          "code": "inline half2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}"
        },
        {
          "comment": "",
          "lineNum": 69,
          "modifiers": "inline",
          "parameters": "half3 x",
          "type": "half3",
          "name": "Pow5",
          "code": "inline half3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}"
        },
        {
          "comment": "",
          "lineNum": 74,
          "modifiers": "inline",
          "parameters": "half4 x",
          "type": "half4",
          "name": "Pow5",
          "code": "inline half4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}"
        },
        {
          "comment": "",
          "lineNum": 79,
          "modifiers": "inline",
          "parameters": "half3 F0, half cosA",
          "type": "half3",
          "name": "FresnelTerm",
          "code": "inline half3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1 - cosA);   // ala Schlick interpoliation\n    return F0 + (1-F0) * t;\n}"
        },
        {
          "comment": "",
          "lineNum": 84,
          "modifiers": "inline",
          "parameters": "half3 F0, half3 F90, half cosA",
          "type": "half3",
          "name": "FresnelLerp",
          "code": "inline half3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}"
        },
        {
          "comment": "// approximage Schlick with ^4 instead of ^5",
          "lineNum": 90,
          "modifiers": "inline",
          "parameters": "half3 F0, half3 F90, half cosA",
          "type": "half3",
          "name": "FresnelLerpFast",
          "code": "inline half3 FresnelLerpFast (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow4 (1 - cosA);\n    return lerp (F0, F90, t);\n}"
        },
        {
          "comment": "// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.",
          "lineNum": 97,
          "modifiers": "",
          "parameters": "half NdotV, half NdotL, half LdotH, half perceptualRoughness",
          "type": "half",
          "name": "DisneyDiffuse",
          "code": "half DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1 + (fd90 - 1) * Pow5(1 - NdotL));\n    half viewScatter    = (1 + (fd90 - 1) * Pow5(1 - NdotV));\n\n    return lightScatter * viewScatter;\n}"
        },
        {
          "comment": "// Generic Smith-Schlick visibility term",
          "lineNum": 111,
          "modifiers": "inline",
          "parameters": "half NdotL, half NdotV, half k",
          "type": "half",
          "name": "SmithVisibilityTerm",
          "code": "inline half SmithVisibilityTerm (half NdotL, half NdotV, half k)\n{\n    half gL = NdotL * (1-k) + k;\n    half gV = NdotV * (1-k) + k;\n    return 1.0 / (gL * gV + 1e-5f); // This function is not intended to be running on Mobile,\n                                    // therefore epsilon is smaller than can be represented by half\n}"
        },
        {
          "comment": "// Smith-Schlick derived for Beckmann",
          "lineNum": 120,
          "modifiers": "inline",
          "parameters": "half NdotL, half NdotV, half roughness",
          "type": "half",
          "name": "SmithBeckmannVisibilityTerm",
          "code": "inline half SmithBeckmannVisibilityTerm (half NdotL, half NdotV, half roughness)\n{\n    half c = 0.797884560802865h; // c = sqrt(2 / Pi)\n    half k = roughness * c;\n    return SmithVisibilityTerm (NdotL, NdotV, k) * 0.25f; // * 0.25 is the 1/4 of the visibility term\n}"
        },
        {
          "comment": "// Ref: http://jcgt.org/published/0003/02/03/paper.pdf",
          "lineNum": 128,
          "modifiers": "inline",
          "parameters": "float NdotL, float NdotV, float roughness",
          "type": "float",
          "name": "SmithJointGGXVisibilityTerm",
          "code": "inline float SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n#if 0\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n#else\n    // Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)\n    float a = roughness;\n    float lambdaV = NdotL * (NdotV * (1 - a) + a);\n    float lambdaL = NdotV * (NdotL * (1 - a) + a);\n\n#if defined(SHADER_API_SWITCH)\n    return 0.5f / (lambdaV + lambdaL + 1e-4f); // work-around against hlslcc rounding error\n#else\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);\n#endif\n\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 161,
          "modifiers": "inline",
          "parameters": "float NdotH, float roughness",
          "type": "float",
          "name": "GGXTerm",
          "code": "inline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}"
        },
        {
          "comment": "",
          "lineNum": 169,
          "modifiers": "inline",
          "parameters": "half perceptualRoughness",
          "type": "half",
          "name": "PerceptualRoughnessToSpecPower",
          "code": "inline half PerceptualRoughnessToSpecPower (half perceptualRoughness)\n{\n    half m = PerceptualRoughnessToRoughness(perceptualRoughness);   // m is the true academic roughness.\n    half sq = max(1e-4f, m*m);\n    half n = (2.0 / sq) - 2.0;                          // https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\n    n = max(n, 1e-4f);                                  // prevent possible cases of pow(0,0), which could happen when roughness is 1.0 and NdotH is zero\n    return n;\n}"
        },
        {
          "comment": "// BlinnPhong normalized as normal distribution function (NDF)\n// for use in micro-facet model: spec=D*G*F\n// eq. 19 in https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf",
          "lineNum": 181,
          "modifiers": "inline",
          "parameters": "half NdotH, half n",
          "type": "half",
          "name": "NDFBlinnPhongNormalizedTerm",
          "code": "inline half NDFBlinnPhongNormalizedTerm (half NdotH, half n)\n{\n    // norm = (n+2)/(2*pi)\n    half normTerm = (n + 2.0) * (0.5/UNITY_PI);\n\n    half specTerm = pow (NdotH, n);\n    return specTerm * normTerm;\n}"
        },
        {
          "comment": "// pass this as a constant for optimization",
          "lineNum": 198,
          "modifiers": "",
          "parameters": "float fSpecPow, int nMips",
          "type": "float",
          "name": "GetSpecPowToMip",
          "code": "float GetSpecPowToMip(float fSpecPow, int nMips)\n{\n   // Default curve - Inverse of TB2 curve with adjusted constants\n   float fSmulMaxT = ( exp2(-10.0/sqrt( fSpecPow )) - k0)/k1;\n   return float(nMips-1)*(1.0 - clamp( fSmulMaxT/g_fMaxT, 0.0, 1.0 ));\n}"
        },
        {
          "comment": "",
          "lineNum": 209,
          "modifiers": "inline",
          "parameters": "float3 inVec",
          "type": "float3",
          "name": "Unity_SafeNormalize",
          "code": "inline float3 Unity_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}"
        },
        {
          "comment": "// Main Physically Based BRDF\n// Derived from Disney work and based on Torrance-Sparrow micro-facet model\n//\n//   BRDF = kD / pi + kS * (D * V * F) / 4\n//   I = BRDF * NdotL\n//\n// * NDF (depending on UNITY_BRDF_GGX):\n//  a) Normalized BlinnPhong\n//  b) GGX\n// * Smith for Visiblity term\n// * Schlick approximation for Fresnel",
          "lineNum": 233,
          "modifiers": "",
          "parameters": "half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness,    float3 normal, float3 viewDir,    UnityLight light, UnityIndirect gi",
          "type": "half4",
          "name": "BRDF1_Unity_PBS",
          "code": "half4 BRDF1_Unity_PBS (half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    UnityLight light, UnityIndirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = Unity_SafeNormalize (float3(light.dir) + viewDir);\n\n// NdotV should not be negative for visible pixels, but it can happen due to perspective projection and normal mapping\n// In this case normal should be modified to become valid (i.e facing camera) and not cause weird artifacts.\n// but this operation adds few ALU and users may not want it. Alternative is to simply take the abs of NdotV (less correct but works too).\n// Following define allow to control this. Set it to 0 if ALU is critical on your platform.\n// This correction is interesting for GGX with SmithJoint visibility function because artifacts are more visible in this case due to highlight edge of rough surface\n// Edit: Disable this code by default for now as it is not compatible with two sided lighting used in SpeedTree.\n#define UNITY_HANDLE_CORRECTLY_NEGATIVE_NDOTV 0\n\n#if UNITY_HANDLE_CORRECTLY_NEGATIVE_NDOTV\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    // A re-normalization should be applied here but as the shift is small we don't do it to save ALU.\n    //normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n#else\n    half nv = abs(dot(normal, viewDir));    // This abs allow to limit artifact\n#endif\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\n\n    // Specular term\n    // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!\n    // BUT 1) that will make shader look significantly darker than Legacy ones\n    // and 2) on engine side \"Non-important\" lights have to be divided by Pi too in cases when they are injected into ambient SH\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n#if UNITY_BRDF_GGX\n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n#else\n    // Legacy\n    half V = SmithBeckmannVisibilityTerm (nl, nv, roughness);\n    half D = NDFBlinnPhongNormalizedTerm (nh, PerceptualRoughnessToSpecPower(perceptualRoughness));\n#endif\n\n    float specularTerm = V*D * UNITY_PI; // Torrance-Sparrow model, Fresnel is applied later\n\n#   ifdef UNITY_COLORSPACE_GAMMA\n        specularTerm = sqrt(max(1e-4h, specularTerm));\n#   endif\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0, specularTerm * nl);\n#if defined(_SPECULARHIGHLIGHTS_OFF)\n    specularTerm = 0.0;\n#endif\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n#   ifdef UNITY_COLORSPACE_GAMMA\n        surfaceReduction = 1.0-0.28*roughness*perceptualRoughness;      // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\n#   else\n        surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n#   endif\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    specularTerm *= any(specColor) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1-oneMinusReflectivity));\n    half3 color =   diffColor * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, grazingTerm, nv);\n\n    return half4(color, 1);\n}"
        },
        {
          "comment": "// Based on Minimalist CookTorrance BRDF\n// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255\n//\n// * NDF (depending on UNITY_BRDF_GGX):\n//  a) BlinnPhong\n//  b) [Modified] GGX\n// * Modified Kelemen and Szirmay-​Kalos for Visibility term\n// * Fresnel approximated with 1/LdotH",
          "lineNum": 324,
          "modifiers": "",
          "parameters": "half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness,    float3 normal, float3 viewDir,    UnityLight light, UnityIndirect gi",
          "type": "half4",
          "name": "BRDF2_Unity_PBS",
          "code": "half4 BRDF2_Unity_PBS (half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    UnityLight light, UnityIndirect gi)\n{\n    float3 halfDir = Unity_SafeNormalize (float3(light.dir) + viewDir);\n\n    half nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n    half nv = saturate(dot(normal, viewDir));\n    float lh = saturate(dot(light.dir, halfDir));\n\n    // Specular term\n    half perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n\n#if UNITY_BRDF_GGX\n\n    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel\n    // See \"Optimizing PBR for Mobile\" from Siggraph 2015 moving mobile graphics course\n    // https://community.arm.com/events/1155\n    half a = roughness;\n    float a2 = a*a;\n\n    float d = nh * nh * (a2 - 1.f) + 1.00001f;\n#ifdef UNITY_COLORSPACE_GAMMA\n    // Tighter approximation for Gamma only rendering mode!\n    // DVF = sqrt(DVF);\n    // DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);\n    float specularTerm = a / (max(0.32f, lh) * (1.5f + roughness) * d);\n#else\n    float specularTerm = a2 / (max(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);\n#endif\n\n    // on mobiles (where half actually means something) denominator have risk of overflow\n    // clamp below was added specifically to \"fix\" that, but dx compiler (we convert bytecode to metal/gles)\n    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))\n#if defined (SHADER_API_MOBILE)\n    specularTerm = specularTerm - 1e-4f;\n#endif\n\n#else\n\n    // Legacy\n    half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);\n    // Modified with approximate Visibility function that takes roughness into account\n    // Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn't take into account roughness\n    // and produced extremely bright specular at grazing angles\n\n    half invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);\n    half invF = lh;\n\n    half specularTerm = ((specularPower + 1) * pow (nh, specularPower)) / (8 * invV * invF + 1e-4h);\n\n#ifdef UNITY_COLORSPACE_GAMMA\n    specularTerm = sqrt(max(1e-4f, specularTerm));\n#endif\n\n#endif\n\n#if defined (SHADER_API_MOBILE)\n    specularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles\n#endif\n#if defined(_SPECULARHIGHLIGHTS_OFF)\n    specularTerm = 0.0;\n#endif\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(realRoughness^2+1)\n\n    // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\n    // 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)\n#ifdef UNITY_COLORSPACE_GAMMA\n    half surfaceReduction = 0.28;\n#else\n    half surfaceReduction = (0.6-0.08*perceptualRoughness);\n#endif\n\n    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;\n\n    half grazingTerm = saturate(smoothness + (1-oneMinusReflectivity));\n    half3 color =   (diffColor + specularTerm * specColor) * light.color * nl\n                    + gi.diffuse * diffColor\n                    + surfaceReduction * gi.specular * FresnelLerpFast (specColor, grazingTerm, nv);\n\n    return half4(color, 1);\n}"
        },
        {
          "comment": "",
          "lineNum": 411,
          "modifiers": "",
          "parameters": "half3 diffColor, half3 specColor, half rlPow4, half smoothness",
          "type": "half3",
          "name": "BRDF3_Direct",
          "code": "half3 BRDF3_Direct(half3 diffColor, half3 specColor, half rlPow4, half smoothness)\n{\n    half LUT_RANGE = 16.0; // must match range in NHxRoughness() function in GeneratedTextures.cpp\n    // Lookup texture to save instructions\n    half specular = tex2D(unity_NHxRoughness, half2(rlPow4, SmoothnessToPerceptualRoughness(smoothness))).r * LUT_RANGE;\n#if defined(_SPECULARHIGHLIGHTS_OFF)\n    specular = 0.0;\n#endif\n\n    return diffColor + specular * specColor;\n}"
        },
        {
          "comment": "",
          "lineNum": 423,
          "modifiers": "",
          "parameters": "half3 diffColor, half3 specColor, UnityIndirect indirect, half grazingTerm, half fresnelTerm",
          "type": "half3",
          "name": "BRDF3_Indirect",
          "code": "half3 BRDF3_Indirect(half3 diffColor, half3 specColor, UnityIndirect indirect, half grazingTerm, half fresnelTerm)\n{\n    half3 c = indirect.diffuse * diffColor;\n    c += indirect.specular * lerp (specColor, grazingTerm, fresnelTerm);\n    return c;\n}"
        },
        {
          "comment": "// Old school, not microfacet based Modified Normalized Blinn-Phong BRDF\n// Implementation uses Lookup texture for performance\n//\n// * Normalized BlinnPhong in RDF form\n// * Implicit Visibility term\n// * No Fresnel term\n//\n// TODO: specular is too weak in Linear rendering mode",
          "lineNum": 438,
          "modifiers": "",
          "parameters": "half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness,    float3 normal, float3 viewDir,    UnityLight light, UnityIndirect gi",
          "type": "half4",
          "name": "BRDF3_Unity_PBS",
          "code": "half4 BRDF3_Unity_PBS (half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    UnityLight light, UnityIndirect gi)\n{\n    float3 reflDir = reflect (viewDir, normal);\n\n    half nl = saturate(dot(normal, light.dir));\n    half nv = saturate(dot(normal, viewDir));\n\n    // Vectorize Pow4 to save instructions\n    half2 rlPow4AndFresnelTerm = Pow4 (float2(dot(reflDir, light.dir), 1-nv));  // use R.L instead of N.H to save couple of instructions\n    half rlPow4 = rlPow4AndFresnelTerm.x; // power exponent must match kHorizontalWarpExp in NHxRoughness() function in GeneratedTextures.cpp\n    half fresnelTerm = rlPow4AndFresnelTerm.y;\n\n    half grazingTerm = saturate(smoothness + (1-oneMinusReflectivity));\n\n    half3 color = BRDF3_Direct(diffColor, specColor, rlPow4, smoothness);\n    color *= light.color * nl;\n    color += BRDF3_Indirect(diffColor, specColor, gi, grazingTerm, fresnelTerm);\n\n    return half4(color, 1);\n}"
        }
      ],
      "structs": [],
      "variables": [
        {
          "comment": "",
          "lineNum": 194,
          "modifiers": "const   = 0.00098, k1 = 0.9921",
          "type": "float",
          "name": "k0",
          "code": "const float k0 = 0.00098, k1 = 0.9921;"
        },
        {
          "comment": "// pass this as a constant for optimization",
          "lineNum": 196,
          "modifiers": "const   = 100000",
          "type": "float",
          "name": "fUserMaxSPow",
          "code": "const float fUserMaxSPow = 100000; // sqrt(12M)"
        },
        {
          "comment": "// pass this as a constant for optimization",
          "lineNum": 197,
          "assignment": "= ( exp2(-10.0/fUserMaxSPow) - k0)/k1;",
          "modifiers": "const",
          "type": "float",
          "name": "g_fMaxT",
          "code": "const float g_fMaxT = ( exp2(-10.0/fUserMaxSPow) - k0)/k1;"
        },
        {
          "comment": "",
          "lineNum": 410,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "unity_NHxRoughness;",
          "code": "sampler2D_float unity_NHxRoughness;"
        }
      ]
    },
    {
      "file": "UnityStandardConfig.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_CONFIG_INCLUDED"
        },
        {
          "comment": "// Define Specular cubemap constants",
          "lineNum": 6,
          "code": "#define UNITY_SPECCUBE_LOD_EXPONENT (1.5)"
        },
        {
          "comment": "// Define Specular cubemap constants",
          "lineNum": 9,
          "code": "#define UNITY_SPECCUBE_LOD_STEPS (6)"
        },
        {
          "comment": "// Energy conservation for Specular workflow is Monochrome. For instance: Red metal will make diffuse Black not Cyan",
          "lineNum": 14,
          "code": "#define UNITY_CONSERVE_ENERGY 1"
        },
        {
          "comment": "// Energy conservation for Specular workflow is Monochrome. For instance: Red metal will make diffuse Black not Cyan",
          "lineNum": 17,
          "code": "#define UNITY_CONSERVE_ENERGY_MONOCHROME 1"
        },
        {
          "comment": "    // Lightmap UVs and ambient color from SHL2 are shared in the vertex to pixel interpolators. Do full SH evaluation in the pixel shader when static lightmap and LIGHTPROBE_SH is enabled.",
          "lineNum": 48,
          "code": "    #define UNITY_SAMPLE_FULL_SH_PER_PIXEL (LIGHTMAP_ON && LIGHTPROBE_SH)"
        },
        {
          "comment": "",
          "lineNum": 58,
          "code": "#define UNITY_BRDF_GGX 1"
        },
        {
          "comment": "// Orthnormalize Tangent Space basis per-pixel\n// Necessary to support high-quality normal-maps. Compatible with Maya and Marmoset.\n// However xNormal expects oldschool non-orthnormalized basis - essentially preventing good looking normal-maps :(\n// Due to the fact that xNormal is probably _the most used tool to bake out normal-maps today_ we have to stick to old ways for now.\n//\n// Disabled by default, until xNormal has an option to bake proper normal-maps.",
          "lineNum": 68,
          "code": "#define UNITY_TANGENT_ORTHONORMALIZE 0"
        },
        {
          "comment": "// Simplified Standard Shader is off by default and should not be used for Legacy Shaders",
          "lineNum": 76,
          "code": "    #define UNITY_STANDARD_SIMPLE 0"
        },
        {
          "comment": "// Setup a new define with meaningful name to know if we require world pos in fragment shader",
          "lineNum": 81,
          "code": "    #define UNITY_REQUIRE_FRAG_WORLDPOS 0"
        },
        {
          "comment": "// Setup a new define with meaningful name to know if we require world pos in fragment shader",
          "lineNum": 83,
          "code": "    #define UNITY_REQUIRE_FRAG_WORLDPOS 1"
        },
        {
          "comment": "// Should we pack worldPos along tangent (saving an interpolator)\n// We want to skip this on mobile platforms, because worldpos gets packed into mediump",
          "lineNum": 89,
          "code": "    #define UNITY_PACK_WORLDPOS_WITH_TANGENT 1"
        },
        {
          "comment": "// Should we pack worldPos along tangent (saving an interpolator)\n// We want to skip this on mobile platforms, because worldpos gets packed into mediump",
          "lineNum": 91,
          "code": "    #define UNITY_PACK_WORLDPOS_WITH_TANGENT 0"
        }
      ],
      "functions": [],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnityStandardCore.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_CORE_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 140,
          "code": "    #define IN_VIEWDIR4PARALLAX(i) NormalizePerPixelNormal(half3(i.tangentToWorldAndPackedData[0].w,i.tangentToWorldAndPackedData[1].w,i.tangentToWorldAndPackedData[2].w))"
        },
        {
          "comment": "",
          "lineNum": 141,
          "code": "    #define IN_VIEWDIR4PARALLAX_FWDADD(i) NormalizePerPixelNormal(i.viewDirForParallax.xyz)"
        },
        {
          "comment": "",
          "lineNum": 143,
          "code": "    #define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)"
        },
        {
          "comment": "",
          "lineNum": 144,
          "code": "    #define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)"
        },
        {
          "comment": "",
          "lineNum": 149,
          "code": "        #define IN_WORLDPOS(i) half3(i.tangentToWorldAndPackedData[0].w,i.tangentToWorldAndPackedData[1].w,i.tangentToWorldAndPackedData[2].w)"
        },
        {
          "comment": "",
          "lineNum": 151,
          "code": "        #define IN_WORLDPOS(i) i.posWorld"
        },
        {
          "comment": "",
          "lineNum": 153,
          "code": "    #define IN_WORLDPOS_FWDADD(i) i.posWorld"
        },
        {
          "comment": "",
          "lineNum": 155,
          "code": "    #define IN_WORLDPOS(i) half3(0,0,0)"
        },
        {
          "comment": "",
          "lineNum": 156,
          "code": "    #define IN_WORLDPOS_FWDADD(i) half3(0,0,0)"
        },
        {
          "comment": "",
          "lineNum": 159,
          "code": "#define IN_LIGHTDIR_FWDADD(i) half3(i.tangentToWorldAndLightDir[0].w, i.tangentToWorldAndLightDir[1].w, i.tangentToWorldAndLightDir[2].w)"
        },
        {
          "comment": "",
          "lineNum": 161,
          "code": "#define FRAGMENT_SETUP(x) FragmentCommonData x = \\\n    FragmentSetup(i.tex, i.eyeVec.xyz, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndPackedData, IN_WORLDPOS(i));"
        },
        {
          "comment": "",
          "lineNum": 164,
          "code": "#define FRAGMENT_SETUP_FWDADD(x) FragmentCommonData x = \\\n    FragmentSetup(i.tex, i.eyeVec.xyz, IN_VIEWDIR4PARALLAX_FWDADD(i), i.tangentToWorldAndLightDir, IN_WORLDPOS_FWDADD(i));"
        },
        {
          "comment": "",
          "lineNum": 188,
          "code": "    #define UNITY_SETUP_BRDF_INPUT SpecularSetup"
        }
      ],
      "functions": [
        {
          "comment": "//-------------------------------------------------------------------------------------\n// counterpart for NormalizePerPixelNormal\n// skips normalization per-vertex and expects normalization to happen per-pixel",
          "lineNum": 17,
          "modifiers": "",
          "parameters": "float3 n",
          "type": "half3",
          "name": "NormalizePerVertexNormal",
          "code": "half3 NormalizePerVertexNormal (float3 n) // takes float to avoid overflow\n{\n    #if (SHADER_TARGET < 30) || UNITY_STANDARD_SIMPLE\n        return normalize(n);\n    #else\n        return n; // will normalize per-pixel instead\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 26,
          "modifiers": "",
          "parameters": "float3 n",
          "type": "float3",
          "name": "NormalizePerPixelNormal",
          "code": "float3 NormalizePerPixelNormal (float3 n)\n{\n    #if (SHADER_TARGET < 30) || UNITY_STANDARD_SIMPLE\n        return n;\n    #else\n        return normalize((float3)n); // takes float to avoid overflow\n    #endif\n}"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------",
          "lineNum": 36,
          "modifiers": "",
          "parameters": "",
          "type": "UnityLight",
          "name": "MainLight",
          "code": "UnityLight MainLight ()\n{\n    UnityLight l;\n\n    l.color = _LightColor0.rgb;\n    l.dir = _WorldSpaceLightPos0.xyz;\n    return l;\n}"
        },
        {
          "comment": "",
          "lineNum": 45,
          "modifiers": "",
          "parameters": "half3 lightDir, half atten",
          "type": "UnityLight",
          "name": "AdditiveLight",
          "code": "UnityLight AdditiveLight (half3 lightDir, half atten)\n{\n    UnityLight l;\n\n    l.color = _LightColor0.rgb;\n    l.dir = lightDir;\n    #ifndef USING_DIRECTIONAL_LIGHT\n        l.dir = NormalizePerPixelNormal(l.dir);\n    #endif\n\n    // shadow the light\n    l.color *= atten;\n    return l;\n}"
        },
        {
          "comment": "",
          "lineNum": 60,
          "modifiers": "",
          "parameters": "",
          "type": "UnityLight",
          "name": "DummyLight",
          "code": "UnityLight DummyLight ()\n{\n    UnityLight l;\n    l.color = 0;\n    l.dir = half3 (0,1,0);\n    return l;\n}"
        },
        {
          "comment": "",
          "lineNum": 68,
          "modifiers": "",
          "parameters": "",
          "type": "UnityIndirect",
          "name": "ZeroIndirect",
          "code": "UnityIndirect ZeroIndirect ()\n{\n    UnityIndirect ind;\n    ind.diffuse = 0;\n    ind.specular = 0;\n    return ind;\n}"
        },
        {
          "comment": "// deprecated",
          "lineNum": 80,
          "modifiers": "",
          "parameters": "half4 tan2world[3]",
          "type": "half3",
          "name": "WorldNormal",
          "code": "half3 WorldNormal(half4 tan2world[3])\n{\n    return normalize(tan2world[2].xyz);\n}"
        },
        {
          "comment": "// deprecated",
          "lineNum": 87,
          "modifiers": "",
          "parameters": "half4 tan2world[3]",
          "type": "half3x3",
          "name": "ExtractTangentToWorldPerPixel",
          "code": "    half3x3 ExtractTangentToWorldPerPixel(half4 tan2world[3])\n    {\n        half3 t = tan2world[0].xyz;\n        half3 b = tan2world[1].xyz;\n        half3 n = tan2world[2].xyz;\n\n    #if UNITY_TANGENT_ORTHONORMALIZE\n        n = NormalizePerPixelNormal(n);\n\n        // ortho-normalize Tangent\n        t = normalize (t - n * dot(t, n));\n\n        // recalculate Binormal\n        half3 newB = cross(n, t);\n        b = newB * sign (dot (newB, b));\n    #endif\n\n        return half3x3(t, b, n);\n    }"
        },
        {
          "comment": "",
          "lineNum": 107,
          "modifiers": "",
          "parameters": "half4 tan2world[3]",
          "type": "half3x3",
          "name": "ExtractTangentToWorldPerPixel",
          "code": "    half3x3 ExtractTangentToWorldPerPixel(half4 tan2world[3])\n    {\n        return half3x3(0,0,0,0,0,0,0,0,0);\n    }"
        },
        {
          "comment": "",
          "lineNum": 113,
          "modifiers": "",
          "parameters": "float4 i_tex, float4 tangentToWorld[3]",
          "type": "float3",
          "name": "PerPixelWorldNormal",
          "code": "float3 PerPixelWorldNormal(float4 i_tex, float4 tangentToWorld[3])\n{\n#ifdef _NORMALMAP\n    half3 tangent = tangentToWorld[0].xyz;\n    half3 binormal = tangentToWorld[1].xyz;\n    half3 normal = tangentToWorld[2].xyz;\n\n    #if UNITY_TANGENT_ORTHONORMALIZE\n        normal = NormalizePerPixelNormal(normal);\n\n        // ortho-normalize Tangent\n        tangent = normalize (tangent - normal * dot(tangent, normal));\n\n        // recalculate Binormal\n        half3 newB = cross(normal, tangent);\n        binormal = newB * sign (dot (newB, binormal));\n    #endif\n\n    half3 normalTangent = NormalInTangentSpace(i_tex);\n    float3 normalWorld = NormalizePerPixelNormal(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z); // @TODO: see if we can squeeze this normalize on SM2.0 as well\n#else\n    float3 normalWorld = normalize(tangentToWorld[2].xyz);\n#endif\n    return normalWorld;\n}"
        },
        {
          "comment": "",
          "lineNum": 191,
          "modifiers": "inline",
          "parameters": "float4 i_tex",
          "type": "FragmentCommonData",
          "name": "SpecularSetup",
          "code": "inline FragmentCommonData SpecularSetup (float4 i_tex)\n{\n    half4 specGloss = SpecularGloss(i_tex.xy);\n    half3 specColor = specGloss.rgb;\n    half smoothness = specGloss.a;\n\n    half oneMinusReflectivity;\n    half3 diffColor = EnergyConservationBetweenDiffuseAndSpecular (Albedo(i_tex), specColor, /*out*/ oneMinusReflectivity);\n\n    FragmentCommonData o = (FragmentCommonData)0;\n    o.diffColor = diffColor;\n    o.specColor = specColor;\n    o.oneMinusReflectivity = oneMinusReflectivity;\n    o.smoothness = smoothness;\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 208,
          "modifiers": "inline",
          "parameters": "float4 i_tex",
          "type": "FragmentCommonData",
          "name": "RoughnessSetup",
          "code": "inline FragmentCommonData RoughnessSetup(float4 i_tex)\n{\n    half2 metallicGloss = MetallicRough(i_tex.xy);\n    half metallic = metallicGloss.x;\n    half smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\n\n    half oneMinusReflectivity;\n    half3 specColor;\n    half3 diffColor = DiffuseAndSpecularFromMetallic(Albedo(i_tex), metallic, /*out*/ specColor, /*out*/ oneMinusReflectivity);\n\n    FragmentCommonData o = (FragmentCommonData)0;\n    o.diffColor = diffColor;\n    o.specColor = specColor;\n    o.oneMinusReflectivity = oneMinusReflectivity;\n    o.smoothness = smoothness;\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 226,
          "modifiers": "inline",
          "parameters": "float4 i_tex",
          "type": "FragmentCommonData",
          "name": "MetallicSetup",
          "code": "inline FragmentCommonData MetallicSetup (float4 i_tex)\n{\n    half2 metallicGloss = MetallicGloss(i_tex.xy);\n    half metallic = metallicGloss.x;\n    half smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\n\n    half oneMinusReflectivity;\n    half3 specColor;\n    half3 diffColor = DiffuseAndSpecularFromMetallic (Albedo(i_tex), metallic, /*out*/ specColor, /*out*/ oneMinusReflectivity);\n\n    FragmentCommonData o = (FragmentCommonData)0;\n    o.diffColor = diffColor;\n    o.specColor = specColor;\n    o.oneMinusReflectivity = oneMinusReflectivity;\n    o.smoothness = smoothness;\n    return o;\n}"
        },
        {
          "comment": "// parallax transformed texcoord is used to sample occlusion",
          "lineNum": 245,
          "modifiers": "inline",
          "parameters": "inout float4 i_tex, float3 i_eyeVec, half3 i_viewDirForParallax, float4 tangentToWorld[3], float3 i_posWorld",
          "type": "FragmentCommonData",
          "name": "FragmentSetup",
          "code": "inline FragmentCommonData FragmentSetup (inout float4 i_tex, float3 i_eyeVec, half3 i_viewDirForParallax, float4 tangentToWorld[3], float3 i_posWorld)\n{\n    i_tex = Parallax(i_tex, i_viewDirForParallax);\n\n    half alpha = Alpha(i_tex.xy);\n    #if defined(_ALPHATEST_ON)\n        clip (alpha - _Cutoff);\n    #endif\n\n    FragmentCommonData o = UNITY_SETUP_BRDF_INPUT (i_tex);\n    o.normalWorld = PerPixelWorldNormal(i_tex, tangentToWorld);\n    o.eyeVec = NormalizePerPixelNormal(i_eyeVec);\n    o.posWorld = i_posWorld;\n\n    // NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)\n    o.diffColor = PreMultiplyAlpha (o.diffColor, alpha, o.oneMinusReflectivity, /*out*/ o.alpha);\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 264,
          "modifiers": "inline",
          "parameters": "FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections",
          "type": "UnityGI",
          "name": "FragmentGI",
          "code": "inline UnityGI FragmentGI (FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)\n{\n    UnityGIInput d;\n    d.light = light;\n    d.worldPos = s.posWorld;\n    d.worldViewDir = -s.eyeVec;\n    d.atten = atten;\n    #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n        d.ambient = 0;\n        d.lightmapUV = i_ambientOrLightmapUV;\n    #else\n        d.ambient = i_ambientOrLightmapUV.rgb;\n        d.lightmapUV = 0;\n    #endif\n\n    d.probeHDR[0] = unity_SpecCube0_HDR;\n    d.probeHDR[1] = unity_SpecCube1_HDR;\n    #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n      d.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending\n    #endif\n    #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n      d.boxMax[0] = unity_SpecCube0_BoxMax;\n      d.probePosition[0] = unity_SpecCube0_ProbePosition;\n      d.boxMax[1] = unity_SpecCube1_BoxMax;\n      d.boxMin[1] = unity_SpecCube1_BoxMin;\n      d.probePosition[1] = unity_SpecCube1_ProbePosition;\n    #endif\n\n    if(reflections)\n    {\n        Unity_GlossyEnvironmentData g = UnityGlossyEnvironmentSetup(s.smoothness, -s.eyeVec, s.normalWorld, s.specColor);\n        // Replace the reflUVW if it has been compute in Vertex shader. Note: the compiler will optimize the calcul in UnityGlossyEnvironmentSetup itself\n        #if UNITY_STANDARD_SIMPLE\n            g.reflUVW = s.reflUVW;\n        #endif\n\n        return UnityGlobalIllumination (d, occlusion, s.normalWorld, g);\n    }\n    else\n    {\n        return UnityGlobalIllumination (d, occlusion, s.normalWorld);\n    }\n}"
        },
        {
          "comment": "",
          "lineNum": 308,
          "modifiers": "inline",
          "parameters": "FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light",
          "type": "UnityGI",
          "name": "FragmentGI",
          "code": "inline UnityGI FragmentGI (FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)\n{\n    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);\n}"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------",
          "lineNum": 315,
          "modifiers": "",
          "parameters": "half4 output, half alphaFromSurface",
          "type": "half4",
          "name": "OutputForward",
          "code": "half4 OutputForward (half4 output, half alphaFromSurface)\n{\n    #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)\n        output.a = alphaFromSurface;\n    #else\n        UNITY_OPAQUE_ALPHA(output.a);\n    #endif\n    return output;\n}"
        },
        {
          "comment": "",
          "lineNum": 325,
          "modifiers": "inline",
          "parameters": "VertexInput v, float3 posWorld, half3 normalWorld",
          "type": "half4",
          "name": "VertexGIForward",
          "code": "inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)\n{\n    half4 ambientOrLightmapUV = 0;\n    // Static lightmaps\n    #ifdef LIGHTMAP_ON\n        ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n        ambientOrLightmapUV.zw = 0;\n    // Sample light probe for Dynamic objects only (no static or dynamic lightmaps)\n    #elif UNITY_SHOULD_SAMPLE_SH\n        #ifdef VERTEXLIGHT_ON\n            // Approximated illumination from non-important point lights\n            ambientOrLightmapUV.rgb = Shade4PointLights (\n                unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n                unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n                unity_4LightAtten0, posWorld, normalWorld);\n        #endif\n\n        ambientOrLightmapUV.rgb = ShadeSHPerVertex (normalWorld, ambientOrLightmapUV.rgb);\n    #endif\n\n    #ifdef DYNAMICLIGHTMAP_ON\n        ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    #endif\n\n    return ambientOrLightmapUV;\n}"
        },
        {
          "comment": "",
          "lineNum": 373,
          "modifiers": "",
          "parameters": "VertexInput v",
          "type": "VertexOutputForwardBase",
          "name": "vertForwardBase",
          "code": "VertexOutputForwardBase vertForwardBase (VertexInput v)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n    VertexOutputForwardBase o;\n    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);\n    UNITY_TRANSFER_INSTANCE_ID(v, o);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n    float4 posWorld = mul(unity_ObjectToWorld, v.vertex);\n    #if UNITY_REQUIRE_FRAG_WORLDPOS\n        #if UNITY_PACK_WORLDPOS_WITH_TANGENT\n            o.tangentToWorldAndPackedData[0].w = posWorld.x;\n            o.tangentToWorldAndPackedData[1].w = posWorld.y;\n            o.tangentToWorldAndPackedData[2].w = posWorld.z;\n        #else\n            o.posWorld = posWorld.xyz;\n        #endif\n    #endif\n    o.pos = UnityObjectToClipPos(v.vertex);\n\n    o.tex = TexCoords(v);\n    o.eyeVec.xyz = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);\n    float3 normalWorld = UnityObjectToWorldNormal(v.normal);\n    #ifdef _TANGENT_TO_WORLD\n        float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n        float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);\n        o.tangentToWorldAndPackedData[0].xyz = tangentToWorld[0];\n        o.tangentToWorldAndPackedData[1].xyz = tangentToWorld[1];\n        o.tangentToWorldAndPackedData[2].xyz = tangentToWorld[2];\n    #else\n        o.tangentToWorldAndPackedData[0].xyz = 0;\n        o.tangentToWorldAndPackedData[1].xyz = 0;\n        o.tangentToWorldAndPackedData[2].xyz = normalWorld;\n    #endif\n\n    //We need this for shadow receving\n    UNITY_TRANSFER_LIGHTING(o, v.uv1);\n\n    o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);\n\n    #ifdef _PARALLAXMAP\n        TANGENT_SPACE_ROTATION;\n        half3 viewDirForParallax = mul (rotation, ObjSpaceViewDir(v.vertex));\n        o.tangentToWorldAndPackedData[0].w = viewDirForParallax.x;\n        o.tangentToWorldAndPackedData[1].w = viewDirForParallax.y;\n        o.tangentToWorldAndPackedData[2].w = viewDirForParallax.z;\n    #endif\n\n    UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,o.pos);\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 426,
          "modifiers": "",
          "parameters": "VertexOutputForwardBase i",
          "type": "half4",
          "name": "fragForwardBaseInternal",
          "code": "half4 fragForwardBaseInternal (VertexOutputForwardBase i)\n{\n    UNITY_APPLY_DITHER_CROSSFADE(i.pos.xy);\n\n    FRAGMENT_SETUP(s)\n\n    UNITY_SETUP_INSTANCE_ID(i);\n    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);\n\n    UnityLight mainLight = MainLight ();\n    UNITY_LIGHT_ATTENUATION(atten, i, s.posWorld);\n\n    half occlusion = Occlusion(i.tex.xy);\n    UnityGI gi = FragmentGI (s, occlusion, i.ambientOrLightmapUV, atten, mainLight);\n\n    half4 c = UNITY_BRDF_PBS (s.diffColor, s.specColor, s.oneMinusReflectivity, s.smoothness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);\n    c.rgb += Emission(i.tex.xy);\n\n    UNITY_EXTRACT_FOG_FROM_EYE_VEC(i);\n    UNITY_APPLY_FOG(_unity_fogCoord, c.rgb);\n    return OutputForward (c, s.alpha);\n}"
        },
        {
          "comment": "",
          "lineNum": 449,
          "modifiers": "",
          "parameters": "VertexOutputForwardBase i",
          "type": "half4",
          "name": "fragForwardBase",
          "code": "half4 fragForwardBase (VertexOutputForwardBase i) : SV_Target   // backward compatibility (this used to be the fragment entry function)\n{\n    return fragForwardBaseInternal(i);\n}"
        },
        {
          "comment": "",
          "lineNum": 474,
          "modifiers": "",
          "parameters": "VertexInput v",
          "type": "VertexOutputForwardAdd",
          "name": "vertForwardAdd",
          "code": "VertexOutputForwardAdd vertForwardAdd (VertexInput v)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n    VertexOutputForwardAdd o;\n    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardAdd, o);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n    float4 posWorld = mul(unity_ObjectToWorld, v.vertex);\n    o.pos = UnityObjectToClipPos(v.vertex);\n\n    o.tex = TexCoords(v);\n    o.eyeVec.xyz = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);\n    o.posWorld = posWorld.xyz;\n    float3 normalWorld = UnityObjectToWorldNormal(v.normal);\n    #ifdef _TANGENT_TO_WORLD\n        float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n        float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);\n        o.tangentToWorldAndLightDir[0].xyz = tangentToWorld[0];\n        o.tangentToWorldAndLightDir[1].xyz = tangentToWorld[1];\n        o.tangentToWorldAndLightDir[2].xyz = tangentToWorld[2];\n    #else\n        o.tangentToWorldAndLightDir[0].xyz = 0;\n        o.tangentToWorldAndLightDir[1].xyz = 0;\n        o.tangentToWorldAndLightDir[2].xyz = normalWorld;\n    #endif\n    //We need this for shadow receiving and lighting\n    UNITY_TRANSFER_LIGHTING(o, v.uv1);\n\n    float3 lightDir = _WorldSpaceLightPos0.xyz - posWorld.xyz * _WorldSpaceLightPos0.w;\n    #ifndef USING_DIRECTIONAL_LIGHT\n        lightDir = NormalizePerVertexNormal(lightDir);\n    #endif\n    o.tangentToWorldAndLightDir[0].w = lightDir.x;\n    o.tangentToWorldAndLightDir[1].w = lightDir.y;\n    o.tangentToWorldAndLightDir[2].w = lightDir.z;\n\n    #ifdef _PARALLAXMAP\n        TANGENT_SPACE_ROTATION;\n        o.viewDirForParallax = mul (rotation, ObjSpaceViewDir(v.vertex));\n    #endif\n\n    UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o, o.pos);\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 520,
          "modifiers": "",
          "parameters": "VertexOutputForwardAdd i",
          "type": "half4",
          "name": "fragForwardAddInternal",
          "code": "half4 fragForwardAddInternal (VertexOutputForwardAdd i)\n{\n    UNITY_APPLY_DITHER_CROSSFADE(i.pos.xy);\n\n    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);\n\n    FRAGMENT_SETUP_FWDADD(s)\n\n    UNITY_LIGHT_ATTENUATION(atten, i, s.posWorld)\n    UnityLight light = AdditiveLight (IN_LIGHTDIR_FWDADD(i), atten);\n    UnityIndirect noIndirect = ZeroIndirect ();\n\n    half4 c = UNITY_BRDF_PBS (s.diffColor, s.specColor, s.oneMinusReflectivity, s.smoothness, s.normalWorld, -s.eyeVec, light, noIndirect);\n\n    UNITY_EXTRACT_FOG_FROM_EYE_VEC(i);\n    UNITY_APPLY_FOG_COLOR(_unity_fogCoord, c.rgb, half4(0,0,0,0)); // fog towards black in additive pass\n    return OutputForward (c, s.alpha);\n}"
        },
        {
          "comment": "",
          "lineNum": 539,
          "modifiers": "",
          "parameters": "VertexOutputForwardAdd i",
          "type": "half4",
          "name": "fragForwardAdd",
          "code": "half4 fragForwardAdd (VertexOutputForwardAdd i) : SV_Target     // backward compatibility (this used to be the fragment entry function)\n{\n    return fragForwardAddInternal(i);\n}"
        },
        {
          "comment": "",
          "lineNum": 564,
          "modifiers": "",
          "parameters": "VertexInput v",
          "type": "VertexOutputDeferred",
          "name": "vertDeferred",
          "code": "VertexOutputDeferred vertDeferred (VertexInput v)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n    VertexOutputDeferred o;\n    UNITY_INITIALIZE_OUTPUT(VertexOutputDeferred, o);\n    UNITY_TRANSFER_INSTANCE_ID(v, o);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n    float4 posWorld = mul(unity_ObjectToWorld, v.vertex);\n    #if UNITY_REQUIRE_FRAG_WORLDPOS\n        #if UNITY_PACK_WORLDPOS_WITH_TANGENT\n            o.tangentToWorldAndPackedData[0].w = posWorld.x;\n            o.tangentToWorldAndPackedData[1].w = posWorld.y;\n            o.tangentToWorldAndPackedData[2].w = posWorld.z;\n        #else\n            o.posWorld = posWorld.xyz;\n        #endif\n    #endif\n    o.pos = UnityObjectToClipPos(v.vertex);\n\n    o.tex = TexCoords(v);\n    o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);\n    float3 normalWorld = UnityObjectToWorldNormal(v.normal);\n    #ifdef _TANGENT_TO_WORLD\n        float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n        float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);\n        o.tangentToWorldAndPackedData[0].xyz = tangentToWorld[0];\n        o.tangentToWorldAndPackedData[1].xyz = tangentToWorld[1];\n        o.tangentToWorldAndPackedData[2].xyz = tangentToWorld[2];\n    #else\n        o.tangentToWorldAndPackedData[0].xyz = 0;\n        o.tangentToWorldAndPackedData[1].xyz = 0;\n        o.tangentToWorldAndPackedData[2].xyz = normalWorld;\n    #endif\n\n    o.ambientOrLightmapUV = 0;\n    #ifdef LIGHTMAP_ON\n        o.ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    #elif UNITY_SHOULD_SAMPLE_SH\n        o.ambientOrLightmapUV.rgb = ShadeSHPerVertex (normalWorld, o.ambientOrLightmapUV.rgb);\n    #endif\n    #ifdef DYNAMICLIGHTMAP_ON\n        o.ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    #endif\n\n    #ifdef _PARALLAXMAP\n        TANGENT_SPACE_ROTATION;\n        half3 viewDirForParallax = mul (rotation, ObjSpaceViewDir(v.vertex));\n        o.tangentToWorldAndPackedData[0].w = viewDirForParallax.x;\n        o.tangentToWorldAndPackedData[1].w = viewDirForParallax.y;\n        o.tangentToWorldAndPackedData[2].w = viewDirForParallax.z;\n    #endif\n\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 621,
          "modifiers": "",
          "parameters": "VertexOutputDeferred i,    out half4 outGBuffer0 : SV_Target0,    out half4 outGBuffer1 : SV_Target1,    out half4 outGBuffer2 : SV_Target2,    out half4 outEmission : SV_Target3          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)    ,out half4 outShadowMask : SV_Target4       #endif",
          "type": "void",
          "name": "fragDeferred",
          "code": "void fragDeferred (\n    VertexOutputDeferred i,\n    out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n    out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3          // RT3: emission (rgb), --unused-- (a)\n#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    ,out half4 outShadowMask : SV_Target4       // RT4: shadowmask (rgba)\n#endif\n)\n{\n    #if (SHADER_TARGET < 30)\n        outGBuffer0 = 1;\n        outGBuffer1 = 1;\n        outGBuffer2 = 0;\n        outEmission = 0;\n        #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n            outShadowMask = 1;\n        #endif\n        return;\n    #endif\n\n    UNITY_APPLY_DITHER_CROSSFADE(i.pos.xy);\n\n    FRAGMENT_SETUP(s)\n    UNITY_SETUP_INSTANCE_ID(i);\n\n    // no analytic lights in this pass\n    UnityLight dummyLight = DummyLight ();\n    half atten = 1;\n\n    // only GI\n    half occlusion = Occlusion(i.tex.xy);\n#if UNITY_ENABLE_REFLECTION_BUFFERS\n    bool sampleReflectionsInDeferred = false;\n#else\n    bool sampleReflectionsInDeferred = true;\n#endif\n\n    UnityGI gi = FragmentGI (s, occlusion, i.ambientOrLightmapUV, atten, dummyLight, sampleReflectionsInDeferred);\n\n    half3 emissiveColor = UNITY_BRDF_PBS (s.diffColor, s.specColor, s.oneMinusReflectivity, s.smoothness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect).rgb;\n\n    #ifdef _EMISSION\n        emissiveColor += Emission (i.tex.xy);\n    #endif\n\n    #ifndef UNITY_HDR_ON\n        emissiveColor.rgb = exp2(-emissiveColor.rgb);\n    #endif\n\n    UnityStandardData data;\n    data.diffuseColor   = s.diffColor;\n    data.occlusion      = occlusion;\n    data.specularColor  = s.specColor;\n    data.smoothness     = s.smoothness;\n    data.normalWorld    = s.normalWorld;\n\n    UnityStandardDataToGbuffer(data, outGBuffer0, outGBuffer1, outGBuffer2);\n\n    // Emissive lighting buffer\n    outEmission = half4(emissiveColor, 1);\n\n    // Baked direct lighting occlusion if any\n    #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n        outShadowMask = UnityGetRawBakedOcclusions(i.ambientOrLightmapUV.xy, IN_WORLDPOS(i));\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 695,
          "modifiers": "inline",
          "parameters": "float3 posWorld,    half occlusion, half4 i_ambientOrLightmapUV, half atten, half smoothness, half3 normalWorld, half3 eyeVec,    UnityLight light,    bool reflections",
          "type": "UnityGI",
          "name": "FragmentGI",
          "code": "inline UnityGI FragmentGI(\n    float3 posWorld,\n    half occlusion, half4 i_ambientOrLightmapUV, half atten, half smoothness, half3 normalWorld, half3 eyeVec,\n    UnityLight light,\n    bool reflections)\n{\n    // we init only fields actually used\n    FragmentCommonData s = (FragmentCommonData)0;\n    s.smoothness = smoothness;\n    s.normalWorld = normalWorld;\n    s.eyeVec = eyeVec;\n    s.posWorld = posWorld;\n    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, reflections);\n}"
        },
        {
          "comment": "    // we init only fields actually used",
          "lineNum": 709,
          "modifiers": "inline",
          "parameters": "float3 posWorld,    half occlusion, half4 i_ambientOrLightmapUV, half atten, half smoothness, half3 normalWorld, half3 eyeVec,    UnityLight light",
          "type": "UnityGI",
          "name": "FragmentGI",
          "code": "inline UnityGI FragmentGI (\n    float3 posWorld,\n    half occlusion, half4 i_ambientOrLightmapUV, half atten, half smoothness, half3 normalWorld, half3 eyeVec,\n    UnityLight light)\n{\n    return FragmentGI (posWorld, occlusion, i_ambientOrLightmapUV, atten, smoothness, normalWorld, eyeVec, light, true);\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 167,
          "type": "struct",
          "name": "FragmentCommonData",
          "modifiers": "",
          "code": "struct FragmentCommonData\n{\n    half3 diffColor, specColor;\n    // Note: smoothness & oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.\n    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.\n    half oneMinusReflectivity, smoothness;\n    float3 normalWorld;\n    float3 eyeVec;\n    half alpha;\n    float3 posWorld;\n\n#if UNITY_STANDARD_SIMPLE\n    half3 reflUVW;\n#endif\n\n#if UNITY_STANDARD_SIMPLE\n    half3 tangentSpaceNormal;\n#endif\n};"
        },
        {
          "comment": "",
          "lineNum": 355,
          "type": "struct",
          "name": "VertexOutputForwardBase",
          "modifiers": "",
          "code": "struct VertexOutputForwardBase\n{\n    UNITY_POSITION(pos);\n    float4 tex                            : TEXCOORD0;\n    float4 eyeVec                         : TEXCOORD1;    // eyeVec.xyz | fogCoord\n    float4 tangentToWorldAndPackedData[3] : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax or worldPos]\n    half4 ambientOrLightmapUV             : TEXCOORD5;    // SH or Lightmap UV\n    UNITY_LIGHTING_COORDS(6,7)\n\n    // next ones would not fit into SM2.0 limits, but they are always for SM3.0+\n#if UNITY_REQUIRE_FRAG_WORLDPOS && !UNITY_PACK_WORLDPOS_WITH_TANGENT\n    float3 posWorld                     : TEXCOORD8;\n#endif\n\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        },
        {
          "comment": "",
          "lineNum": 457,
          "type": "struct",
          "name": "VertexOutputForwardAdd",
          "modifiers": "",
          "code": "struct VertexOutputForwardAdd\n{\n    UNITY_POSITION(pos);\n    float4 tex                          : TEXCOORD0;\n    float4 eyeVec                       : TEXCOORD1;    // eyeVec.xyz | fogCoord\n    float4 tangentToWorldAndLightDir[3] : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:lightDir]\n    float3 posWorld                     : TEXCOORD5;\n    UNITY_LIGHTING_COORDS(6, 7)\n\n    // next ones would not fit into SM2.0 limits, but they are always for SM3.0+\n#if defined(_PARALLAXMAP)\n    half3 viewDirForParallax            : TEXCOORD8;\n#endif\n\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        },
        {
          "comment": "",
          "lineNum": 547,
          "type": "struct",
          "name": "VertexOutputDeferred",
          "modifiers": "",
          "code": "struct VertexOutputDeferred\n{\n    UNITY_POSITION(pos);\n    float4 tex                            : TEXCOORD0;\n    float3 eyeVec                         : TEXCOORD1;\n    float4 tangentToWorldAndPackedData[3] : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax or worldPos]\n    half4 ambientOrLightmapUV             : TEXCOORD5;    // SH or Lightmap UVs\n\n    #if UNITY_REQUIRE_FRAG_WORLDPOS && !UNITY_PACK_WORLDPOS_WITH_TANGENT\n        float3 posWorld                     : TEXCOORD6;\n    #endif\n\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": []
    },
    {
      "file": "UnityStandardCoreForward.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_CORE_FORWARD_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 12,
          "modifiers": "",
          "parameters": "VertexInput v) { return vertForwardBaseSimple(v",
          "type": "VertexOutputBaseSimple",
          "name": "vertBase",
          "code": "    VertexOutputBaseSimple vertBase (VertexInput v) { return vertForwardBaseSimple(v); }"
        },
        {
          "comment": "",
          "lineNum": 13,
          "modifiers": "",
          "parameters": "VertexInput v) { return vertForwardAddSimple(v",
          "type": "VertexOutputForwardAddSimple",
          "name": "vertAdd",
          "code": "    VertexOutputForwardAddSimple vertAdd (VertexInput v) { return vertForwardAddSimple(v); }"
        },
        {
          "comment": "",
          "lineNum": 14,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i) : SV_Target { return fragForwardBaseSimpleInternal(i",
          "type": "half4",
          "name": "fragBase",
          "code": "    half4 fragBase (VertexOutputBaseSimple i) : SV_Target { return fragForwardBaseSimpleInternal(i); }"
        },
        {
          "comment": "",
          "lineNum": 15,
          "modifiers": "",
          "parameters": "VertexOutputForwardAddSimple i) : SV_Target { return fragForwardAddSimpleInternal(i",
          "type": "half4",
          "name": "fragAdd",
          "code": "    half4 fragAdd (VertexOutputForwardAddSimple i) : SV_Target { return fragForwardAddSimpleInternal(i); }"
        },
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "",
          "parameters": "VertexInput v) { return vertForwardBase(v",
          "type": "VertexOutputForwardBase",
          "name": "vertBase",
          "code": "    VertexOutputForwardBase vertBase (VertexInput v) { return vertForwardBase(v); }"
        },
        {
          "comment": "",
          "lineNum": 19,
          "modifiers": "",
          "parameters": "VertexInput v) { return vertForwardAdd(v",
          "type": "VertexOutputForwardAdd",
          "name": "vertAdd",
          "code": "    VertexOutputForwardAdd vertAdd (VertexInput v) { return vertForwardAdd(v); }"
        },
        {
          "comment": "",
          "lineNum": 20,
          "modifiers": "",
          "parameters": "VertexOutputForwardBase i) : SV_Target { return fragForwardBaseInternal(i",
          "type": "half4",
          "name": "fragBase",
          "code": "    half4 fragBase (VertexOutputForwardBase i) : SV_Target { return fragForwardBaseInternal(i); }"
        },
        {
          "comment": "",
          "lineNum": 21,
          "modifiers": "",
          "parameters": "VertexOutputForwardAdd i) : SV_Target { return fragForwardAddInternal(i",
          "type": "half4",
          "name": "fragAdd",
          "code": "    half4 fragAdd (VertexOutputForwardAdd i) : SV_Target { return fragForwardAddInternal(i); }"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnityStandardCoreForwardSimple.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_CORE_FORWARD_SIMPLE_INCLUDED"
        },
        {
          "comment": "//  Does not support: _PARALLAXMAP, DIRLIGHTMAP_COMBINED",
          "lineNum": 7,
          "code": "#define GLOSSMAP (defined(_SPECGLOSSMAP) || defined(_METALLICGLOSSMAP))"
        },
        {
          "comment": "",
          "lineNum": 10,
          "code": "    #define SPECULAR_HIGHLIGHTS (!defined(_SPECULAR_HIGHLIGHTS_OFF))"
        },
        {
          "comment": "",
          "lineNum": 54,
          "code": "#define JOIN2(a, b) a##b"
        },
        {
          "comment": "",
          "lineNum": 55,
          "code": "#define JOIN(a, b) JOIN2(a,b)"
        },
        {
          "comment": "",
          "lineNum": 56,
          "code": "#define UNIFORM_REFLECTIVITY JOIN(UNITY_SETUP_BRDF_INPUT, _Reflectivity)"
        }
      ],
      "functions": [
        {
          "comment": "// UNIFORM_REFLECTIVITY(): workaround to get (uniform) reflecivity based on UNITY_SETUP_BRDF_INPUT",
          "lineNum": 39,
          "modifiers": "",
          "parameters": "",
          "type": "half",
          "name": "MetallicSetup_Reflectivity",
          "code": "half MetallicSetup_Reflectivity()\n{\n    return 1.0h - OneMinusReflectivityFromMetallic(_Metallic);\n}"
        },
        {
          "comment": "",
          "lineNum": 44,
          "modifiers": "",
          "parameters": "",
          "type": "half",
          "name": "SpecularSetup_Reflectivity",
          "code": "half SpecularSetup_Reflectivity()\n{\n    return SpecularStrength(_SpecColor.rgb);\n}"
        },
        {
          "comment": "",
          "lineNum": 49,
          "modifiers": "",
          "parameters": "",
          "type": "half",
          "name": "RoughnessSetup_Reflectivity",
          "code": "half RoughnessSetup_Reflectivity()\n{\n    return MetallicSetup_Reflectivity();\n}"
        },
        {
          "comment": "",
          "lineNum": 61,
          "modifiers": "",
          "parameters": "half3 tangent, half3 binormal, half3 normal, half3 v",
          "type": "half3",
          "name": "TransformToTangentSpace",
          "code": "half3 TransformToTangentSpace(half3 tangent, half3 binormal, half3 normal, half3 v)\n{\n    // Mali400 shader compiler prefers explicit dot product over using a half3x3 matrix\n    return half3(dot(tangent, v), dot(binormal, v), dot(normal, v));\n}"
        },
        {
          "comment": "",
          "lineNum": 67,
          "modifiers": "",
          "parameters": "half3 normalWorld, half4 vTangent, half3 lightDirWorld, half3 eyeVecWorld, out half3 tangentSpaceLightDir, out half3 tangentSpaceEyeVec",
          "type": "void",
          "name": "TangentSpaceLightingInput",
          "code": "void TangentSpaceLightingInput(half3 normalWorld, half4 vTangent, half3 lightDirWorld, half3 eyeVecWorld, out half3 tangentSpaceLightDir, out half3 tangentSpaceEyeVec)\n{\n    half3 tangentWorld = UnityObjectToWorldDir(vTangent.xyz);\n    half sign = half(vTangent.w) * half(unity_WorldTransformParams.w);\n    half3 binormalWorld = cross(normalWorld, tangentWorld) * sign;\n    tangentSpaceLightDir = TransformToTangentSpace(tangentWorld, binormalWorld, normalWorld, lightDirWorld);\n    #if SPECULAR_HIGHLIGHTS\n        tangentSpaceEyeVec = normalize(TransformToTangentSpace(tangentWorld, binormalWorld, normalWorld, eyeVecWorld));\n    #else\n        tangentSpaceEyeVec = 0;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 82,
          "modifiers": "",
          "parameters": "VertexInput v",
          "type": "VertexOutputBaseSimple",
          "name": "vertForwardBaseSimple",
          "code": "VertexOutputBaseSimple vertForwardBaseSimple (VertexInput v)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n    VertexOutputBaseSimple o;\n    UNITY_INITIALIZE_OUTPUT(VertexOutputBaseSimple, o);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n    float4 posWorld = mul(unity_ObjectToWorld, v.vertex);\n    o.pos = UnityObjectToClipPos(v.vertex);\n    o.tex = TexCoords(v);\n\n    half3 eyeVec = normalize(posWorld.xyz - _WorldSpaceCameraPos);\n    half3 normalWorld = UnityObjectToWorldNormal(v.normal);\n\n    o.normalWorld.xyz = normalWorld;\n    o.eyeVec.xyz = eyeVec;\n\n    #ifdef _NORMALMAP\n        half3 tangentSpaceEyeVec;\n        TangentSpaceLightingInput(normalWorld, v.tangent, _WorldSpaceLightPos0.xyz, eyeVec, o.tangentSpaceLightDir, tangentSpaceEyeVec);\n        #if SPECULAR_HIGHLIGHTS\n            o.tangentSpaceEyeVec = tangentSpaceEyeVec;\n        #endif\n    #endif\n\n    //We need this for shadow receiving\n    TRANSFER_SHADOW(o);\n\n    o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);\n\n    o.fogCoord.yzw = reflect(eyeVec, normalWorld);\n\n    o.normalWorld.w = Pow4(1 - saturate(dot(normalWorld, -eyeVec))); // fresnel term\n    #if !GLOSSMAP\n        o.eyeVec.w = saturate(_Glossiness + UNIFORM_REFLECTIVITY()); // grazing term\n    #endif\n\n    UNITY_TRANSFER_FOG(o, o.pos);\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 124,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i",
          "type": "FragmentCommonData",
          "name": "FragmentSetupSimple",
          "code": "FragmentCommonData FragmentSetupSimple(VertexOutputBaseSimple i)\n{\n    half alpha = Alpha(i.tex.xy);\n    #if defined(_ALPHATEST_ON)\n        clip (alpha - _Cutoff);\n    #endif\n\n    FragmentCommonData s = UNITY_SETUP_BRDF_INPUT (i.tex);\n\n    // NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)\n    s.diffColor = PreMultiplyAlpha (s.diffColor, alpha, s.oneMinusReflectivity, /*out*/ s.alpha);\n\n    s.normalWorld = i.normalWorld.xyz;\n    s.eyeVec = i.eyeVec.xyz;\n    s.posWorld = IN_WORLDPOS(i);\n    s.reflUVW = i.fogCoord.yzw;\n\n    #ifdef _NORMALMAP\n        s.tangentSpaceNormal =  NormalInTangentSpace(i.tex);\n    #else\n        s.tangentSpaceNormal =  0;\n    #endif\n\n    return s;\n}"
        },
        {
          "comment": "",
          "lineNum": 150,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i, FragmentCommonData s",
          "type": "UnityLight",
          "name": "MainLightSimple",
          "code": "UnityLight MainLightSimple(VertexOutputBaseSimple i, FragmentCommonData s)\n{\n    UnityLight mainLight = MainLight();\n    return mainLight;\n}"
        },
        {
          "comment": "",
          "lineNum": 156,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i, FragmentCommonData s",
          "type": "half",
          "name": "PerVertexGrazingTerm",
          "code": "half PerVertexGrazingTerm(VertexOutputBaseSimple i, FragmentCommonData s)\n{\n    #if GLOSSMAP\n        return saturate(s.smoothness + (1-s.oneMinusReflectivity));\n    #else\n        return i.eyeVec.w;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 165,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i",
          "type": "half",
          "name": "PerVertexFresnelTerm",
          "code": "half PerVertexFresnelTerm(VertexOutputBaseSimple i)\n{\n    return i.normalWorld.w;\n}"
        },
        {
          "comment": "",
          "lineNum": 178,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i, UnityLight mainLight",
          "type": "half3",
          "name": "LightDirForSpecular",
          "code": "half3 LightDirForSpecular(VertexOutputBaseSimple i, UnityLight mainLight)\n{\n    #if SPECULAR_HIGHLIGHTS && defined(_NORMALMAP)\n        return i.tangentSpaceLightDir;\n    #else\n        return mainLight.dir;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 187,
          "modifiers": "",
          "parameters": "half3 diffColor, half3 specColor, half smoothness, half rl",
          "type": "half3",
          "name": "BRDF3DirectSimple",
          "code": "half3 BRDF3DirectSimple(half3 diffColor, half3 specColor, half smoothness, half rl)\n{\n    #if SPECULAR_HIGHLIGHTS\n        return BRDF3_Direct(diffColor, specColor, Pow4(rl), smoothness);\n    #else\n        return diffColor;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 196,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i",
          "type": "half4",
          "name": "fragForwardBaseSimpleInternal",
          "code": "half4 fragForwardBaseSimpleInternal (VertexOutputBaseSimple i)\n{\n    UNITY_APPLY_DITHER_CROSSFADE(i.pos.xy);\n\n    FragmentCommonData s = FragmentSetupSimple(i);\n\n    UnityLight mainLight = MainLightSimple(i, s);\n\n    #if !defined(LIGHTMAP_ON) && defined(_NORMALMAP)\n    half ndotl = saturate(dot(s.tangentSpaceNormal, i.tangentSpaceLightDir));\n    #else\n    half ndotl = saturate(dot(s.normalWorld, mainLight.dir));\n    #endif\n\n    //we can't have worldpos here (not enough interpolator on SM 2.0) so no shadow fade in that case.\n    half shadowMaskAttenuation = UnitySampleBakedOcclusion(i.ambientOrLightmapUV, 0);\n    half realtimeShadowAttenuation = SHADOW_ATTENUATION(i);\n    half atten = UnityMixRealtimeAndBakedShadows(realtimeShadowAttenuation, shadowMaskAttenuation, 0);\n\n    half occlusion = Occlusion(i.tex.xy);\n    half rl = dot(REFLECTVEC_FOR_SPECULAR(i, s), LightDirForSpecular(i, mainLight));\n\n    UnityGI gi = FragmentGI (s, occlusion, i.ambientOrLightmapUV, atten, mainLight);\n    half3 attenuatedLightColor = gi.light.color * ndotl;\n\n    half3 c = BRDF3_Indirect(s.diffColor, s.specColor, gi.indirect, PerVertexGrazingTerm(i, s), PerVertexFresnelTerm(i));\n    c += BRDF3DirectSimple(s.diffColor, s.specColor, s.smoothness, rl) * attenuatedLightColor;\n    c += Emission(i.tex.xy);\n\n    UNITY_APPLY_FOG(i.fogCoord, c);\n\n    return OutputForward (half4(c, 1), s.alpha);\n}"
        },
        {
          "comment": "",
          "lineNum": 230,
          "modifiers": "",
          "parameters": "VertexOutputBaseSimple i",
          "type": "half4",
          "name": "fragForwardBaseSimple",
          "code": "half4 fragForwardBaseSimple (VertexOutputBaseSimple i) : SV_Target  // backward compatibility (this used to be the fragment entry function)\n{\n    return fragForwardBaseSimpleInternal(i);\n}"
        },
        {
          "comment": "",
          "lineNum": 262,
          "modifiers": "",
          "parameters": "VertexInput v",
          "type": "VertexOutputForwardAddSimple",
          "name": "vertForwardAddSimple",
          "code": "VertexOutputForwardAddSimple vertForwardAddSimple (VertexInput v)\n{\n    VertexOutputForwardAddSimple o;\n    UNITY_SETUP_INSTANCE_ID(v);\n    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardAddSimple, o);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n    float4 posWorld = mul(unity_ObjectToWorld, v.vertex);\n    o.pos = UnityObjectToClipPos(v.vertex);\n    o.tex = TexCoords(v);\n    o.posWorld = posWorld.xyz;\n\n    //We need this for shadow receiving and lighting\n    UNITY_TRANSFER_LIGHTING(o, v.uv1);\n\n    half3 lightDir = _WorldSpaceLightPos0.xyz - posWorld.xyz * _WorldSpaceLightPos0.w;\n    #ifndef USING_DIRECTIONAL_LIGHT\n        lightDir = NormalizePerVertexNormal(lightDir);\n    #endif\n\n    #if SPECULAR_HIGHLIGHTS\n        half3 eyeVec = normalize(posWorld.xyz - _WorldSpaceCameraPos);\n    #endif\n\n    half3 normalWorld = UnityObjectToWorldNormal(v.normal);\n\n    #ifdef _NORMALMAP\n        #if SPECULAR_HIGHLIGHTS\n            TangentSpaceLightingInput(normalWorld, v.tangent, lightDir, eyeVec, o.lightDir, o.tangentSpaceEyeVec);\n        #else\n            half3 ignore;\n            TangentSpaceLightingInput(normalWorld, v.tangent, lightDir, 0, o.lightDir, ignore);\n        #endif\n    #else\n        o.lightDir = lightDir;\n        o.normalWorld = normalWorld;\n        #if SPECULAR_HIGHLIGHTS\n            o.fogCoord.yzw = reflect(eyeVec, normalWorld);\n        #endif\n    #endif\n\n    UNITY_TRANSFER_FOG(o,o.pos);\n    return o;\n}"
        },
        {
          "comment": "",
          "lineNum": 307,
          "modifiers": "",
          "parameters": "VertexOutputForwardAddSimple i",
          "type": "FragmentCommonData",
          "name": "FragmentSetupSimpleAdd",
          "code": "FragmentCommonData FragmentSetupSimpleAdd(VertexOutputForwardAddSimple i)\n{\n    half alpha = Alpha(i.tex.xy);\n    #if defined(_ALPHATEST_ON)\n        clip (alpha - _Cutoff);\n    #endif\n\n    FragmentCommonData s = UNITY_SETUP_BRDF_INPUT (i.tex);\n\n    // NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)\n    s.diffColor = PreMultiplyAlpha (s.diffColor, alpha, s.oneMinusReflectivity, /*out*/ s.alpha);\n\n    s.eyeVec = 0;\n    s.posWorld = i.posWorld;\n\n    #ifdef _NORMALMAP\n        s.tangentSpaceNormal = NormalInTangentSpace(i.tex);\n        s.normalWorld = 0;\n    #else\n        s.tangentSpaceNormal = 0;\n        s.normalWorld = i.normalWorld;\n    #endif\n\n    #if SPECULAR_HIGHLIGHTS && !defined(_NORMALMAP)\n        s.reflUVW = i.fogCoord.yzw;\n    #else\n        s.reflUVW = 0;\n    #endif\n\n    return s;\n}"
        },
        {
          "comment": "",
          "lineNum": 339,
          "modifiers": "",
          "parameters": "VertexOutputForwardAddSimple i, FragmentCommonData s",
          "type": "half3",
          "name": "LightSpaceNormal",
          "code": "half3 LightSpaceNormal(VertexOutputForwardAddSimple i, FragmentCommonData s)\n{\n    #ifdef _NORMALMAP\n        return s.tangentSpaceNormal;\n    #else\n        return i.normalWorld;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 348,
          "modifiers": "",
          "parameters": "VertexOutputForwardAddSimple i",
          "type": "half4",
          "name": "fragForwardAddSimpleInternal",
          "code": "half4 fragForwardAddSimpleInternal (VertexOutputForwardAddSimple i)\n{\n    UNITY_APPLY_DITHER_CROSSFADE(i.pos.xy);\n\n    FragmentCommonData s = FragmentSetupSimpleAdd(i);\n\n    half3 c = BRDF3DirectSimple(s.diffColor, s.specColor, s.smoothness, dot(REFLECTVEC_FOR_SPECULAR(i, s), i.lightDir));\n\n    #if SPECULAR_HIGHLIGHTS // else diffColor has premultiplied light color\n        c *= _LightColor0.rgb;\n    #endif\n\n    UNITY_LIGHT_ATTENUATION(atten, i, s.posWorld)\n    c *= atten * saturate(dot(LightSpaceNormal(i, s), i.lightDir));\n\n    UNITY_APPLY_FOG_COLOR(i.fogCoord, c.rgb, half4(0,0,0,0)); // fog towards black in additive pass\n    return OutputForward (half4(c, 1), s.alpha);\n}"
        },
        {
          "comment": "",
          "lineNum": 367,
          "modifiers": "",
          "parameters": "VertexOutputForwardAddSimple i",
          "type": "half4",
          "name": "fragForwardAddSimple",
          "code": "half4 fragForwardAddSimple (VertexOutputForwardAddSimple i) : SV_Target // backward compatibility (this used to be the fragment entry function)\n{\n    return fragForwardAddSimpleInternal(i);\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 13,
          "type": "struct",
          "name": "VertexOutputBaseSimple",
          "modifiers": "",
          "code": "struct VertexOutputBaseSimple\n{\n    UNITY_POSITION(pos);\n    float4 tex                          : TEXCOORD0;\n    half4 eyeVec                        : TEXCOORD1; // w: grazingTerm\n\n    half4 ambientOrLightmapUV           : TEXCOORD2; // SH or Lightmap UV\n    SHADOW_COORDS(3)\n    UNITY_FOG_COORDS_PACKED(4, half4) // x: fogCoord, yzw: reflectVec\n\n    half4 normalWorld                   : TEXCOORD5; // w: fresnelTerm\n\n#ifdef _NORMALMAP\n    half3 tangentSpaceLightDir          : TEXCOORD6;\n    #if SPECULAR_HIGHLIGHTS\n        half3 tangentSpaceEyeVec        : TEXCOORD7;\n    #endif\n#endif\n#if UNITY_REQUIRE_FRAG_WORLDPOS\n    float3 posWorld                     : TEXCOORD8;\n#endif\n\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        },
        {
          "comment": "",
          "lineNum": 235,
          "type": "struct",
          "name": "VertexOutputForwardAddSimple",
          "modifiers": "",
          "code": "struct VertexOutputForwardAddSimple\n{\n    UNITY_POSITION(pos);\n    float4 tex                          : TEXCOORD0;\n    float3 posWorld                     : TEXCOORD1;\n\n#if !defined(_NORMALMAP) && SPECULAR_HIGHLIGHTS\n    UNITY_FOG_COORDS_PACKED(2, half4) // x: fogCoord, yzw: reflectVec\n#else\n    UNITY_FOG_COORDS_PACKED(2, half1)\n#endif\n\n    half3 lightDir                      : TEXCOORD3;\n\n#if defined(_NORMALMAP)\n    #if SPECULAR_HIGHLIGHTS\n        half3 tangentSpaceEyeVec        : TEXCOORD4;\n    #endif\n#else\n    half3 normalWorld                   : TEXCOORD4;\n#endif\n\n    UNITY_LIGHTING_COORDS(5, 6)\n\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": []
    },
    {
      "file": "UnityStandardInput.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_INPUT_INCLUDED"
        },
        {
          "comment": "//---------------------------------------\n// Directional lightmaps & Parallax require tangent space too",
          "lineNum": 12,
          "code": "    #define _TANGENT_TO_WORLD 1"
        },
        {
          "comment": "",
          "lineNum": 16,
          "code": "    #define _DETAIL 1"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 70,
          "modifiers": "",
          "parameters": "VertexInput v",
          "type": "float4",
          "name": "TexCoords",
          "code": "float4 TexCoords(VertexInput v)\n{\n    float4 texcoord;\n    texcoord.xy = TRANSFORM_TEX(v.uv0, _MainTex); // Always source from uv0\n    texcoord.zw = TRANSFORM_TEX(((_UVSec == 0) ? v.uv0 : v.uv1), _DetailAlbedoMap);\n    return texcoord;\n}"
        },
        {
          "comment": "",
          "lineNum": 78,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half",
          "name": "DetailMask",
          "code": "half DetailMask(float2 uv)\n{\n    return tex2D (_DetailMask, uv).a;\n}"
        },
        {
          "comment": "",
          "lineNum": 83,
          "modifiers": "",
          "parameters": "float4 texcoords",
          "type": "half3",
          "name": "Albedo",
          "code": "half3 Albedo(float4 texcoords)\n{\n    half3 albedo = _Color.rgb * tex2D (_MainTex, texcoords.xy).rgb;\n#if _DETAIL\n    #if (SHADER_TARGET < 30)\n        // SM20: instruction count limitation\n        // SM20: no detail mask\n        half mask = 1;\n    #else\n        half mask = DetailMask(texcoords.xy);\n    #endif\n    half3 detailAlbedo = tex2D (_DetailAlbedoMap, texcoords.zw).rgb;\n    #if _DETAIL_MULX2\n        albedo *= LerpWhiteTo (detailAlbedo * unity_ColorSpaceDouble.rgb, mask);\n    #elif _DETAIL_MUL\n        albedo *= LerpWhiteTo (detailAlbedo, mask);\n    #elif _DETAIL_ADD\n        albedo += detailAlbedo * mask;\n    #elif _DETAIL_LERP\n        albedo = lerp (albedo, detailAlbedo, mask);\n    #endif\n#endif\n    return albedo;\n}"
        },
        {
          "comment": "",
          "lineNum": 108,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half",
          "name": "Alpha",
          "code": "half Alpha(float2 uv)\n{\n#if defined(_SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A)\n    return _Color.a;\n#else\n    return tex2D(_MainTex, uv).a * _Color.a;\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 117,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half",
          "name": "Occlusion",
          "code": "half Occlusion(float2 uv)\n{\n#if (SHADER_TARGET < 30)\n    // SM20: instruction count limitation\n    // SM20: simpler occlusion\n    return tex2D(_OcclusionMap, uv).g;\n#else\n    half occ = tex2D(_OcclusionMap, uv).g;\n    return LerpOneTo (occ, _OcclusionStrength);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 129,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half4",
          "name": "SpecularGloss",
          "code": "half4 SpecularGloss(float2 uv)\n{\n    half4 sg;\n#ifdef _SPECGLOSSMAP\n    #if defined(_SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A)\n        sg.rgb = tex2D(_SpecGlossMap, uv).rgb;\n        sg.a = tex2D(_MainTex, uv).a;\n    #else\n        sg = tex2D(_SpecGlossMap, uv);\n    #endif\n    sg.a *= _GlossMapScale;\n#else\n    sg.rgb = _SpecColor.rgb;\n    #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A\n        sg.a = tex2D(_MainTex, uv).a * _GlossMapScale;\n    #else\n        sg.a = _Glossiness;\n    #endif\n#endif\n    return sg;\n}"
        },
        {
          "comment": "",
          "lineNum": 151,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half2",
          "name": "MetallicGloss",
          "code": "half2 MetallicGloss(float2 uv)\n{\n    half2 mg;\n\n#ifdef _METALLICGLOSSMAP\n    #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A\n        mg.r = tex2D(_MetallicGlossMap, uv).r;\n        mg.g = tex2D(_MainTex, uv).a;\n    #else\n        mg = tex2D(_MetallicGlossMap, uv).ra;\n    #endif\n    mg.g *= _GlossMapScale;\n#else\n    mg.r = _Metallic;\n    #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A\n        mg.g = tex2D(_MainTex, uv).a * _GlossMapScale;\n    #else\n        mg.g = _Glossiness;\n    #endif\n#endif\n    return mg;\n}"
        },
        {
          "comment": "",
          "lineNum": 174,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half2",
          "name": "MetallicRough",
          "code": "half2 MetallicRough(float2 uv)\n{\n    half2 mg;\n#ifdef _METALLICGLOSSMAP\n    mg.r = tex2D(_MetallicGlossMap, uv).r;\n#else\n    mg.r = _Metallic;\n#endif\n\n#ifdef _SPECGLOSSMAP\n    mg.g = 1.0f - tex2D(_SpecGlossMap, uv).r;\n#else\n    mg.g = 1.0f - _Glossiness;\n#endif\n    return mg;\n}"
        },
        {
          "comment": "",
          "lineNum": 191,
          "modifiers": "",
          "parameters": "float2 uv",
          "type": "half3",
          "name": "Emission",
          "code": "half3 Emission(float2 uv)\n{\n#ifndef _EMISSION\n    return 0;\n#else\n    return tex2D(_EmissionMap, uv).rgb * _EmissionColor.rgb;\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 201,
          "modifiers": "",
          "parameters": "float4 texcoords",
          "type": "half3",
          "name": "NormalInTangentSpace",
          "code": "half3 NormalInTangentSpace(float4 texcoords)\n{\n    half3 normalTangent = UnpackScaleNormal(tex2D (_BumpMap, texcoords.xy), _BumpScale);\n\n#if _DETAIL && defined(UNITY_ENABLE_DETAIL_NORMALMAP)\n    half mask = DetailMask(texcoords.xy);\n    half3 detailNormalTangent = UnpackScaleNormal(tex2D (_DetailNormalMap, texcoords.zw), _DetailNormalMapScale);\n    #if _DETAIL_LERP\n        normalTangent = lerp(\n            normalTangent,\n            detailNormalTangent,\n            mask);\n    #else\n        normalTangent = lerp(\n            normalTangent,\n            BlendNormals(normalTangent, detailNormalTangent),\n            mask);\n    #endif\n#endif\n\n    return normalTangent;\n}"
        },
        {
          "comment": "",
          "lineNum": 225,
          "modifiers": "",
          "parameters": "float4 texcoords, half3 viewDir",
          "type": "float4",
          "name": "Parallax",
          "code": "float4 Parallax (float4 texcoords, half3 viewDir)\n{\n#if !defined(_PARALLAXMAP) || (SHADER_TARGET < 30)\n    // Disable parallax on pre-SM3.0 shader target models\n    return texcoords;\n#else\n    half h = tex2D (_ParallaxMap, texcoords.xy).g;\n    float2 offset = ParallaxOffset1Step (h, _Parallax, viewDir);\n    return float4(texcoords.xy + offset, texcoords.zw + offset);\n#endif\n\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 55,
          "type": "struct",
          "name": "VertexInput",
          "modifiers": "",
          "code": "struct VertexInput\n{\n    float4 vertex   : POSITION;\n    half3 normal    : NORMAL;\n    float2 uv0      : TEXCOORD0;\n    float2 uv1      : TEXCOORD1;\n#if defined(DYNAMICLIGHTMAP_ON) || defined(UNITY_PASS_META)\n    float2 uv2      : TEXCOORD2;\n#endif\n#ifdef _TANGENT_TO_WORLD\n    half4 tangent   : TANGENT;\n#endif\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        }
      ],
      "variables": [
        {
          "comment": "//---------------------------------------",
          "lineNum": 20,
          "modifiers": "",
          "type": "half4",
          "name": "_Color;",
          "code": "half4       _Color;"
        },
        {
          "comment": "//---------------------------------------",
          "lineNum": 21,
          "modifiers": "",
          "type": "half",
          "name": "_Cutoff;",
          "code": "half        _Cutoff;"
        },
        {
          "comment": "",
          "lineNum": 23,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D   _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 24,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_ST;",
          "code": "float4      _MainTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 26,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_DetailAlbedoMap;",
          "code": "sampler2D   _DetailAlbedoMap;"
        },
        {
          "comment": "",
          "lineNum": 27,
          "modifiers": "",
          "type": "float4",
          "name": "_DetailAlbedoMap_ST;",
          "code": "float4      _DetailAlbedoMap_ST;"
        },
        {
          "comment": "",
          "lineNum": 29,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_BumpMap;",
          "code": "sampler2D   _BumpMap;"
        },
        {
          "comment": "",
          "lineNum": 30,
          "modifiers": "",
          "type": "half",
          "name": "_BumpScale;",
          "code": "half        _BumpScale;"
        },
        {
          "comment": "",
          "lineNum": 32,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_DetailMask;",
          "code": "sampler2D   _DetailMask;"
        },
        {
          "comment": "",
          "lineNum": 33,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_DetailNormalMap;",
          "code": "sampler2D   _DetailNormalMap;"
        },
        {
          "comment": "",
          "lineNum": 34,
          "modifiers": "",
          "type": "half",
          "name": "_DetailNormalMapScale;",
          "code": "half        _DetailNormalMapScale;"
        },
        {
          "comment": "",
          "lineNum": 36,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_SpecGlossMap;",
          "code": "sampler2D   _SpecGlossMap;"
        },
        {
          "comment": "",
          "lineNum": 37,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MetallicGlossMap;",
          "code": "sampler2D   _MetallicGlossMap;"
        },
        {
          "comment": "",
          "lineNum": 38,
          "modifiers": "",
          "type": "half",
          "name": "_Metallic;",
          "code": "half        _Metallic;"
        },
        {
          "comment": "",
          "lineNum": 39,
          "modifiers": "",
          "type": "float",
          "name": "_Glossiness;",
          "code": "float       _Glossiness;"
        },
        {
          "comment": "",
          "lineNum": 40,
          "modifiers": "",
          "type": "float",
          "name": "_GlossMapScale;",
          "code": "float       _GlossMapScale;"
        },
        {
          "comment": "",
          "lineNum": 42,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_OcclusionMap;",
          "code": "sampler2D   _OcclusionMap;"
        },
        {
          "comment": "",
          "lineNum": 43,
          "modifiers": "",
          "type": "half",
          "name": "_OcclusionStrength;",
          "code": "half        _OcclusionStrength;"
        },
        {
          "comment": "",
          "lineNum": 45,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_ParallaxMap;",
          "code": "sampler2D   _ParallaxMap;"
        },
        {
          "comment": "",
          "lineNum": 46,
          "modifiers": "",
          "type": "half",
          "name": "_Parallax;",
          "code": "half        _Parallax;"
        },
        {
          "comment": "",
          "lineNum": 47,
          "modifiers": "",
          "type": "half",
          "name": "_UVSec;",
          "code": "half        _UVSec;"
        },
        {
          "comment": "",
          "lineNum": 49,
          "modifiers": "",
          "type": "half4",
          "name": "_EmissionColor;",
          "code": "half4       _EmissionColor;"
        },
        {
          "comment": "",
          "lineNum": 50,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_EmissionMap;",
          "code": "sampler2D   _EmissionMap;"
        }
      ]
    },
    {
      "file": "UnityStandardMeta.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_META_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "",
          "parameters": "VertexInput v",
          "type": "v2f_meta",
          "name": "vert_meta",
          "code": "v2f_meta vert_meta (VertexInput v)\n{\n    v2f_meta o;\n    o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);\n    o.uv = TexCoords(v);\n#ifdef EDITOR_VISUALIZATION\n    o.vizUV = 0;\n    o.lightCoord = 0;\n    if (unity_VisualizationMode == EDITORVIZ_TEXTURE)\n        o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.uv0.xy, v.uv1.xy, v.uv2.xy, unity_EditorViz_Texture_ST);\n    else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)\n    {\n        o.vizUV = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n        o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));\n    }\n#endif\n    return o;\n}"
        },
        {
          "comment": "// Albedo for lightmapping should basically be diffuse color.\n// But rough metals (black diffuse) still scatter quite a lot of light around, so\n// we want to take some of that into account too.",
          "lineNum": 44,
          "modifiers": "",
          "parameters": "half3 diffuse, half3 specular, half smoothness",
          "type": "half3",
          "name": "UnityLightmappingAlbedo",
          "code": "half3 UnityLightmappingAlbedo (half3 diffuse, half3 specular, half smoothness)\n{\n    half roughness = SmoothnessToRoughness(smoothness);\n    half3 res = diffuse;\n    res += specular * roughness * 0.5;\n    return res;\n}"
        },
        {
          "comment": "",
          "lineNum": 52,
          "modifiers": "",
          "parameters": "v2f_meta i",
          "type": "float4",
          "name": "frag_meta",
          "code": "float4 frag_meta (v2f_meta i) : SV_Target\n{\n    // we're interested in diffuse & specular colors,\n    // and surface roughness to produce final albedo.\n    FragmentCommonData data = UNITY_SETUP_BRDF_INPUT (i.uv);\n\n    UnityMetaInput o;\n    UNITY_INITIALIZE_OUTPUT(UnityMetaInput, o);\n\n#ifdef EDITOR_VISUALIZATION\n    o.Albedo = data.diffColor;\n    o.VizUV = i.vizUV;\n    o.LightCoord = i.lightCoord;\n#else\n    o.Albedo = UnityLightmappingAlbedo (data.diffColor, data.specColor, data.smoothness);\n#endif\n    o.SpecularColor = data.specColor;\n    o.Emission = Emission(i.uv.xy);\n\n    return UnityMetaFragment(o);\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 12,
          "type": "struct",
          "name": "v2f_meta",
          "modifiers": "",
          "code": "struct v2f_meta\n{\n    float4 pos      : SV_POSITION;\n    float4 uv       : TEXCOORD0;\n#ifdef EDITOR_VISUALIZATION\n    float2 vizUV        : TEXCOORD1;\n    float4 lightCoord   : TEXCOORD2;\n#endif\n};"
        }
      ],
      "variables": []
    },
    {
      "file": "UnityStandardParticleEditor.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_PARTICLE_EDITOR_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 5,
          "code": "#define _FLIPBOOK_BLENDING 1"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 48,
          "modifiers": "",
          "parameters": "VertexInput v, out VertexOutput o, out float4 opos : SV_POSITION",
          "type": "void",
          "name": "vertEditorPass",
          "code": "void vertEditorPass(VertexInput v, out VertexOutput o, out float4 opos : SV_POSITION)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n\n    opos = UnityObjectToClipPos(v.vertex);\n\n    #ifdef _FLIPBOOK_BLENDING\n        #ifdef UNITY_PARTICLE_INSTANCING_ENABLED\n            vertInstancingUVs(v.texcoords.xy, o.texcoord, o.texcoord2AndBlend);\n        #else\n            o.texcoord = v.texcoords.xy;\n            o.texcoord2AndBlend.xy = v.texcoords.zw;\n            o.texcoord2AndBlend.z = v.texcoordBlend;\n        #endif\n    #else\n        #ifdef UNITY_PARTICLE_INSTANCING_ENABLED\n            vertInstancingUVs(v.texcoords.xy, o.texcoord);\n            o.texcoord = TRANSFORM_TEX(o.texcoord, _MainTex);\n        #else\n            o.texcoord = TRANSFORM_TEX(v.texcoords.xy, _MainTex);\n        #endif\n    #endif\n    o.color = v.color;\n}"
        },
        {
          "comment": "",
          "lineNum": 73,
          "modifiers": "",
          "parameters": "VertexOutput i",
          "type": "void",
          "name": "fragSceneClip",
          "code": "void fragSceneClip(VertexOutput i)\n{\n    half alpha = tex2D(_MainTex, i.texcoord).a;\n#ifdef _FLIPBOOK_BLENDING\n    half alpha2 = tex2D(_MainTex, i.texcoord2AndBlend.xy);\n    alpha = lerp(alpha, alpha2, i.texcoord2AndBlend.z);\n#endif\n    alpha *= i.color.a;\n\n#ifdef _ALPHATEST_ON\n    clip(alpha - _Cutoff);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 87,
          "modifiers": "",
          "parameters": "VertexOutput i",
          "type": "half4",
          "name": "fragSceneHighlightPass",
          "code": "half4 fragSceneHighlightPass(VertexOutput i) : SV_Target\n{\n    fragSceneClip(i);\n    return float4(_ObjectId, _PassValue, 1, 1);\n}"
        },
        {
          "comment": "",
          "lineNum": 93,
          "modifiers": "",
          "parameters": "VertexOutput i",
          "type": "half4",
          "name": "fragScenePickingPass",
          "code": "half4 fragScenePickingPass(VertexOutput i) : SV_Target\n{\n    fragSceneClip(i);\n    return _SelectionID;\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 25,
          "type": "struct",
          "name": "VertexInput",
          "modifiers": "",
          "code": "struct VertexInput\n{\n    float4 vertex   : POSITION;\n    float3 normal   : NORMAL;\n    fixed4 color    : COLOR;\n    #if defined(_FLIPBOOK_BLENDING) && !defined(UNITY_PARTICLE_INSTANCING_ENABLED)\n        float4 texcoords : TEXCOORD0;\n        float texcoordBlend : TEXCOORD1;\n    #else\n        float2 texcoords : TEXCOORD0;\n    #endif\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 39,
          "type": "struct",
          "name": "VertexOutput",
          "modifiers": "",
          "code": "struct VertexOutput\n{\n    float2 texcoord : TEXCOORD0;\n    #ifdef _FLIPBOOK_BLENDING\n        float3 texcoord2AndBlend : TEXCOORD1;\n    #endif\n    fixed4 color : TEXCOORD2;\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 15,
          "modifiers": "",
          "type": "half",
          "name": "_Cutoff;",
          "code": "half        _Cutoff;"
        },
        {
          "comment": "",
          "lineNum": 17,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D   _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_ST;",
          "code": "float4      _MainTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 20,
          "modifiers": "",
          "type": "float",
          "name": "_ObjectId;",
          "code": "float _ObjectId;"
        },
        {
          "comment": "",
          "lineNum": 21,
          "modifiers": "",
          "type": "float",
          "name": "_PassValue;",
          "code": "float _PassValue;"
        },
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "",
          "type": "float4",
          "name": "_SelectionID;",
          "code": "float4 _SelectionID;"
        },
        {
          "comment": "",
          "lineNum": 23,
          "modifiers": "uniform",
          "type": "float",
          "name": "_SelectionAlphaCutoff;",
          "code": "uniform float _SelectionAlphaCutoff;"
        }
      ]
    },
    {
      "file": "UnityStandardParticleInstancing.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_PARTICLE_INSTANCING_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 5,
          "code": "#define UNITY_PARTICLE_INSTANCING_ENABLED"
        },
        {
          "comment": "",
          "lineNum": 11,
          "code": "#define UNITY_PARTICLE_INSTANCE_DATA DefaultParticleInstanceData"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 25,
          "modifiers": "",
          "parameters": "out float4x4 objectToWorld, out float4x4 worldToObject",
          "type": "void",
          "name": "vertInstancingMatrices",
          "code": "void vertInstancingMatrices(out float4x4 objectToWorld, out float4x4 worldToObject)\n{\n    UNITY_PARTICLE_INSTANCE_DATA data = unity_ParticleInstanceData[unity_InstanceID];\n\n    // transform matrix\n    objectToWorld._11_21_31_41 = float4(data.transform._11_21_31, 0.0f);\n    objectToWorld._12_22_32_42 = float4(data.transform._12_22_32, 0.0f);\n    objectToWorld._13_23_33_43 = float4(data.transform._13_23_33, 0.0f);\n    objectToWorld._14_24_34_44 = float4(data.transform._14_24_34, 1.0f);\n\n    // inverse transform matrix\n    float3x3 w2oRotation;\n    w2oRotation[0] = objectToWorld[1].yzx * objectToWorld[2].zxy - objectToWorld[1].zxy * objectToWorld[2].yzx;\n    w2oRotation[1] = objectToWorld[0].zxy * objectToWorld[2].yzx - objectToWorld[0].yzx * objectToWorld[2].zxy;\n    w2oRotation[2] = objectToWorld[0].yzx * objectToWorld[1].zxy - objectToWorld[0].zxy * objectToWorld[1].yzx;\n\n    float det = dot(objectToWorld[0].xyz, w2oRotation[0]);\n\n    w2oRotation = transpose(w2oRotation);\n\n    w2oRotation *= rcp(det);\n\n    float3 w2oPosition = mul(w2oRotation, -objectToWorld._14_24_34);\n\n    worldToObject._11_21_31_41 = float4(w2oRotation._11_21_31, 0.0f);\n    worldToObject._12_22_32_42 = float4(w2oRotation._12_22_32, 0.0f);\n    worldToObject._13_23_33_43 = float4(w2oRotation._13_23_33, 0.0f);\n    worldToObject._14_24_34_44 = float4(w2oPosition, 1.0f);\n}"
        },
        {
          "comment": "",
          "lineNum": 55,
          "modifiers": "",
          "parameters": "",
          "type": "void",
          "name": "vertInstancingSetup",
          "code": "void vertInstancingSetup()\n{\n    vertInstancingMatrices(unity_ObjectToWorld, unity_WorldToObject);\n}"
        },
        {
          "comment": "",
          "lineNum": 60,
          "modifiers": "",
          "parameters": "inout fixed4 color",
          "type": "void",
          "name": "vertInstancingColor",
          "code": "void vertInstancingColor(inout fixed4 color)\n{\n#ifndef UNITY_PARTICLE_INSTANCE_DATA_NO_COLOR\n    UNITY_PARTICLE_INSTANCE_DATA data = unity_ParticleInstanceData[unity_InstanceID];\n    color = lerp(fixed4(1.0f, 1.0f, 1.0f, 1.0f), color, unity_ParticleUseMeshColors);\n    color *= float4(data.color & 255, (data.color >> 8) & 255, (data.color >> 16) & 255, (data.color >> 24) & 255) * (1.0f / 255);\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 69,
          "modifiers": "",
          "parameters": "in float2 uv, out float2 texcoord, out float3 texcoord2AndBlend",
          "type": "void",
          "name": "vertInstancingUVs",
          "code": "void vertInstancingUVs(in float2 uv, out float2 texcoord, out float3 texcoord2AndBlend)\n{\n    if (unity_ParticleUVShiftData.x != 0.0f)\n    {\n        UNITY_PARTICLE_INSTANCE_DATA data = unity_ParticleInstanceData[unity_InstanceID];\n\n        float numTilesX = unity_ParticleUVShiftData.y;\n        float2 animScale = unity_ParticleUVShiftData.zw;\n#ifdef UNITY_PARTICLE_INSTANCE_DATA_NO_ANIM_FRAME\n        float sheetIndex = 0.0f;\n#else\n        float sheetIndex = data.animFrame;\n#endif\n\n        float index0 = floor(sheetIndex);\n        float vIdx0 = floor(index0 / numTilesX);\n        float uIdx0 = floor(index0 - vIdx0 * numTilesX);\n        float2 offset0 = float2(uIdx0 * animScale.x, (1.0f - animScale.y) - vIdx0 * animScale.y);\n\n        texcoord = uv * animScale.xy + offset0.xy;\n\n#ifdef _FLIPBOOK_BLENDING\n        float index1 = floor(sheetIndex + 1.0f);\n        float vIdx1 = floor(index1 / numTilesX);\n        float uIdx1 = floor(index1 - vIdx1 * numTilesX);\n        float2 offset1 = float2(uIdx1 * animScale.x, (1.0f - animScale.y) - vIdx1 * animScale.y);\n\n        texcoord2AndBlend.xy = uv * animScale.xy + offset1.xy;\n        texcoord2AndBlend.z = frac(sheetIndex);\n#else\n        texcoord2AndBlend.xy = texcoord;\n        texcoord2AndBlend.z = 0.0f;\n#endif\n    }\n    else\n    {\n        texcoord = uv;\n        texcoord2AndBlend.xy = uv;\n        texcoord2AndBlend.z = 0.0f;\n    }\n}"
        },
        {
          "comment": "",
          "lineNum": 111,
          "modifiers": "",
          "parameters": "in float2 uv, out float2 texcoord",
          "type": "void",
          "name": "vertInstancingUVs",
          "code": "void vertInstancingUVs(in float2 uv, out float2 texcoord)\n{\n    float3 texcoord2AndBlend = 0.0f;\n    vertInstancingUVs(uv, texcoord, texcoord2AndBlend);\n}"
        },
        {
          "comment": "",
          "lineNum": 119,
          "modifiers": "",
          "parameters": "",
          "type": "void",
          "name": "vertInstancingSetup",
          "code": "void vertInstancingSetup() {}"
        },
        {
          "comment": "",
          "lineNum": 120,
          "modifiers": "",
          "parameters": "inout fixed4 color",
          "type": "void",
          "name": "vertInstancingColor",
          "code": "void vertInstancingColor(inout fixed4 color) {}"
        },
        {
          "comment": "",
          "lineNum": 121,
          "modifiers": "",
          "parameters": "in float2 uv, out float2 texcoord, out float3 texcoord2AndBlend",
          "type": "void",
          "name": "vertInstancingUVs",
          "code": "void vertInstancingUVs(in float2 uv, out float2 texcoord, out float3 texcoord2AndBlend) { texcoord = 0.0f; texcoord2AndBlend = 0.0f; }"
        },
        {
          "comment": "",
          "lineNum": 122,
          "modifiers": "",
          "parameters": "in float2 uv, out float2 texcoord",
          "type": "void",
          "name": "vertInstancingUVs",
          "code": "void vertInstancingUVs(in float2 uv, out float2 texcoord) { texcoord = 0.0f; }"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 14,
          "type": "struct",
          "name": "DefaultParticleInstanceData",
          "modifiers": "",
          "code": "struct DefaultParticleInstanceData\n{\n    float3x4 transform;\n    uint color;\n    float animFrame;\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 21,
          "modifiers": "",
          "type": "StructuredBuffer<UNITY_PARTICLE_INSTANCE_DATA>",
          "name": "unity_ParticleInstanceData;",
          "code": "StructuredBuffer<UNITY_PARTICLE_INSTANCE_DATA> unity_ParticleInstanceData;"
        },
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "",
          "type": "float4",
          "name": "unity_ParticleUVShiftData;",
          "code": "float4 unity_ParticleUVShiftData;"
        },
        {
          "comment": "",
          "lineNum": 23,
          "modifiers": "",
          "type": "float",
          "name": "unity_ParticleUseMeshColors;",
          "code": "float unity_ParticleUseMeshColors;"
        }
      ]
    },
    {
      "file": "UnityStandardParticles.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_PARTICLES_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 5,
          "code": "#define _FLIPBOOK_BLENDING 1"
        },
        {
          "comment": "",
          "lineNum": 9,
          "code": "#define _DISTORTION_ON 1"
        },
        {
          "comment": "    // For inputs/outputs analysis SoftParticles and Fading are identical; so make sure to only keep one\n    // of them ever defined.",
          "lineNum": 34,
          "code": "        #define _FADING_ON"
        },
        {
          "comment": "",
          "lineNum": 128,
          "code": "#define SOFT_PARTICLE_NEAR_FADE _SoftParticleFadeParams.x"
        },
        {
          "comment": "",
          "lineNum": 129,
          "code": "#define SOFT_PARTICLE_INV_FADE_DISTANCE _SoftParticleFadeParams.y"
        },
        {
          "comment": "",
          "lineNum": 131,
          "code": "#define CAMERA_NEAR_FADE _CameraFadeParams.x"
        },
        {
          "comment": "",
          "lineNum": 132,
          "code": "#define CAMERA_INV_FADE_DISTANCE _CameraFadeParams.y"
        },
        {
          "comment": "// Color function",
          "lineNum": 165,
          "code": "#define vertColor(c) \\\n        vertInstancingColor(c);"
        },
        {
          "comment": "// Color function",
          "lineNum": 168,
          "code": "#define vertColor(c)"
        },
        {
          "comment": "// Flipbook vertex function",
          "lineNum": 174,
          "code": "    #define vertTexcoord(v, o) \\\n        vertInstancingUVs(v.texcoords.xy, o.texcoord, o.texcoord2AndBlend);"
        },
        {
          "comment": "// Flipbook vertex function",
          "lineNum": 177,
          "code": "    #define vertTexcoord(v, o) \\\n        vertInstancingUVs(v.texcoords.xy, o.texcoord); \\\n        o.texcoord = TRANSFORM_TEX(o.texcoord, _MainTex);"
        },
        {
          "comment": "// Flipbook vertex function",
          "lineNum": 183,
          "code": "    #define vertTexcoord(v, o) \\\n        o.texcoord = v.texcoords.xy; \\\n        o.texcoord2AndBlend.xy = v.texcoords.zw; \\\n        o.texcoord2AndBlend.z = v.texcoordBlend;"
        },
        {
          "comment": "// Flipbook vertex function",
          "lineNum": 188,
          "code": "    #define vertTexcoord(v, o) \\\n        o.texcoord = TRANSFORM_TEX(v.texcoords.xy, _MainTex);"
        },
        {
          "comment": "// Fading vertex function",
          "lineNum": 195,
          "code": "#define vertFading(o) \\\n    o.projectedPosition = ComputeScreenPos (clipPosition); \\\n    COMPUTE_EYEDEPTH(o.projectedPosition.z);"
        },
        {
          "comment": "// Fading vertex function",
          "lineNum": 199,
          "code": "#define vertFading(o)"
        },
        {
          "comment": "// Distortion vertex function",
          "lineNum": 204,
          "code": "#define vertDistortion(o) \\\n    o.grabPassPosition = ComputeGrabScreenPos (clipPosition);"
        },
        {
          "comment": "// Distortion vertex function",
          "lineNum": 207,
          "code": "#define vertDistortion(o)"
        },
        {
          "comment": "// Color blending fragment function",
          "lineNum": 212,
          "code": "#define fragColorMode(i) \\\n    albedo.rgb = lerp(1 - 2 * (1 - albedo.rgb) * (1 - i.color.rgb), 2 * albedo.rgb * i.color.rgb, step(albedo.rgb, 0.5)); \\\n    albedo.a *= i.color.a;"
        },
        {
          "comment": "// Color blending fragment function",
          "lineNum": 216,
          "code": "#define fragColorMode(i) \\\n    half3 aHSL = RGBtoHSV(albedo.rgb); \\\n    half3 bHSL = RGBtoHSV(i.color.rgb); \\\n    half3 rHSL = fixed3(bHSL.x, bHSL.y, aHSL.z); \\\n    albedo = fixed4(HSVtoRGB(rHSL), albedo.a * i.color.a);"
        },
        {
          "comment": "// Color blending fragment function",
          "lineNum": 222,
          "code": "#define fragColorMode(i) \\\n    albedo.rgb = albedo.rgb + i.color.rgb * _ColorAddSubDiff.x; \\\n    albedo.rgb = lerp(albedo.rgb, abs(albedo.rgb), _ColorAddSubDiff.y); \\\n    albedo.a *= i.color.a;"
        },
        {
          "comment": "// Color blending fragment function",
          "lineNum": 227,
          "code": "#define fragColorMode(i) \\\n    albedo *= i.color;"
        },
        {
          "comment": "// Pre-multiplied alpha helper",
          "lineNum": 233,
          "code": "#define ALBEDO_MUL albedo"
        },
        {
          "comment": "// Pre-multiplied alpha helper",
          "lineNum": 235,
          "code": "#define ALBEDO_MUL albedo.a"
        },
        {
          "comment": "// Soft particles fragment function",
          "lineNum": 240,
          "code": "#define fragSoftParticles(i) \\\n    float softParticlesFade = 1.0f; \\\n    if (SOFT_PARTICLE_NEAR_FADE > 0.0 || SOFT_PARTICLE_INV_FADE_DISTANCE > 0.0) \\\n    { \\\n        float sceneZ = LinearEyeDepth (SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projectedPosition))); \\\n        softParticlesFade = saturate (SOFT_PARTICLE_INV_FADE_DISTANCE * ((sceneZ - SOFT_PARTICLE_NEAR_FADE) - i.projectedPosition.z)); \\\n        ALBEDO_MUL *= softParticlesFade; \\\n    }"
        },
        {
          "comment": "// Soft particles fragment function",
          "lineNum": 249,
          "code": "#define fragSoftParticles(i) \\\n    float softParticlesFade = 1.0f;"
        },
        {
          "comment": "// Camera fading fragment function",
          "lineNum": 255,
          "code": "#define fragCameraFading(i) \\\n    float cameraFade = saturate((i.projectedPosition.z - CAMERA_NEAR_FADE) * CAMERA_INV_FADE_DISTANCE); \\\n    ALBEDO_MUL *= cameraFade;"
        },
        {
          "comment": "// Camera fading fragment function",
          "lineNum": 259,
          "code": "#define fragCameraFading(i) \\\n    float cameraFade = 1.0f;"
        },
        {
          "comment": "",
          "lineNum": 264,
          "code": "#define fragDistortion(i) \\\n    float4 grabPosUV = UNITY_PROJ_COORD(i.grabPassPosition); \\\n    grabPosUV.xy += normal.xy * _DistortionStrengthScaled * albedo.a; \\\n    half3 grabPass = tex2Dproj(_GrabTexture, grabPosUV).rgb; \\\n    albedo.rgb = lerp(grabPass, albedo.rgb, saturate(albedo.a - _DistortionBlend));"
        },
        {
          "comment": "",
          "lineNum": 270,
          "code": "#define fragDistortion(i)"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 93,
          "modifiers": "",
          "parameters": "sampler2D tex, Input IN",
          "type": "fixed4",
          "name": "readTexture",
          "code": "fixed4 readTexture(sampler2D tex, Input IN)\n{\n    fixed4 color = tex2D (tex, IN.texcoord);\n    #ifdef _FLIPBOOK_BLENDING\n    fixed4 color2 = tex2D(tex, IN.texcoord2AndBlend.xy);\n    color = lerp(color, color2, IN.texcoord2AndBlend.z);\n    #endif\n    return color;\n}"
        },
        {
          "comment": "",
          "lineNum": 103,
          "modifiers": "",
          "parameters": "sampler2D tex, VertexOutput IN",
          "type": "fixed4",
          "name": "readTexture",
          "code": "fixed4 readTexture(sampler2D tex, VertexOutput IN)\n{\n    fixed4 color = tex2D (tex, IN.texcoord);\n    #ifdef _FLIPBOOK_BLENDING\n    fixed4 color2 = tex2D(tex, IN.texcoord2AndBlend.xy);\n    color = lerp(color, color2, IN.texcoord2AndBlend.z);\n    #endif\n    return color;\n}"
        },
        {
          "comment": "",
          "lineNum": 145,
          "modifiers": "",
          "parameters": "half3 arg1",
          "type": "half3",
          "name": "RGBtoHSV",
          "code": "half3 RGBtoHSV(half3 arg1)\n{\n    half4 K = half4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    half4 P = lerp(half4(arg1.bg, K.wz), half4(arg1.gb, K.xy), step(arg1.b, arg1.g));\n    half4 Q = lerp(half4(P.xyw, arg1.r), half4(arg1.r, P.yzx), step(P.x, arg1.r));\n    half D = Q.x - min(Q.w, Q.y);\n    half E = 1e-10;\n    return half3(abs(Q.z + (Q.w - Q.y) / (6.0 * D + E)), D / (Q.x + E), Q.x);\n}"
        },
        {
          "comment": "",
          "lineNum": 155,
          "modifiers": "",
          "parameters": "half3 arg1",
          "type": "half3",
          "name": "HSVtoRGB",
          "code": "half3 HSVtoRGB(half3 arg1)\n{\n    half4 K = half4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    half3 P = abs(frac(arg1.xxx + K.xyz) * 6.0 - K.www);\n    return arg1.z * lerp(K.xxx, saturate(P - K.xxx), arg1.y);\n}"
        },
        {
          "comment": "",
          "lineNum": 273,
          "modifiers": "",
          "parameters": "inout appdata_particles v, out Input o",
          "type": "void",
          "name": "vert",
          "code": "void vert (inout appdata_particles v, out Input o)\n{\n    UNITY_INITIALIZE_OUTPUT(Input, o);\n    float4 clipPosition = UnityObjectToClipPos(v.vertex);\n\n    vertColor(v.color);\n    vertTexcoord(v, o);\n    vertFading(o);\n    vertDistortion(o);\n}"
        },
        {
          "comment": "",
          "lineNum": 284,
          "modifiers": "",
          "parameters": "Input IN, inout SurfaceOutputStandard o",
          "type": "void",
          "name": "surf",
          "code": "void surf (Input IN, inout SurfaceOutputStandard o)\n{\n    half4 albedo = readTexture (_MainTex, IN);\n    albedo *= _Color;\n\n    fragColorMode(IN);\n    fragSoftParticles(IN);\n    fragCameraFading(IN);\n\n    #if defined(_METALLICGLOSSMAP)\n    fixed2 metallicGloss = readTexture (_MetallicGlossMap, IN).ra * fixed2(1.0, _Glossiness);\n    #else\n    fixed2 metallicGloss = fixed2(_Metallic, _Glossiness);\n    #endif\n\n    #if defined(_NORMALMAP)\n    float3 normal = normalize (UnpackScaleNormal (readTexture (_BumpMap, IN), _BumpScale));\n    #else\n    float3 normal = float3(0,0,1);\n    #endif\n\n    #if defined(_EMISSION)\n    half3 emission = readTexture (_EmissionMap, IN).rgb * cameraFade * softParticlesFade;\n    #else\n    half3 emission = 0;\n    #endif\n\n    fragDistortion(IN);\n\n    o.Albedo = albedo.rgb;\n    #if defined(_NORMALMAP)\n    o.Normal = normal;\n    #endif\n    o.Emission = emission * _EmissionColor;\n    o.Metallic = metallicGloss.r;\n    o.Smoothness = metallicGloss.g;\n\n    #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON) || defined(_ALPHAOVERLAY_ON)\n    o.Alpha = albedo.a;\n    #else\n    o.Alpha = 1;\n    #endif\n\n    #if defined(_ALPHAMODULATE_ON)\n    o.Albedo = lerp(half3(1.0, 1.0, 1.0), albedo.rgb, albedo.a);\n    #endif\n\n    #if defined(_ALPHATEST_ON)\n    clip (albedo.a - _Cutoff + 0.0001);\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 336,
          "modifiers": "",
          "parameters": "appdata_particles v, out VertexOutput o",
          "type": "void",
          "name": "vertParticleUnlit",
          "code": "void vertParticleUnlit (appdata_particles v, out VertexOutput o)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n    float4 clipPosition = UnityObjectToClipPos(v.vertex);\n    o.vertex = clipPosition;\n    o.color = v.color;\n\n    vertColor(o.color);\n    vertTexcoord(v, o);\n    vertFading(o);\n    vertDistortion(o);\n\n    UNITY_TRANSFER_FOG(o, o.vertex);\n}"
        },
        {
          "comment": "",
          "lineNum": 354,
          "modifiers": "",
          "parameters": "VertexOutput IN",
          "type": "half4",
          "name": "fragParticleUnlit",
          "code": "half4 fragParticleUnlit (VertexOutput IN) : SV_Target\n{\n    half4 albedo = readTexture (_MainTex, IN);\n    albedo *= _Color;\n\n    fragColorMode(IN);\n    fragSoftParticles(IN);\n    fragCameraFading(IN);\n\n    #if defined(_NORMALMAP)\n    float3 normal = normalize (UnpackScaleNormal (readTexture (_BumpMap, IN), _BumpScale));\n    #else\n    float3 normal = float3(0,0,1);\n    #endif\n\n    #if defined(_EMISSION)\n    half3 emission = readTexture (_EmissionMap, IN).rgb;\n    #else\n    half3 emission = 0;\n    #endif\n\n    fragDistortion(IN);\n\n    half4 result = albedo;\n\n    #if defined(_ALPHAMODULATE_ON)\n    result.rgb = lerp(half3(1.0, 1.0, 1.0), albedo.rgb, albedo.a);\n    #endif\n\n    result.rgb += emission * _EmissionColor * cameraFade * softParticlesFade;\n\n    #if !defined(_ALPHABLEND_ON) && !defined(_ALPHAPREMULTIPLY_ON) && !defined(_ALPHAOVERLAY_ON)\n    result.a = 1;\n    #endif\n\n    #if defined(_ALPHATEST_ON)\n    clip (albedo.a - _Cutoff + 0.0001);\n    #endif\n\n    UNITY_APPLY_FOG_COLOR(IN.fogCoord, result, fixed4(0,0,0,0));\n    return result;\n}"
        }
      ],
      "structs": [
        {
          "comment": "// Vertex shader input",
          "lineNum": 40,
          "type": "struct",
          "name": "appdata_particles",
          "modifiers": "",
          "code": "struct appdata_particles\n{\n    float4 vertex : POSITION;\n    float3 normal : NORMAL;\n    fixed4 color : COLOR;\n    #if defined(_FLIPBOOK_BLENDING) && !defined(UNITY_PARTICLE_INSTANCING_ENABLED)\n    float4 texcoords : TEXCOORD0;\n    float texcoordBlend : TEXCOORD1;\n    #else\n    float2 texcoords : TEXCOORD0;\n    #endif\n    #if defined(_NORMALMAP)\n    float4 tangent : TANGENT;\n    #endif\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "// Surface shader input",
          "lineNum": 58,
          "type": "struct",
          "name": "Input",
          "modifiers": "",
          "code": "struct Input\n{\n    float4 color : COLOR;\n    float2 texcoord;\n    #if defined(_FLIPBOOK_BLENDING)\n    float3 texcoord2AndBlend;\n    #endif\n    #if defined(SOFTPARTICLES_ON) || defined(_FADING_ON)\n    float4 projectedPosition;\n    #endif\n    #if _DISTORTION_ON\n    float4 grabPassPosition;\n    #endif\n};"
        },
        {
          "comment": "// Non-surface shader v2f structure",
          "lineNum": 74,
          "type": "struct",
          "name": "VertexOutput",
          "modifiers": "",
          "code": "struct VertexOutput\n{\n    float4 vertex : SV_POSITION;\n    float4 color : COLOR;\n    UNITY_FOG_COORDS(0)\n    float2 texcoord : TEXCOORD1;\n    #if defined(_FLIPBOOK_BLENDING)\n    float3 texcoord2AndBlend : TEXCOORD2;\n    #endif\n    #if defined(SOFTPARTICLES_ON) || defined(_FADING_ON)\n    float4 projectedPosition : TEXCOORD3;\n    #endif\n    #if _DISTORTION_ON\n    float4 grabPassPosition : TEXCOORD4;\n    #endif\n    UNITY_VERTEX_OUTPUT_STEREO\n\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 113,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 114,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_ST;",
          "code": "float4 _MainTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 115,
          "modifiers": "",
          "type": "half4",
          "name": "_Color;",
          "code": "half4 _Color;"
        },
        {
          "comment": "",
          "lineNum": 116,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_BumpMap;",
          "code": "sampler2D _BumpMap;"
        },
        {
          "comment": "",
          "lineNum": 117,
          "modifiers": "",
          "type": "half",
          "name": "_BumpScale;",
          "code": "half _BumpScale;"
        },
        {
          "comment": "",
          "lineNum": 118,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_EmissionMap;",
          "code": "sampler2D _EmissionMap;"
        },
        {
          "comment": "",
          "lineNum": 119,
          "modifiers": "",
          "type": "half3",
          "name": "_EmissionColor;",
          "code": "half3 _EmissionColor;"
        },
        {
          "comment": "",
          "lineNum": 120,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MetallicGlossMap;",
          "code": "sampler2D _MetallicGlossMap;"
        },
        {
          "comment": "",
          "lineNum": 121,
          "modifiers": "",
          "type": "half",
          "name": "_Metallic;",
          "code": "half _Metallic;"
        },
        {
          "comment": "",
          "lineNum": 122,
          "modifiers": "",
          "type": "half",
          "name": "_Glossiness;",
          "code": "half _Glossiness;"
        },
        {
          "comment": "",
          "lineNum": 124,
          "modifiers": "",
          "type": "float4",
          "name": "_SoftParticleFadeParams;",
          "code": "float4 _SoftParticleFadeParams;"
        },
        {
          "comment": "",
          "lineNum": 125,
          "modifiers": "",
          "type": "float4",
          "name": "_CameraFadeParams;",
          "code": "float4 _CameraFadeParams;"
        },
        {
          "comment": "",
          "lineNum": 126,
          "modifiers": "",
          "type": "half",
          "name": "_Cutoff;",
          "code": "half _Cutoff;"
        },
        {
          "comment": "",
          "lineNum": 135,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_GrabTexture;",
          "code": "sampler2D _GrabTexture;"
        },
        {
          "comment": "",
          "lineNum": 136,
          "modifiers": "",
          "type": "half",
          "name": "_DistortionStrengthScaled;",
          "code": "half _DistortionStrengthScaled;"
        },
        {
          "comment": "",
          "lineNum": 137,
          "modifiers": "",
          "type": "half",
          "name": "_DistortionBlend;",
          "code": "half _DistortionBlend;"
        },
        {
          "comment": "",
          "lineNum": 141,
          "modifiers": "",
          "type": "half4",
          "name": "_ColorAddSubDiff;",
          "code": "half4 _ColorAddSubDiff;"
        }
      ]
    },
    {
      "file": "UnityStandardParticleShadow.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_PARTICLE_SHADOW_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 8,
          "code": "#define _FLIPBOOK_BLENDING 1"
        },
        {
          "comment": "",
          "lineNum": 18,
          "code": "    #define UNITY_STANDARD_USE_DITHER_MASK 1"
        },
        {
          "comment": "// Need to output UVs in shadow caster, since we need to sample texture and do clip/dithering based on it",
          "lineNum": 23,
          "code": "#define UNITY_STANDARD_USE_SHADOW_UVS 1"
        },
        {
          "comment": "// Has a non-empty shadow caster output struct (it's an error to have empty structs on some platforms...)",
          "lineNum": 28,
          "code": "#define UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT 1"
        },
        {
          "comment": "",
          "lineNum": 32,
          "code": "#define UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT 1"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 50,
          "modifiers": "",
          "parameters": "half2 uv",
          "type": "half",
          "name": "MetallicSetup_ShadowGetOneMinusReflectivity",
          "code": "half MetallicSetup_ShadowGetOneMinusReflectivity(half2 uv)\n{\n    half metallicity = _Metallic;\n    #ifdef _METALLICGLOSSMAP\n        metallicity = tex2D(_MetallicGlossMap, uv).r;\n    #endif\n    return OneMinusReflectivityFromMetallic(metallicity);\n}"
        },
        {
          "comment": "",
          "lineNum": 99,
          "modifiers": "",
          "parameters": "VertexInput v,    #ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT    out VertexOutputShadowCaster o,    #endif    #ifdef UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT    out VertexOutputStereoShadowCaster os,    #endif    out float4 opos : SV_POSITION",
          "type": "void",
          "name": "vertParticleShadowCaster",
          "code": "void vertParticleShadowCaster (VertexInput v,\n    #ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT\n    out VertexOutputShadowCaster o,\n    #endif\n    #ifdef UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT\n    out VertexOutputStereoShadowCaster os,\n    #endif\n    out float4 opos : SV_POSITION)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n    #ifdef UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT\n        UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(os);\n    #endif\n    TRANSFER_SHADOW_CASTER_NOPOS(o,opos)\n    #ifdef UNITY_STANDARD_USE_SHADOW_UVS\n        #ifdef _FLIPBOOK_BLENDING\n            #ifdef UNITY_PARTICLE_INSTANCING_ENABLED\n                vertInstancingUVs(v.texcoords.xy, o.texcoord, o.texcoord2AndBlend);\n            #else\n                o.texcoord = v.texcoords.xy;\n                o.texcoord2AndBlend.xy = v.texcoords.zw;\n                o.texcoord2AndBlend.z = v.texcoordBlend;\n            #endif\n        #else\n            #ifdef UNITY_PARTICLE_INSTANCING_ENABLED\n                vertInstancingUVs(v.texcoords.xy, o.texcoord);\n                o.texcoord = TRANSFORM_TEX(o.texcoord, _MainTex);\n            #else\n                o.texcoord = TRANSFORM_TEX(v.texcoords.xy, _MainTex);\n            #endif\n        #endif\n        o.color = v.color;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 134,
          "modifiers": "",
          "parameters": "#ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT    VertexOutputShadowCaster i#endif#ifdef UNITY_STANDARD_USE_DITHER_MASK    , UNITY_VPOS_TYPE vpos : VPOS#endif",
          "type": "half4",
          "name": "fragParticleShadowCaster",
          "code": "half4 fragParticleShadowCaster (\n#ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT\n    VertexOutputShadowCaster i\n#endif\n#ifdef UNITY_STANDARD_USE_DITHER_MASK\n    , UNITY_VPOS_TYPE vpos : VPOS\n#endif\n    ) : SV_Target\n{\n    #ifdef UNITY_STANDARD_USE_SHADOW_UVS\n        half alpha = tex2D(_MainTex, i.texcoord).a;\n        #ifdef _FLIPBOOK_BLENDING\n            half alpha2 = tex2D(_MainTex, i.texcoord2AndBlend.xy).a;\n            alpha = lerp(alpha, alpha2, i.texcoord2AndBlend.z);\n        #endif\n        alpha *= i.color.a;\n\n        #ifdef _ALPHATEST_ON\n            clip (alpha - _Cutoff);\n        #endif\n        #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)\n            #ifdef _ALPHAPREMULTIPLY_ON\n                half outModifiedAlpha;\n                PreMultiplyAlpha(half3(0, 0, 0), alpha, MetallicSetup_ShadowGetOneMinusReflectivity(i.texcoord), outModifiedAlpha);\n                alpha = outModifiedAlpha;\n            #endif\n            #ifdef UNITY_STANDARD_USE_DITHER_MASK\n                // Use dither mask for alpha blended shadows, based on pixel position xy\n                // and alpha level. Our dither texture is 4x4x16.\n                half alphaRef = tex3D(_DitherMaskLOD, float3(vpos.xy*0.25,alpha*0.9375)).a;\n                clip (alphaRef - 0.01);\n            #else\n                clip (alpha - 0.5);\n            #endif\n        #endif\n    #endif // UNITY_STANDARD_USE_SHADOW_UVS)\n\n    SHADOW_CASTER_FRAGMENT(i)\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 59,
          "type": "struct",
          "name": "VertexInput",
          "modifiers": "",
          "code": "struct VertexInput\n{\n    float4 vertex   : POSITION;\n    float3 normal   : NORMAL;\n    fixed4 color    : COLOR;\n    #if defined(_FLIPBOOK_BLENDING) && !defined(UNITY_PARTICLE_INSTANCING_ENABLED)\n        float4 texcoords : TEXCOORD0;\n        float texcoordBlend : TEXCOORD1;\n    #else\n        float2 texcoords : TEXCOORD0;\n    #endif\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 74,
          "type": "struct",
          "name": "VertexOutputShadowCaster",
          "modifiers": "",
          "code": "struct VertexOutputShadowCaster\n{\n    V2F_SHADOW_CASTER_NOPOS\n    #ifdef UNITY_STANDARD_USE_SHADOW_UVS\n        float2 texcoord : TEXCOORD1;\n        #ifdef _FLIPBOOK_BLENDING\n            float3 texcoord2AndBlend : TEXCOORD2;\n        #endif\n        fixed4 color : TEXCOORD3;\n    #endif\n};"
        },
        {
          "comment": "",
          "lineNum": 88,
          "type": "struct",
          "name": "VertexOutputStereoShadowCaster",
          "modifiers": "",
          "code": "struct VertexOutputStereoShadowCaster\n{\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 36,
          "modifiers": "",
          "type": "half",
          "name": "_Cutoff;",
          "code": "half        _Cutoff;"
        },
        {
          "comment": "",
          "lineNum": 38,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D   _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 39,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_ST;",
          "code": "float4      _MainTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 41,
          "modifiers": "",
          "type": "sampler3D",
          "name": "_DitherMaskLOD;",
          "code": "sampler3D   _DitherMaskLOD;"
        },
        {
          "comment": "// Handle PremultipliedAlpha from Fade or Transparent shading mode",
          "lineNum": 45,
          "modifiers": "",
          "type": "half",
          "name": "_Metallic;",
          "code": "half        _Metallic;"
        },
        {
          "comment": "// Handle PremultipliedAlpha from Fade or Transparent shading mode",
          "lineNum": 47,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MetallicGlossMap;",
          "code": "sampler2D   _MetallicGlossMap;"
        }
      ]
    },
    {
      "file": "UnityStandardShadow.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_SHADOW_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 14,
          "code": "    #define UNITY_STANDARD_USE_DITHER_MASK 1"
        },
        {
          "comment": "// Need to output UVs in shadow caster, since we need to sample texture and do clip/dithering based on it",
          "lineNum": 19,
          "code": "#define UNITY_STANDARD_USE_SHADOW_UVS 1"
        },
        {
          "comment": "// Has a non-empty shadow caster output struct (it's an error to have empty structs on some platforms...)",
          "lineNum": 24,
          "code": "#define UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT 1"
        },
        {
          "comment": "",
          "lineNum": 28,
          "code": "#define UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT 1"
        },
        {
          "comment": "// SHADOW_ONEMINUSREFLECTIVITY(): workaround to get one minus reflectivity based on UNITY_SETUP_BRDF_INPUT",
          "lineNum": 83,
          "code": "#define SHADOW_JOIN2(a, b) a##b"
        },
        {
          "comment": "// SHADOW_ONEMINUSREFLECTIVITY(): workaround to get one minus reflectivity based on UNITY_SETUP_BRDF_INPUT",
          "lineNum": 84,
          "code": "#define SHADOW_JOIN(a, b) SHADOW_JOIN2(a,b)"
        },
        {
          "comment": "// SHADOW_ONEMINUSREFLECTIVITY(): workaround to get one minus reflectivity based on UNITY_SETUP_BRDF_INPUT",
          "lineNum": 85,
          "code": "#define SHADOW_ONEMINUSREFLECTIVITY SHADOW_JOIN(UNITY_SETUP_BRDF_INPUT, _ShadowGetOneMinusReflectivity)"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 55,
          "modifiers": "",
          "parameters": "half2 uv",
          "type": "half",
          "name": "MetallicSetup_ShadowGetOneMinusReflectivity",
          "code": "half MetallicSetup_ShadowGetOneMinusReflectivity(half2 uv)\n{\n    half metallicity = _Metallic;\n    #ifdef _METALLICGLOSSMAP\n        metallicity = tex2D(_MetallicGlossMap, uv).r;\n    #endif\n    return OneMinusReflectivityFromMetallic(metallicity);\n}"
        },
        {
          "comment": "",
          "lineNum": 64,
          "modifiers": "",
          "parameters": "half2 uv",
          "type": "half",
          "name": "RoughnessSetup_ShadowGetOneMinusReflectivity",
          "code": "half RoughnessSetup_ShadowGetOneMinusReflectivity(half2 uv)\n{\n    half metallicity = _Metallic;\n#ifdef _METALLICGLOSSMAP\n    metallicity = tex2D(_MetallicGlossMap, uv).r;\n#endif\n    return OneMinusReflectivityFromMetallic(metallicity);\n}"
        },
        {
          "comment": "",
          "lineNum": 73,
          "modifiers": "",
          "parameters": "half2 uv",
          "type": "half",
          "name": "SpecularSetup_ShadowGetOneMinusReflectivity",
          "code": "half SpecularSetup_ShadowGetOneMinusReflectivity(half2 uv)\n{\n    half3 specColor = _SpecColor.rgb;\n    #ifdef _SPECGLOSSMAP\n        specColor = tex2D(_SpecGlossMap, uv).rgb;\n    #endif\n    return (1 - SpecularStrength(specColor));\n}"
        },
        {
          "comment": "",
          "lineNum": 124,
          "modifiers": "",
          "parameters": "VertexInput v    , out float4 opos : SV_POSITION    #ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT    , out VertexOutputShadowCaster o    #endif    #ifdef UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT    , out VertexOutputStereoShadowCaster os    #endif",
          "type": "void",
          "name": "vertShadowCaster",
          "code": "void vertShadowCaster (VertexInput v\n    , out float4 opos : SV_POSITION\n    #ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT\n    , out VertexOutputShadowCaster o\n    #endif\n    #ifdef UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT\n    , out VertexOutputStereoShadowCaster os\n    #endif\n)\n{\n    UNITY_SETUP_INSTANCE_ID(v);\n    #ifdef UNITY_STANDARD_USE_STEREO_SHADOW_OUTPUT_STRUCT\n        UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(os);\n    #endif\n    TRANSFER_SHADOW_CASTER_NOPOS(o,opos)\n    #if defined(UNITY_STANDARD_USE_SHADOW_UVS)\n        o.tex = TRANSFORM_TEX(v.uv0, _MainTex);\n\n        #ifdef _PARALLAXMAP\n            TANGENT_SPACE_ROTATION;\n            o.viewDirForParallax = mul (rotation, ObjSpaceViewDir(v.vertex));\n        #endif\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 149,
          "modifiers": "",
          "parameters": "UNITY_POSITION(vpos)#ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT    , VertexOutputShadowCaster i#endif",
          "type": "half4",
          "name": "fragShadowCaster",
          "code": "half4 fragShadowCaster (UNITY_POSITION(vpos)\n#ifdef UNITY_STANDARD_USE_SHADOW_OUTPUT_STRUCT\n    , VertexOutputShadowCaster i\n#endif\n) : SV_Target\n{\n    #if defined(UNITY_STANDARD_USE_SHADOW_UVS)\n        #if defined(_PARALLAXMAP) && (SHADER_TARGET >= 30)\n            half3 viewDirForParallax = normalize(i.viewDirForParallax);\n            fixed h = tex2D (_ParallaxMap, i.tex.xy).g;\n            half2 offset = ParallaxOffset1Step (h, _Parallax, viewDirForParallax);\n            i.tex.xy += offset;\n        #endif\n\n        #if defined(_SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A)\n            half alpha = _Color.a;\n        #else\n            half alpha = tex2D(_MainTex, i.tex.xy).a * _Color.a;\n        #endif\n        #if defined(_ALPHATEST_ON)\n            clip (alpha - _Cutoff);\n        #endif\n        #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)\n            #if defined(_ALPHAPREMULTIPLY_ON)\n                half outModifiedAlpha;\n                PreMultiplyAlpha(half3(0, 0, 0), alpha, SHADOW_ONEMINUSREFLECTIVITY(i.tex), outModifiedAlpha);\n                alpha = outModifiedAlpha;\n            #endif\n            #if defined(UNITY_STANDARD_USE_DITHER_MASK)\n                // Use dither mask for alpha blended shadows, based on pixel position xy\n                // and alpha level. Our dither texture is 4x4x16.\n                #ifdef LOD_FADE_CROSSFADE\n                    #define _LOD_FADE_ON_ALPHA\n                    alpha *= unity_LODFade.y;\n                #endif\n                half alphaRef = tex3D(_DitherMaskLOD, float3(vpos.xy*0.25,alpha*0.9375)).a;\n                clip (alphaRef - 0.01);\n            #else\n                clip (alpha - _Cutoff);\n            #endif\n        #endif\n    #endif // #if defined(UNITY_STANDARD_USE_SHADOW_UVS)\n\n    #ifdef LOD_FADE_CROSSFADE\n        #ifdef _LOD_FADE_ON_ALPHA\n            #undef _LOD_FADE_ON_ALPHA\n        #else\n            UnityApplyDitherCrossFade(vpos.xy);\n        #endif\n    #endif\n\n    SHADOW_CASTER_FRAGMENT(i)\n}"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 87,
          "type": "struct",
          "name": "VertexInput",
          "modifiers": "",
          "code": "struct VertexInput\n{\n    float4 vertex   : POSITION;\n    float3 normal   : NORMAL;\n    float2 uv0      : TEXCOORD0;\n    #if defined(UNITY_STANDARD_USE_SHADOW_UVS) && defined(_PARALLAXMAP)\n        half4 tangent   : TANGENT;\n    #endif\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 99,
          "type": "struct",
          "name": "VertexOutputShadowCaster",
          "modifiers": "",
          "code": "struct VertexOutputShadowCaster\n{\n    V2F_SHADOW_CASTER_NOPOS\n    #if defined(UNITY_STANDARD_USE_SHADOW_UVS)\n        float2 tex : TEXCOORD1;\n\n        #if defined(_PARALLAXMAP)\n            half3 viewDirForParallax : TEXCOORD2;\n        #endif\n    #endif\n};"
        },
        {
          "comment": "",
          "lineNum": 113,
          "type": "struct",
          "name": "VertexOutputStereoShadowCaster",
          "modifiers": "",
          "code": "struct VertexOutputStereoShadowCaster\n{\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 32,
          "modifiers": "",
          "type": "half4",
          "name": "_Color;",
          "code": "half4       _Color;"
        },
        {
          "comment": "",
          "lineNum": 33,
          "modifiers": "",
          "type": "half",
          "name": "_Cutoff;",
          "code": "half        _Cutoff;"
        },
        {
          "comment": "",
          "lineNum": 34,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D   _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 35,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_ST;",
          "code": "float4      _MainTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 37,
          "modifiers": "",
          "type": "sampler3D",
          "name": "_DitherMaskLOD;",
          "code": "sampler3D   _DitherMaskLOD;"
        },
        {
          "comment": "// Handle PremultipliedAlpha from Fade or Transparent shading mode",
          "lineNum": 41,
          "modifiers": "",
          "type": "half4",
          "name": "_SpecColor;",
          "code": "half4       _SpecColor;"
        },
        {
          "comment": "// Handle PremultipliedAlpha from Fade or Transparent shading mode",
          "lineNum": 42,
          "modifiers": "",
          "type": "half",
          "name": "_Metallic;",
          "code": "half        _Metallic;"
        },
        {
          "comment": "// Handle PremultipliedAlpha from Fade or Transparent shading mode",
          "lineNum": 44,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_SpecGlossMap;",
          "code": "sampler2D   _SpecGlossMap;"
        },
        {
          "comment": "// Handle PremultipliedAlpha from Fade or Transparent shading mode",
          "lineNum": 47,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MetallicGlossMap;",
          "code": "sampler2D   _MetallicGlossMap;"
        },
        {
          "comment": "",
          "lineNum": 51,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_ParallaxMap;",
          "code": "sampler2D   _ParallaxMap;"
        },
        {
          "comment": "",
          "lineNum": 52,
          "modifiers": "",
          "type": "half",
          "name": "_Parallax;",
          "code": "half        _Parallax;"
        }
      ]
    },
    {
      "file": "UnityStandardUtils.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_STANDARD_UTILS_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 9,
          "modifiers": "",
          "parameters": "half3 specular",
          "type": "half",
          "name": "SpecularStrength",
          "code": "half SpecularStrength(half3 specular)\n{\n    #if (SHADER_TARGET < 30)\n        // SM2.0: instruction count limitation\n        // SM2.0: simplified SpecularStrength\n        return specular.r; // Red channel - because most metals are either monocrhome or with redish/yellowish tint\n    #else\n        return max (max (specular.r, specular.g), specular.b);\n    #endif\n}"
        },
        {
          "comment": "// Diffuse/Spec Energy conservation",
          "lineNum": 21,
          "modifiers": "inline",
          "parameters": "half3 albedo, half3 specColor, out half oneMinusReflectivity",
          "type": "half3",
          "name": "EnergyConservationBetweenDiffuseAndSpecular",
          "code": "inline half3 EnergyConservationBetweenDiffuseAndSpecular (half3 albedo, half3 specColor, out half oneMinusReflectivity)\n{\n    oneMinusReflectivity = 1 - SpecularStrength(specColor);\n    #if !UNITY_CONSERVE_ENERGY\n        return albedo;\n    #elif UNITY_CONSERVE_ENERGY_MONOCHROME\n        return albedo * oneMinusReflectivity;\n    #else\n        return albedo * (half3(1,1,1) - specColor);\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 33,
          "modifiers": "inline",
          "parameters": "half metallic",
          "type": "half",
          "name": "OneMinusReflectivityFromMetallic",
          "code": "inline half OneMinusReflectivityFromMetallic(half metallic)\n{\n    // We'll need oneMinusReflectivity, so\n    //   1-reflectivity = 1-lerp(dielectricSpec, 1, metallic) = lerp(1-dielectricSpec, 0, metallic)\n    // store (1-dielectricSpec) in unity_ColorSpaceDielectricSpec.a, then\n    //   1-reflectivity = lerp(alpha, 0, metallic) = alpha + metallic*(0 - alpha) =\n    //                  = alpha - metallic * alpha\n    half oneMinusDielectricSpec = unity_ColorSpaceDielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}"
        },
        {
          "comment": "",
          "lineNum": 44,
          "modifiers": "inline",
          "parameters": "half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity",
          "type": "half3",
          "name": "DiffuseAndSpecularFromMetallic",
          "code": "inline half3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (unity_ColorSpaceDielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}"
        },
        {
          "comment": "",
          "lineNum": 51,
          "modifiers": "inline",
          "parameters": "half3 diffColor, half alpha, half oneMinusReflectivity, out half outModifiedAlpha",
          "type": "half3",
          "name": "PreMultiplyAlpha",
          "code": "inline half3 PreMultiplyAlpha (half3 diffColor, half alpha, half oneMinusReflectivity, out half outModifiedAlpha)\n{\n    #if defined(_ALPHAPREMULTIPLY_ON)\n        // NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)\n\n        // Transparency 'removes' from Diffuse component\n        diffColor *= alpha;\n\n        #if (SHADER_TARGET < 30)\n            // SM2.0: instruction count limitation\n            // Instead will sacrifice part of physically based transparency where amount Reflectivity is affecting Transparency\n            // SM2.0: uses unmodified alpha\n            outModifiedAlpha = alpha;\n        #else\n            // Reflectivity 'removes' from the rest of components, including Transparency\n            // outAlpha = 1-(1-alpha)*(1-reflectivity) = 1-(oneMinusReflectivity - alpha*oneMinusReflectivity) =\n            //          = 1-oneMinusReflectivity + alpha*oneMinusReflectivity\n            outModifiedAlpha = 1-oneMinusReflectivity + alpha*oneMinusReflectivity;\n        #endif\n    #else\n        outModifiedAlpha = alpha;\n    #endif\n    return diffColor;\n}"
        },
        {
          "comment": "// Same as ParallaxOffset in Unity CG, except:\n//  *) precision - half instead of float",
          "lineNum": 78,
          "modifiers": "",
          "parameters": "half h, half height, half3 viewDir",
          "type": "half2",
          "name": "ParallaxOffset1Step",
          "code": "half2 ParallaxOffset1Step (half h, half height, half3 viewDir)\n{\n    h = h * height - height/2.0;\n    half3 v = normalize(viewDir);\n    v.z += 0.42;\n    return h * (v.xy / v.z);\n}"
        },
        {
          "comment": "",
          "lineNum": 86,
          "modifiers": "",
          "parameters": "half b, half t",
          "type": "half",
          "name": "LerpOneTo",
          "code": "half LerpOneTo(half b, half t)\n{\n    half oneMinusT = 1 - t;\n    return oneMinusT + b * t;\n}"
        },
        {
          "comment": "",
          "lineNum": 92,
          "modifiers": "",
          "parameters": "half3 b, half t",
          "type": "half3",
          "name": "LerpWhiteTo",
          "code": "half3 LerpWhiteTo(half3 b, half t)\n{\n    half oneMinusT = 1 - t;\n    return half3(oneMinusT, oneMinusT, oneMinusT) + b * t;\n}"
        },
        {
          "comment": "",
          "lineNum": 98,
          "modifiers": "",
          "parameters": "half4 packednormal, half bumpScale",
          "type": "half3",
          "name": "UnpackScaleNormalDXT5nm",
          "code": "half3 UnpackScaleNormalDXT5nm(half4 packednormal, half bumpScale)\n{\n    half3 normal;\n    normal.xy = (packednormal.wy * 2 - 1);\n    #if (SHADER_TARGET >= 30)\n        // SM2.0: instruction count limitation\n        // SM2.0: normal scaler is not supported\n        normal.xy *= bumpScale;\n    #endif\n    normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}"
        },
        {
          "comment": "",
          "lineNum": 111,
          "modifiers": "",
          "parameters": "half4 packednormal, half bumpScale",
          "type": "half3",
          "name": "UnpackScaleNormalRGorAG",
          "code": "half3 UnpackScaleNormalRGorAG(half4 packednormal, half bumpScale)\n{\n    #if defined(UNITY_NO_DXT5nm)\n        half3 normal = packednormal.xyz * 2 - 1;\n        #if (SHADER_TARGET >= 30)\n            // SM2.0: instruction count limitation\n            // SM2.0: normal scaler is not supported\n            normal.xy *= bumpScale;\n        #endif\n        return normal;\n    #else\n        // This do the trick\n        packednormal.x *= packednormal.w;\n\n        half3 normal;\n        normal.xy = (packednormal.xy * 2 - 1);\n        #if (SHADER_TARGET >= 30)\n            // SM2.0: instruction count limitation\n            // SM2.0: normal scaler is not supported\n            normal.xy *= bumpScale;\n        #endif\n        normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n        return normal;\n    #endif\n}"
        },
        {
          "comment": "",
          "lineNum": 137,
          "modifiers": "",
          "parameters": "half4 packednormal, half bumpScale",
          "type": "half3",
          "name": "UnpackScaleNormal",
          "code": "half3 UnpackScaleNormal(half4 packednormal, half bumpScale)\n{\n    return UnpackScaleNormalRGorAG(packednormal, bumpScale);\n}"
        },
        {
          "comment": "",
          "lineNum": 142,
          "modifiers": "",
          "parameters": "half3 n1, half3 n2",
          "type": "half3",
          "name": "BlendNormals",
          "code": "half3 BlendNormals(half3 n1, half3 n2)\n{\n    return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n}"
        },
        {
          "comment": "",
          "lineNum": 147,
          "modifiers": "",
          "parameters": "half3 normal, half3 tangent, half tangentSign",
          "type": "half3x3",
          "name": "CreateTangentToWorldPerVertex",
          "code": "half3x3 CreateTangentToWorldPerVertex(half3 normal, half3 tangent, half tangentSign)\n{\n    // For odd-negative scale transforms we need to flip the sign\n    half sign = tangentSign * unity_WorldTransformParams.w;\n    half3 binormal = cross(normal, tangent) * sign;\n    return half3x3(tangent, binormal, normal);\n}"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------",
          "lineNum": 156,
          "modifiers": "",
          "parameters": "half3 normal, half3 ambient",
          "type": "half3",
          "name": "ShadeSHPerVertex",
          "code": "half3 ShadeSHPerVertex (half3 normal, half3 ambient)\n{\n    #if UNITY_SAMPLE_FULL_SH_PER_PIXEL\n        // Completely per-pixel\n        // nothing to do here\n    #elif (SHADER_TARGET < 30) || UNITY_STANDARD_SIMPLE\n        // Completely per-vertex\n        ambient += max(half3(0,0,0), ShadeSH9 (half4(normal, 1.0)));\n    #else\n        // L2 per-vertex, L0..L1 & gamma-correction per-pixel\n\n        // NOTE: SH data is always in Linear AND calculation is split between vertex & pixel\n        // Convert ambient to Linear and do final gamma-correction at the end (per-pixel)\n        #ifdef UNITY_COLORSPACE_GAMMA\n            ambient = GammaToLinearSpace (ambient);\n        #endif\n        ambient += SHEvalLinearL2 (half4(normal, 1.0));     // no max since this is only L2 contribution\n    #endif\n\n    return ambient;\n}"
        },
        {
          "comment": "",
          "lineNum": 178,
          "modifiers": "",
          "parameters": "half3 normal, half3 ambient, float3 worldPos",
          "type": "half3",
          "name": "ShadeSHPerPixel",
          "code": "half3 ShadeSHPerPixel (half3 normal, half3 ambient, float3 worldPos)\n{\n    half3 ambient_contrib = 0.0;\n\n    #if UNITY_SAMPLE_FULL_SH_PER_PIXEL\n        // Completely per-pixel\n        #if UNITY_LIGHT_PROBE_PROXY_VOLUME\n            if (unity_ProbeVolumeParams.x == 1.0)\n                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume(half4(normal, 1.0), worldPos);\n            else\n                ambient_contrib = SHEvalLinearL0L1(half4(normal, 1.0));\n        #else\n            ambient_contrib = SHEvalLinearL0L1(half4(normal, 1.0));\n        #endif\n\n            ambient_contrib += SHEvalLinearL2(half4(normal, 1.0));\n\n            ambient += max(half3(0, 0, 0), ambient_contrib);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            ambient = LinearToGammaSpace(ambient);\n        #endif\n    #elif (SHADER_TARGET < 30) || UNITY_STANDARD_SIMPLE\n        // Completely per-vertex\n        // nothing to do here. Gamma conversion on ambient from SH takes place in the vertex shader, see ShadeSHPerVertex.\n    #else\n        // L2 per-vertex, L0..L1 & gamma-correction per-pixel\n        // Ambient in this case is expected to be always Linear, see ShadeSHPerVertex()\n        #if UNITY_LIGHT_PROBE_PROXY_VOLUME\n            if (unity_ProbeVolumeParams.x == 1.0)\n                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume (half4(normal, 1.0), worldPos);\n            else\n                ambient_contrib = SHEvalLinearL0L1 (half4(normal, 1.0));\n        #else\n            ambient_contrib = SHEvalLinearL0L1 (half4(normal, 1.0));\n        #endif\n\n        ambient = max(half3(0, 0, 0), ambient+ambient_contrib);     // include L2 contribution in vertex shader before clamp.\n        #ifdef UNITY_COLORSPACE_GAMMA\n            ambient = LinearToGammaSpace (ambient);\n        #endif\n    #endif\n\n    return ambient;\n}"
        },
        {
          "comment": "//-------------------------------------------------------------------------------------",
          "lineNum": 225,
          "modifiers": "inline",
          "parameters": "float3 worldRefl, float3 worldPos, float4 cubemapCenter, float4 boxMin, float4 boxMax",
          "type": "float3",
          "name": "BoxProjectedCubemapDirection",
          "code": "inline float3 BoxProjectedCubemapDirection (float3 worldRefl, float3 worldPos, float4 cubemapCenter, float4 boxMin, float4 boxMax)\n{\n    // Do we have a valid reflection probe?\n    UNITY_BRANCH\n    if (cubemapCenter.w > 0.0)\n    {\n        float3 nrdir = normalize(worldRefl);\n\n        #if 1\n            float3 rbmax = (boxMax.xyz - worldPos) / nrdir;\n            float3 rbmin = (boxMin.xyz - worldPos) / nrdir;\n\n            float3 rbminmax = (nrdir > 0.0f) ? rbmax : rbmin;\n\n        #else // Optimized version\n            float3 rbmax = (boxMax.xyz - worldPos);\n            float3 rbmin = (boxMin.xyz - worldPos);\n\n            float3 select = step (float3(0,0,0), nrdir);\n            float3 rbminmax = lerp (rbmax, rbmin, select);\n            rbminmax /= nrdir;\n        #endif\n\n        float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\n        worldPos -= cubemapCenter.xyz;\n        worldRefl = worldPos + nrdir * fa;\n    }\n    return worldRefl;\n}"
        },
        {
          "comment": "// Project the surface gradient (dhdx, dhdy) onto the surface (n, dpdx, dpdy)",
          "lineNum": 263,
          "modifiers": "",
          "parameters": "half3 n, half3 dpdx, half3 dpdy, half dhdx, half dhdy",
          "type": "half3",
          "name": "CalculateSurfaceGradient",
          "code": "half3 CalculateSurfaceGradient(half3 n, half3 dpdx, half3 dpdy, half dhdx, half dhdy)\n{\n    half3 r1 = cross(dpdy, n);\n    half3 r2 = cross(n, dpdx);\n    return (r1 * dhdx + r2 * dhdy) / dot(dpdx, r1);\n}"
        },
        {
          "comment": "// Move the normal away from the surface normal in the opposite surface gradient direction",
          "lineNum": 271,
          "modifiers": "",
          "parameters": "half3 n, half3 dpdx, half3 dpdy, half dhdx, half dhdy",
          "type": "half3",
          "name": "PerturbNormal",
          "code": "half3 PerturbNormal(half3 n, half3 dpdx, half3 dpdy, half dhdx, half dhdy)\n{\n    //TODO: normalize seems to be necessary when scales do go beyond the 2...-2 range, should we limit that?\n    //how expensive is a normalize? Anything cheaper for this case?\n    return normalize(n - CalculateSurfaceGradient(n, dpdx, dpdy, dhdx, dhdy));\n}"
        },
        {
          "comment": "// Calculate the surface normal using the uv-space gradient (dhdu, dhdv)",
          "lineNum": 279,
          "modifiers": "",
          "parameters": "half3 position, half3 normal, half2 gradient, half2 uv",
          "type": "half3",
          "name": "CalculateSurfaceNormal",
          "code": "half3 CalculateSurfaceNormal(half3 position, half3 normal, half2 gradient, half2 uv)\n{\n    half3 dpdx = ddx(position);\n    half3 dpdy = ddy(position);\n\n    half dhdx = dot(gradient, ddx(uv));\n    half dhdy = dot(gradient, ddy(uv));\n\n    return PerturbNormal(normal, dpdx, dpdy, dhdx, dhdy);\n}"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnityUI.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_UI_INCLUDED"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 4,
          "modifiers": "inline",
          "parameters": "in float2 position, in float4 clipRect",
          "type": "float",
          "name": "UnityGet2DClipping",
          "code": "inline float UnityGet2DClipping (in float2 position, in float4 clipRect)\n{\n    float2 inside = step(clipRect.xy, position.xy) * step(position.xy, clipRect.zw);\n    return inside.x * inside.y;\n}"
        },
        {
          "comment": "",
          "lineNum": 10,
          "modifiers": "inline",
          "parameters": "in float2 position, in sampler2D mainTexture, in sampler2D alphaTexture, fixed4 textureSampleAdd",
          "type": "fixed4",
          "name": "UnityGetUIDiffuseColor",
          "code": "inline fixed4 UnityGetUIDiffuseColor(in float2 position, in sampler2D mainTexture, in sampler2D alphaTexture, fixed4 textureSampleAdd)\n{\n    return fixed4(tex2D(mainTexture, position).rgb + textureSampleAdd.rgb, tex2D(alphaTexture, position).r + textureSampleAdd.a);\n}"
        }
      ],
      "structs": [],
      "variables": []
    },
    {
      "file": "UnityUIE.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define UNITY_UIE_INCLUDED"
        },
        {
          "comment": "",
          "lineNum": 6,
          "code": "        #define UIE_SKIN_USING_CONSTANTS"
        },
        {
          "comment": "// The value below is only used on older shader targets, and should be configurable for the app at hand to be the smallest possible",
          "lineNum": 12,
          "code": "#define UIE_SKIN_ELEMS_COUNT_MAX_CONSTANTS 20"
        }
      ],
      "functions": [
        {
          "comment": "// Returns the view-space offset that must be applied to the vertex to satisfy a minimum displacement constraint.\n// vertex               Coordinates of the vertex, in vertex-space.\n// embeddedDisplacement Displacement vector that is embedded in vertex, in vertex-space.\n// minDisplacement      Minimum length of the displacement that must be observed, in pixels.",
          "lineNum": 99,
          "modifiers": "",
          "parameters": "float4 vertex, float2 embeddedDisplacement, float minDisplacement",
          "type": "float2",
          "name": "uie_get_border_offset",
          "code": "float2 uie_get_border_offset(float4 vertex, float2 embeddedDisplacement, float minDisplacement)\n{\n    // Compute the displacement length in framebuffer space (unit = 1 pixel).\n    float2 viewDisplacement = mul(uie_toWorldMat, float4(embeddedDisplacement, 0, 0)).xy;\n    float frameDisplacementLength = length(viewDisplacement * _1PixelClipInvView.zw);\n\n    // We need to meet the minimum displacement requirement before rounding so that we can simply add 1 after rounding\n    // if we don't meet it anymore.\n    float newFrameDisplacementLength = max(minDisplacement, frameDisplacementLength);\n    newFrameDisplacementLength = round(newFrameDisplacementLength);\n    newFrameDisplacementLength += step(newFrameDisplacementLength, minDisplacement - 0.001);\n\n    // Convert the resulting displacement into an offset.\n    float changeRatio = newFrameDisplacementLength / (frameDisplacementLength + 0.000001);\n    float2 viewOffset = (changeRatio - 1) * viewDisplacement;\n\n    return viewOffset;\n}"
        },
        {
          "comment": "",
          "lineNum": 118,
          "modifiers": "",
          "parameters": "float2 clipSpaceXY",
          "type": "float2",
          "name": "uie_snap_to_integer_pos",
          "code": "float2 uie_snap_to_integer_pos(float2 clipSpaceXY)\n{\n    return ((int2)((clipSpaceXY+1)/_1PixelClipInvView.xy+0.51f)) * _1PixelClipInvView.xy-1;\n}"
        },
        {
          "comment": "",
          "lineNum": 123,
          "modifiers": "",
          "parameters": "v2f IN",
          "type": "void",
          "name": "uie_fragment_clip",
          "code": "void uie_fragment_clip(v2f IN)\n{\n    float2 pointPos = IN.uvXY.zw;\n    float2 pixelPos = IN.vertex.xy;\n    float2 s = step(IN.clipRect.xy,   pointPos) + step(pointPos, IN.clipRect.zw) +\n               step(_PixelClipRect.xy, pixelPos)  + step(pixelPos, _PixelClipRect.zw);\n    clip(dot(float3(s,1),float3(1,1,-7.95f)));\n}"
        },
        {
          "comment": "",
          "lineNum": 132,
          "modifiers": "",
          "parameters": "appdata_t v",
          "type": "void",
          "name": "uie_vert_load_payload",
          "code": "void uie_vert_load_payload(appdata_t v)\n{\n#ifdef UIE_SKIN_USING_CONSTANTS\n\n    uie_toWorldMat = float3x4(\n        _Transforms[v.xformIDsAndFlags.x * 4 + 0],\n        _Transforms[v.xformIDsAndFlags.x * 4 + 1],\n        _Transforms[v.xformIDsAndFlags.x * 4 + 2]);\n    uie_clipRect = _Transforms[v.xformIDsAndFlags.y * 4 + 3];\n\n#else // !UIE_SKIN_USING_CONSTANTS\n\n    Transform3x4 transform = _TransformsBuffer[v.xformIDsAndFlags.x];\n    uie_toWorldMat = float3x4(transform.v0, transform.v1, transform.v2);\n    uie_clipRect = _TransformsBuffer[v.xformIDsAndFlags.y].clipRect;\n\n#endif // UIE_SKIN_USING_CONSTANTS\n}"
        },
        {
          "comment": "",
          "lineNum": 151,
          "modifiers": "",
          "parameters": "float value, inout float flags",
          "type": "float",
          "name": "TestForValue",
          "code": "float TestForValue(float value, inout float flags)\n{\n#if SHADER_API_GLES\n    float result = saturate(flags - value + 1.0);\n    flags -= result * value;\n    return result;\n#else\n    return flags == value;\n#endif\n}"
        },
        {
          "comment": "",
          "lineNum": 162,
          "modifiers": "",
          "parameters": "appdata_t v",
          "type": "v2f",
          "name": "uie_std_vert",
          "code": "v2f uie_std_vert(appdata_t v)\n{\n    v2f OUT;\n    UNITY_SETUP_INSTANCE_ID(v);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);\n\n    uie_vert_load_payload(v);\n    float flags = v.xformIDsAndFlags.z;\n    // Keep the descending order for GLES2\n    const float isSVGGradients = TestForValue(5.0, flags);\n    const float isEdge = TestForValue(4.0, flags);\n    const float isCustom = TestForValue(3.0, flags);\n    const float isTextured = TestForValue(2.0, flags);\n    const float isText = TestForValue(1.0, flags);\n\n    float2 viewOffset = float2(0, 0);\n    if (isEdge == 1)\n        viewOffset = uie_get_border_offset(v.vertex, v.uv, 1);\n\n    v.vertex.xyz = mul(uie_toWorldMat, v.vertex);\n    v.vertex.xy += viewOffset;\n\n    OUT.uvXY.zw = v.vertex.xy;\n    OUT.vertex = UnityObjectToClipPos(v.vertex);\n\n    if (isText == 1)\n        OUT.vertex.xy = uie_snap_to_integer_pos(OUT.vertex.xy);\n\n    OUT.uvXY.xy = TRANSFORM_TEX(v.uv, _MainTex);\n    if (isTextured == 1.0f && isCustom == 0.0f)\n        OUT.uvXY.xy *= _MainTex_TexelSize.xy;\n    OUT.color = v.color * _Color;\n    OUT.flags = fixed4(isText, isTextured, isCustom, 1 - saturate(isText + isTextured + isCustom));\n    OUT.clipRect = uie_clipRect; // In points\n\n    return OUT;\n}"
        },
        {
          "comment": "",
          "lineNum": 200,
          "modifiers": "",
          "parameters": "v2f IN",
          "type": "fixed4",
          "name": "uie_std_frag",
          "code": "fixed4 uie_std_frag(v2f IN)\n{\n    uie_fragment_clip(IN);\n\n    // Extract the flags.\n    fixed isText     = IN.flags.x;\n    fixed isTextured = IN.flags.y;\n    fixed isCustom   = IN.flags.z;\n    fixed isSolid    = IN.flags.w;\n    float2 uv = IN.uvXY.xy;\n\n    half4 atlasColor = tex2D(_MainTex, uv) * isTextured;\n    half4 fontColor = half4(1, 1, 1, tex2D(_FontTex, uv).a) * isText;\n    half4 customColor = tex2D(_CustomTex, uv) * isCustom;\n\n    half4 texColor = (half4)isSolid + atlasColor + fontColor + customColor;\n    half4 color = texColor * IN.color;\n    return color;\n}"
        },
        {
          "comment": "",
          "lineNum": 222,
          "modifiers": "",
          "parameters": "appdata_t v) { return uie_std_vert(v",
          "type": "v2f",
          "name": "vert",
          "code": "v2f vert(appdata_t v) { return uie_std_vert(v); }"
        },
        {
          "comment": "",
          "lineNum": 223,
          "modifiers": "",
          "parameters": "v2f IN) : SV_Target { return uie_std_frag(IN",
          "type": "fixed4",
          "name": "frag",
          "code": "fixed4 frag(v2f IN) : SV_Target { return uie_std_frag(IN); }"
        }
      ],
      "structs": [
        {
          "comment": "",
          "lineNum": 39,
          "type": "struct",
          "name": "Transform3x4  float4 v0, v1, v2, clipRect; };",
          "modifiers": "Transform3x4  float4 v0, v1, v2, clipRect; };",
          "code": "struct Transform3x4 { float4 v0, v1, v2, clipRect; };"
        },
        {
          "comment": "",
          "lineNum": 45,
          "type": "struct",
          "name": "appdata_t",
          "modifiers": "",
          "code": "struct appdata_t\n{\n    float4 vertex   : POSITION;\n    float4 color    : COLOR;\n    float2 uv       : TEXCOORD0;\n    float3 xformIDsAndFlags : TEXCOORD1; // transformID,clipRectID,Flags\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n};"
        },
        {
          "comment": "",
          "lineNum": 54,
          "type": "struct",
          "name": "v2f",
          "modifiers": "",
          "code": "struct v2f\n{\n    float4 vertex   : SV_POSITION;\n    fixed4 color    : COLOR;\n    float4 uvXY  : TEXCOORD0; // UV and ZW holds XY position in points\n    nointerpolation fixed4 flags : TEXCOORD1;\n    nointerpolation fixed4 clipRect : TEXCOORD2;\n    UNITY_VERTEX_OUTPUT_STEREO\n};"
        }
      ],
      "variables": [
        {
          "comment": "",
          "lineNum": 17,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_MainTex;",
          "code": "sampler2D _MainTex;"
        },
        {
          "comment": "",
          "lineNum": 18,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_ST;",
          "code": "float4 _MainTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 19,
          "modifiers": "",
          "type": "float4",
          "name": "_MainTex_TexelSize;",
          "code": "float4 _MainTex_TexelSize;"
        },
        {
          "comment": "",
          "lineNum": 21,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_FontTex;",
          "code": "sampler2D _FontTex;"
        },
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "",
          "type": "float4",
          "name": "_FontTex_ST;",
          "code": "float4 _FontTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 24,
          "modifiers": "",
          "type": "sampler2D",
          "name": "_CustomTex;",
          "code": "sampler2D _CustomTex;"
        },
        {
          "comment": "",
          "lineNum": 25,
          "modifiers": "",
          "type": "float4",
          "name": "_CustomTex_ST;",
          "code": "float4 _CustomTex_ST;"
        },
        {
          "comment": "",
          "lineNum": 27,
          "modifiers": "",
          "type": "fixed4",
          "name": "_Color;",
          "code": "fixed4 _Color;"
        },
        {
          "comment": "",
          "lineNum": 28,
          "modifiers": "",
          "type": "float4",
          "name": "_1PixelClipInvView;",
          "code": "float4 _1PixelClipInvView; // xy in clip space, zw inverse in view space"
        },
        {
          "comment": "",
          "lineNum": 29,
          "modifiers": "",
          "type": "float4",
          "name": "_PixelClipRect;",
          "code": "float4 _PixelClipRect; // In framebuffer space"
        },
        {
          "comment": "",
          "lineNum": 34,
          "modifiers": "* 4]",
          "type": "float4",
          "name": "_Transforms[UIE_SKIN_ELEMS_COUNT_MAX_CONSTANTS",
          "code": "float4 _Transforms[UIE_SKIN_ELEMS_COUNT_MAX_CONSTANTS * 4]; // 3 float4s map to matrix 3 columns (the projection column is ignored), and a float4 representing a clip rectangle"
        },
        {
          "comment": "",
          "lineNum": 40,
          "modifiers": "",
          "type": "StructuredBuffer<Transform3x4>",
          "name": "_TransformsBuffer;",
          "code": "StructuredBuffer<Transform3x4> _TransformsBuffer; // 3 float4s map to matrix 3 columns (the projection column is ignored), and a float4 representing a clip rectangle"
        },
        {
          "comment": "",
          "lineNum": 64,
          "modifiers": "static const   = 6.0f",
          "type": "float",
          "name": "kUIEVertexLastFlagValue",
          "code": "static const float kUIEVertexLastFlagValue = 6.0f; // Keep in track with UIR.VertexFlags"
        },
        {
          "comment": "",
          "lineNum": 92,
          "modifiers": "static",
          "type": "float3x4",
          "name": "uie_toWorldMat;",
          "code": "static float3x4 uie_toWorldMat;"
        },
        {
          "comment": "",
          "lineNum": 93,
          "modifiers": "static",
          "type": "float4",
          "name": "uie_clipRect;",
          "code": "static float4 uie_clipRect;"
        }
      ]
    },
    {
      "file": "AutoLight.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define AUTOLIGHT_INCLUDED"
        },
        {
          "comment": "// If none of the keywords are defined, assume directional?",
          "lineNum": 13,
          "code": "    #define DIRECTIONAL"
        },
        {
          "comment": "",
          "lineNum": 21,
          "code": "        #define TRANSFER_SHADOW(a) a._ShadowCoord = mul( unity_WorldToShadow[0], mul( unity_ObjectToWorld, v.vertex ) );"
        },
        {
          "comment": "",
          "lineNum": 40,
          "code": "        #define TRANSFER_SHADOW(a) a._ShadowCoord = ComputeScreenPos(a.pos);"
        },
        {
          "comment": "",
          "lineNum": 49,
          "code": "    #define SHADOW_COORDS(idx1) unityShadowCoord4 _ShadowCoord : TEXCOORD##idx1;"
        },
        {
          "comment": "",
          "lineNum": 50,
          "code": "    #define SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)"
        },
        {
          "comment": "",
          "lineNum": 186,
          "code": "#define DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(worldPos, 1))"
        },
        {
          "comment": "",
          "lineNum": 188,
          "code": "#define DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = input._LightCoord"
        },
        {
          "comment": "// ---- Spot light shadows",
          "lineNum": 237,
          "code": "#define SHADOW_COORDS(idx1) unityShadowCoord4 _ShadowCoord : TEXCOORD##idx1;"
        },
        {
          "comment": "// ---- Spot light shadows",
          "lineNum": 238,
          "code": "#define TRANSFER_SHADOW(a) a._ShadowCoord = mul (unity_WorldToShadow[0], mul(unity_ObjectToWorld,v.vertex));"
        },
        {
          "comment": "// ---- Spot light shadows",
          "lineNum": 239,
          "code": "#define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord)"
        },
        {
          "comment": "// ---- Point light shadows",
          "lineNum": 244,
          "code": "#define SHADOW_COORDS(idx1) unityShadowCoord3 _ShadowCoord : TEXCOORD##idx1;"
        },
        {
          "comment": "// ---- Point light shadows",
          "lineNum": 245,
          "code": "#define TRANSFER_SHADOW(a) a._ShadowCoord.xyz = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz;"
        },
        {
          "comment": "// ---- Point light shadows",
          "lineNum": 246,
          "code": "#define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord)"
        },
        {
          "comment": "// ---- Point light shadows",
          "lineNum": 247,
          "code": "#define READ_SHADOW_COORDS(a) unityShadowCoord4(a._ShadowCoord.xyz, 1.0)"
        },
        {
          "comment": "// ---- Shadows off",
          "lineNum": 252,
          "code": "#define SHADOW_COORDS(idx1)"
        },
        {
          "comment": "// ---- Shadows off",
          "lineNum": 253,
          "code": "#define TRANSFER_SHADOW(a)"
        },
        {
          "comment": "// ---- Shadows off",
          "lineNum": 254,
          "code": "#define SHADOW_ATTENUATION(a) 1.0"
        },
        {
          "comment": "// ---- Shadows off",
          "lineNum": 255,
          "code": "#define READ_SHADOW_COORDS(a) 0"
        },
        {
          "comment": "// ---- Shadows off",
          "lineNum": 258,
          "code": "#define READ_SHADOW_COORDS(a) a._ShadowCoord"
        },
        {
          "comment": "",
          "lineNum": 292,
          "code": "#define UNITY_LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) UNITY_SHADOW_COORDS(idx2)"
        },
        {
          "comment": "",
          "lineNum": 293,
          "code": "#define LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) SHADOW_COORDS(idx2)"
        },
        {
          "comment": "",
          "lineNum": 294,
          "code": "#define UNITY_TRANSFER_LIGHTING(a, coord) COMPUTE_LIGHT_COORDS(a) UNITY_TRANSFER_SHADOW(a, coord)"
        },
        {
          "comment": "",
          "lineNum": 295,
          "code": "#define TRANSFER_VERTEX_TO_FRAGMENT(a) COMPUTE_LIGHT_COORDS(a) TRANSFER_SHADOW(a)"
        }
      ],
      "functions": [
        {
          "comment": "",
          "lineNum": 22,
          "modifiers": "inline",
          "parameters": "unityShadowCoord4 shadowCoord",
          "type": "fixed",
          "name": "unitySampleShadow",
          "code": "        inline fixed unitySampleShadow (unityShadowCoord4 shadowCoord)\n        {\n            #if defined(SHADOWS_NATIVE)\n                fixed shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture, shadowCoord.xyz);\n                shadow = _LightShadowData.r + shadow * (1-_LightShadowData.r);\n                return shadow;\n            #else\n                unityShadowCoord dist = SAMPLE_DEPTH_TEXTURE(_ShadowMapTexture, shadowCoord.xy);\n                // tegra is confused if we use _LightShadowData.x directly\n                // with \"ambiguous overloaded function reference max(mediump float, float)\"\n                unityShadowCoord lightShadowDataX = _LightShadowData.x;\n                unityShadowCoord threshold = shadowCoord.z;\n                return max(dist > threshold, lightShadowDataX);\n            #endif\n        }"
        },
        {
          "comment": "",
          "lineNum": 41,
          "modifiers": "inline",
          "parameters": "unityShadowCoord4 shadowCoord",
          "type": "fixed",
          "name": "unitySampleShadow",
          "code": "        inline fixed unitySampleShadow (unityShadowCoord4 shadowCoord)\n        {\n            fixed shadow = UNITY_SAMPLE_SCREEN_SHADOW(_ShadowMapTexture, shadowCoord);\n            return shadow;\n        }"
        },
        {
          "comment": "",
          "lineNum": 59,
          "modifiers": "",
          "parameters": "float2 lightmapUV, float3 worldPos, float4 screenPos",
          "type": "half",
          "name": "UnityComputeForwardShadows",
          "code": "half UnityComputeForwardShadows(float2 lightmapUV, float3 worldPos, float4 screenPos)\n{\n    //fade value\n    float zDist = dot(_WorldSpaceCameraPos - worldPos, UNITY_MATRIX_V[2].xyz);\n    float fadeDist = UnityComputeShadowFadeDistance(worldPos, zDist);\n    half  realtimeToBakedShadowFade = UnityComputeShadowFade(fadeDist);\n\n    //baked occlusion if any\n    half shadowMaskAttenuation = UnitySampleBakedOcclusion(lightmapUV, worldPos);\n\n    half realtimeShadowAttenuation = 1.0f;\n    //directional realtime shadow\n    #if defined (SHADOWS_SCREEN)\n        #if defined(UNITY_NO_SCREENSPACE_SHADOWS) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n            realtimeShadowAttenuation = unitySampleShadow(mul(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1)));\n        #else\n            //Only reached when LIGHTMAP_ON is NOT defined (and thus we use interpolator for screenPos rather than lightmap UVs). See HANDLE_SHADOWS_BLENDING_IN_GI below.\n            realtimeShadowAttenuation = unitySampleShadow(screenPos);\n        #endif\n    #endif\n\n    #if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) && defined(SHADOWS_SOFT) && !defined(LIGHTMAP_SHADOW_MIXING)\n    //avoid expensive shadows fetches in the distance where coherency will be good\n    UNITY_BRANCH\n    if (realtimeToBakedShadowFade < (1.0f - 1e-2f))\n    {\n    #endif\n\n        //spot realtime shadow\n        #if (defined (SHADOWS_DEPTH) && defined (SPOT))\n            #if !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n                unityShadowCoord4 spotShadowCoord = mul(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1));\n            #else\n                unityShadowCoord4 spotShadowCoord = screenPos;\n            #endif\n            realtimeShadowAttenuation = UnitySampleShadowmap(spotShadowCoord);\n        #endif\n\n        //point realtime shadow\n        #if defined (SHADOWS_CUBE)\n            realtimeShadowAttenuation = UnitySampleShadowmap(worldPos - _LightPositionRange.xyz);\n        #endif\n\n    #if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) && defined(SHADOWS_SOFT) && !defined(LIGHTMAP_SHADOW_MIXING)\n    }\n    #endif\n\n    return UnityMixRealtimeAndBakedShadows(realtimeShadowAttenuation, shadowMaskAttenuation, realtimeToBakedShadowFade);\n}"
        },
        {
          "comment": "",
          "lineNum": 177,
          "modifiers": "inline",
          "parameters": "unityShadowCoord4 LightCoord",
          "type": "fixed",
          "name": "UnitySpotCookie",
          "code": "inline fixed UnitySpotCookie(unityShadowCoord4 LightCoord)\n{\n    return tex2D(_LightTexture0, LightCoord.xy / LightCoord.w + 0.5).w;\n}"
        },
        {
          "comment": "",
          "lineNum": 181,
          "modifiers": "inline",
          "parameters": "unityShadowCoord3 LightCoord",
          "type": "fixed",
          "name": "UnitySpotAttenuate",
          "code": "inline fixed UnitySpotAttenuate(unityShadowCoord3 LightCoord)\n{\n    return tex2D(_LightTextureB0, dot(LightCoord, LightCoord).xx).r;\n}"
        }
      ],
      "structs": [],
      "variables": [
        {
          "comment": "",
          "lineNum": 165,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "_LightTexture0;",
          "code": "sampler2D_float _LightTexture0;"
        },
        {
          "comment": "",
          "lineNum": 166,
          "modifiers": "",
          "type": "unityShadowCoord4x4",
          "name": "unity_WorldToLight;",
          "code": "unityShadowCoord4x4 unity_WorldToLight;"
        },
        {
          "comment": "",
          "lineNum": 168,
          "assignment": "= mul(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz; \\",
          "modifiers": "",
          "type": "unityShadowCoord3",
          "name": "lightCoord",
          "code": "unityShadowCoord3 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz; \\"
        },
        {
          "comment": "",
          "lineNum": 169,
          "assignment": "= UNITY_SHADOW_ATTENUATION(input, worldPos); \\",
          "modifiers": "",
          "type": "fixed",
          "name": "shadow",
          "code": "fixed shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \\"
        },
        {
          "comment": "",
          "lineNum": 170,
          "assignment": "= tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).r * shadow;",
          "modifiers": "",
          "type": "fixed",
          "name": "destName",
          "code": "fixed destName = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).r * shadow;"
        },
        {
          "comment": "",
          "lineNum": 174,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "_LightTexture0;",
          "code": "sampler2D_float _LightTexture0;"
        },
        {
          "comment": "",
          "lineNum": 175,
          "modifiers": "",
          "type": "unityShadowCoord4x4",
          "name": "unity_WorldToLight;",
          "code": "unityShadowCoord4x4 unity_WorldToLight;"
        },
        {
          "comment": "",
          "lineNum": 176,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "_LightTextureB0;",
          "code": "sampler2D_float _LightTextureB0;"
        },
        {
          "comment": "",
          "lineNum": 192,
          "assignment": "= UNITY_SHADOW_ATTENUATION(input, worldPos); \\",
          "modifiers": "",
          "type": "fixed",
          "name": "shadow",
          "code": "fixed shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \\"
        },
        {
          "comment": "",
          "lineNum": 193,
          "assignment": "= (lightCoord.z > 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz) * shadow;",
          "modifiers": "",
          "type": "fixed",
          "name": "destName",
          "code": "fixed destName = (lightCoord.z > 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz) * shadow;"
        },
        {
          "comment": "",
          "lineNum": 201,
          "modifiers": "",
          "type": "samplerCUBE_float",
          "name": "_LightTexture0;",
          "code": "samplerCUBE_float _LightTexture0;"
        },
        {
          "comment": "",
          "lineNum": 202,
          "modifiers": "",
          "type": "unityShadowCoord4x4",
          "name": "unity_WorldToLight;",
          "code": "unityShadowCoord4x4 unity_WorldToLight;"
        },
        {
          "comment": "",
          "lineNum": 203,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "_LightTextureB0;",
          "code": "sampler2D_float _LightTextureB0;"
        },
        {
          "comment": "",
          "lineNum": 211,
          "assignment": "= UNITY_SHADOW_ATTENUATION(input, worldPos); \\",
          "modifiers": "",
          "type": "fixed",
          "name": "shadow",
          "code": "fixed shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \\"
        },
        {
          "comment": "",
          "lineNum": 212,
          "assignment": "= tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).r * texCUBE(_LightTexture0, lightCoord).w * shadow;",
          "modifiers": "",
          "type": "fixed",
          "name": "destName",
          "code": "fixed destName = tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).r * texCUBE(_LightTexture0, lightCoord).w * shadow;"
        },
        {
          "comment": "",
          "lineNum": 216,
          "modifiers": "",
          "type": "sampler2D_float",
          "name": "_LightTexture0;",
          "code": "sampler2D_float _LightTexture0;"
        },
        {
          "comment": "",
          "lineNum": 217,
          "modifiers": "",
          "type": "unityShadowCoord4x4",
          "name": "unity_WorldToLight;",
          "code": "unityShadowCoord4x4 unity_WorldToLight;"
        },
        {
          "comment": "",
          "lineNum": 225,
          "assignment": "= UNITY_SHADOW_ATTENUATION(input, worldPos); \\",
          "modifiers": "",
          "type": "fixed",
          "name": "shadow",
          "code": "fixed shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \\"
        },
        {
          "comment": "",
          "lineNum": 226,
          "assignment": "= tex2D(_LightTexture0, lightCoord).w * shadow;",
          "modifiers": "",
          "type": "fixed",
          "name": "destName",
          "code": "fixed destName = tex2D(_LightTexture0, lightCoord).w * shadow;"
        }
      ]
    },
    {
      "file": "HLSLSupport.cginc",
      "defines": [
        {
          "comment": "",
          "lineNum": 2,
          "code": "#define HLSL_SUPPORT_INCLUDED"
        },
        {
          "comment": "    // surface shader analysis is complicated, and is done via two compilers:\n    // - Mojoshader for source level analysis (to find out structs/functions with their members & parameters).\n    //   This step can understand DX9 style HLSL syntax.\n    // - HLSL compiler for \"what actually got read & written to\" (taking dead code etc into account), via a dummy\n    //   compilation and reflection of the shader. This step can understand DX9 & DX11 HLSL syntax.\n    // Neither of these compilers are \"Cg\", but we used to use Cg in the past for this; keep the macro\n    // name intact in case some user-written shaders depend on it being that.",
          "lineNum": 12,
          "code": "    #define UNITY_COMPILER_CG"
        },
        {
          "comment": "    // surface shader analysis is complicated, and is done via two compilers:\n    // - Mojoshader for source level analysis (to find out structs/functions with their members & parameters).\n    //   This step can understand DX9 style HLSL syntax.\n    // - HLSL compiler for \"what actually got read & written to\" (taking dead code etc into account), via a dummy\n    //   compilation and reflection of the shader. This step can understand DX9 & DX11 HLSL syntax.\n    // Neither of these compilers are \"Cg\", but we used to use Cg in the past for this; keep the macro\n    // name intact in case some user-written shaders depend on it being that.",
          "lineNum": 14,
          "code": "    #define UNITY_COMPILER_HLSL"
        },
        {
          "comment": "    // surface shader analysis is complicated, and is done via two compilers:\n    // - Mojoshader for source level analysis (to find out structs/functions with their members & parameters).\n    //   This step can understand DX9 style HLSL syntax.\n    // - HLSL compiler for \"what actually got read & written to\" (taking dead code etc into account), via a dummy\n    //   compilation and reflection of the shader. This step can understand DX9 & DX11 HLSL syntax.\n    // Neither of these compilers are \"Cg\", but we used to use Cg in the past for this; keep the macro\n    // name intact in case some user-written shaders depend on it being that.",
          "lineNum": 15,
          "code": "    #define UNITY_COMPILER_HLSLCC"
        },
        {
          "comment": "    // surface shader analysis is complicated, and is done via two compilers:\n    // - Mojoshader for source level analysis (to find out structs/functions with their members & parameters).\n    //   This step can understand DX9 style HLSL syntax.\n    // - HLSL compiler for \"what actually got read & written to\" (taking dead code etc into account), via a dummy\n    //   compilation and reflection of the shader. This step can understand DX9 & DX11 HLSL syntax.\n    // Neither of these compilers are \"Cg\", but we used to use Cg in the past for this; keep the macro\n    // name intact in case some user-written shaders depend on it being that.",
          "lineNum": 17,
          "code": "    #define UNITY_COMPILER_HLSL"
        },
        {
          "comment": "    // surface shader analysis is complicated, and is done via two compilers:\n    // - Mojoshader for source level analysis (to find out structs/functions with their members & parameters).\n    //   This step can understand DX9 style HLSL syntax.\n    // - HLSL compiler for \"what actually got read & written to\" (taking dead code etc into account), via a dummy\n    //   compilation and reflection of the shader. This step can understand DX9 & DX11 HLSL syntax.\n    // Neither of these compilers are \"Cg\", but we used to use Cg in the past for this; keep the macro\n    // name intact in case some user-written shaders depend on it being that.",
          "lineNum": 19,
          "code": "    #define UNITY_COMPILER_CG"
        },
        {
          "comment": "",
          "lineNum": 23,
          "code": "    #define UNITY_STEREO_MULTIVIEW_ENABLED"
        },
        {
          "comment": "",
          "lineNum": 27,
          "code": "    #define UNITY_STEREO_INSTANCING_ENABLED"
        },
        {
          "comment": "// Is this shader API able to read the current pixel depth value, be it via\n// texture fetch of via renderpass inputs, from the depth buffer while it is\n// simultaneously bound as a z-buffer?\n// On non-renderpass (fallback impl) platforms it's supported on DX11, GL, desktop Metal\n// TODO: Check DX12 and consoles, implement read-only depth if possible\n// With native renderpasses, Vulkan is fine but iOS GPU doesn't have the wires connected to read the data.",
          "lineNum": 37,
          "code": "#define UNITY_SUPPORT_DEPTH_FETCH 1"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 50,
          "code": "#define SV_Target CoLoR"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 51,
          "code": "#define SV_Target0 CoLoR0"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 52,
          "code": "#define SV_Target1 CoLoR1"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 53,
          "code": "#define SV_Target2 CoLoR2"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 54,
          "code": "#define SV_Target3 CoLoR3"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 55,
          "code": "#define SV_Target4 CoLoR4"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 56,
          "code": "#define SV_Target5 CoLoR5"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 57,
          "code": "#define SV_Target6 CoLoR6"
        },
        {
          "comment": "// You should always declare color inouts against SV_Target",
          "lineNum": 58,
          "code": "#define SV_Target7 CoLoR7"
        },
        {
          "comment": "",
          "lineNum": 60,
          "code": "#define COLOR VCOLOR"
        },
        {
          "comment": "",
          "lineNum": 61,
          "code": "#define COLOR0 VCOLOR0"
        },
        {
          "comment": "",
          "lineNum": 62,
          "code": "#define COLOR1 VCOLOR1"
        },
        {
          "comment": "",
          "lineNum": 63,
          "code": "#define COLOR2 VCOLOR2"
        },
        {
          "comment": "",
          "lineNum": 64,
          "code": "#define COLOR3 VCOLOR3"
        },
        {
          "comment": "",
          "lineNum": 65,
          "code": "#define COLOR4 VCOLOR4"
        },
        {
          "comment": "",
          "lineNum": 66,
          "code": "#define COLOR5 VCOLOR5"
        },
        {
          "comment": "",
          "lineNum": 67,
          "code": "#define COLOR6 VCOLOR6"
        },
        {
          "comment": "",
          "lineNum": 68,
          "code": "#define COLOR7 VCOLOR7"
        },
        {
          "comment": "",
          "lineNum": 125,
          "code": "    #define UNITY_ALLOWED_MRT_COUNT 4"
        },
        {
          "comment": "",
          "lineNum": 127,
          "code": "    #define UNITY_ALLOWED_MRT_COUNT 8"
        },
        {
          "comment": "    //no fast coherent dynamic branching on these hardware",
          "lineNum": 133,
          "code": "    #define UNITY_FAST_COHERENT_DYNAMIC_BRANCHING 1"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 148,
          "code": "#define fixed half"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 149,
          "code": "#define fixed2 half2"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 150,
          "code": "#define fixed3 half3"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 151,
          "code": "#define fixed4 half4"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 152,
          "code": "#define fixed4x4 half4x4"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 153,
          "code": "#define fixed3x3 half3x3"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 154,
          "code": "#define fixed2x2 half2x2"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 155,
          "code": "#define sampler2D_half sampler2D"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 156,
          "code": "#define sampler2D_float sampler2D"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 157,
          "code": "#define samplerCUBE_half samplerCUBE"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 158,
          "code": "#define samplerCUBE_float samplerCUBE"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 159,
          "code": "#define sampler3D_float sampler3D"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 160,
          "code": "#define sampler3D_half sampler3D"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 161,
          "code": "#define Texture2D_half Texture2D"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 162,
          "code": "#define Texture2D_float Texture2D"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 163,
          "code": "#define Texture2DArray_half Texture2DArray"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 164,
          "code": "#define Texture2DArray_float Texture2DArray"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 165,
          "code": "#define Texture2DMS_half Texture2DMS"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 166,
          "code": "#define Texture2DMS_float Texture2DMS"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 167,
          "code": "#define TextureCube_half TextureCube"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 168,
          "code": "#define TextureCube_float TextureCube"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 169,
          "code": "#define TextureCubeArray_half TextureCubeArray"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 170,
          "code": "#define TextureCubeArray_float TextureCubeArray"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 171,
          "code": "#define Texture3D_float Texture3D"
        },
        {
          "comment": "// Define \"fixed\" precision to be half on non-GLSL platforms,\n// and sampler*_prec to be just simple samplers.",
          "lineNum": 172,
          "code": "#define Texture3D_half Texture3D"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 178,
          "code": "#define fixed min16float"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 179,
          "code": "#define fixed2 min16float2"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 180,
          "code": "#define fixed3 min16float3"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 181,
          "code": "#define fixed4 min16float4"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 182,
          "code": "#define fixed4x4 min16float4x4"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 183,
          "code": "#define fixed3x3 min16float3x3"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 184,
          "code": "#define fixed2x2 min16float2x2"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 185,
          "code": "#define half min16float"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 186,
          "code": "#define half2 min16float2"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 187,
          "code": "#define half3 min16float3"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 188,
          "code": "#define half4 min16float4"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 189,
          "code": "#define half2x2 min16float2x2"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 190,
          "code": "#define half3x3 min16float3x3"
        },
        {
          "comment": "// with HLSLcc, use DX11.1 partial precision for translation\n// we specifically define fixed to be float16 (same as half) as all new GPUs seems to agree on float16 being minimal precision float",
          "lineNum": 191,
          "code": "#define half4x4 min16float4x4"
        },
        {
          "comment": "",
          "lineNum": 195,
          "code": "#define fixed float"
        },
        {
          "comment": "",
          "lineNum": 196,
          "code": "#define fixed2 float2"
        },
        {
          "comment": "",
          "lineNum": 197,
          "code": "#define fixed3 float3"
        },
        {
          "comment": "",
          "lineNum": 198,
          "code": "#define fixed4 float4"
        },
        {
          "comment": "",
          "lineNum": 199,
          "code": "#define fixed4x4 float4x4"
        },
        {
          "comment": "",
          "lineNum": 200,
          "code": "#define fixed3x3 float3x3"
        },
        {
          "comment": "",
          "lineNum": 201,
          "code": "#define fixed2x2 float2x2"
        },
        {
          "comment": "",
          "lineNum": 202,
          "code": "#define half float"
        },
        {
          "comment": "",
          "lineNum": 203,
          "code": "#define half2 float2"
        },
        {
          "comment": "",
          "lineNum": 204,
          "code": "#define half3 float3"
        },
        {
          "comment": "",
          "lineNum": 205,
          "code": "#define half4 float4"
        },
        {
          "comment": "",
          "lineNum": 206,
          "code": "#define half2x2 float2x2"
        },
        {
          "comment": "",
          "lineNum": 207,
          "code": "#define half3x3 float3x3"
        },
        {
          "comment": "",
          "lineNum": 208,
          "code": "#define half4x4 float4x4"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 216,
          "code": "#define min16float half"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 217,
          "code": "#define min16float2 half2"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 218,
          "code": "#define min16float3 half3"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 219,
          "code": "#define min16float4 half4"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 220,
          "code": "#define min10float fixed"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 221,
          "code": "#define min10float2 fixed2"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 222,
          "code": "#define min10float3 fixed3"
        },
        {
          "comment": "// Define min16float/min10float to be half/fixed on non-D3D11 platforms.\n// This allows people to use min16float and friends in their shader code if they\n// really want to (making that will make shaders not load before DX11.1, e.g. on Win7,\n// but if they target WSA/WP exclusively that's fine).",
          "lineNum": 223,
          "code": "#define min10float4 fixed4"
        },
        {
          "comment": "",
          "lineNum": 227,
          "code": "#define uint int"
        },
        {
          "comment": "",
          "lineNum": 228,
          "code": "#define uint1 int1"
        },
        {
          "comment": "",
          "lineNum": 229,
          "code": "#define uint2 int2"
        },
        {
          "comment": "",
          "lineNum": 230,
          "code": "#define uint3 int3"
        },
        {
          "comment": "",
          "lineNum": 231,
          "code": "#define uint4 int4"
        },
        {
          "comment": "",
          "lineNum": 233,
          "code": "#define min16uint int"
        },
        {
          "comment": "",
          "lineNum": 234,
          "code": "#define min16uint1 int1"
        },
        {
          "comment": "",
          "lineNum": 235,
          "code": "#define min16uint2 int2"
        },
        {
          "comment": "",
          "lineNum": 236,
          "code": "#define min16uint3 int3"
        },
        {
          "comment": "",
          "lineNum": 237,
          "code": "#define min16uint4 int4"
        },
        {
          "comment": "",
          "lineNum": 239,
          "code": "#define uint1x1 int1x1"
        },
        {
          "comment": "",
          "lineNum": 240,
          "code": "#define uint1x2 int1x2"
        },
        {
          "comment": "",
          "lineNum": 241,
          "code": "#define uint1x3 int1x3"
        },
        {
          "comment": "",
          "lineNum": 242,
          "code": "#define uint1x4 int1x4"
        },
        {
          "comment": "",
          "lineNum": 243,
          "code": "#define uint2x1 int2x1"
        },
        {
          "comment": "",
          "lineNum": 244,
          "code": "#define uint2x2 int2x2"
        },
        {
          "comment": "",
          "lineNum": 245,
          "code": "#define uint2x3 int2x3"
        },
        {
          "comment": "",
          "lineNum": 246,
          "code": "#define uint2x4 int2x4"
        },
        {
          "comment": "",
          "lineNum": 247,
          "code": "#define uint3x1 int3x1"
        },
        {
          "comment": "",
          "lineNum": 248,
          "code": "#define uint3x2 int3x2"
        },
        {
          "comment": "",
          "lineNum": 249,
          "code": "#define uint3x3 int3x3"
        },
        {
          "comment": "",
          "lineNum": 250,
          "code": "#define uint3x4 int3x4"
        },
        {
          "comment": "",
          "lineNum": 251,
          "code": "#define uint4x1 int4x1"
        },
        {
          "comment": "",
          "lineNum": 252,
          "code": "#define uint4x2 int4x2"
        },
        {
          "comment": "",
          "lineNum": 253,
          "code": "#define uint4x3 int4x3"
        },
        {
          "comment": "",
          "lineNum": 254,
          "code": "#define uint4x4 int4x4"
        },
        {
          "comment": "",
          "lineNum": 256,
          "code": "#define asuint(x) asint(x)"
        },
        {
          "comment": "// specifically for samplers that are provided as arguments to entry functions",
          "lineNum": 261,
          "code": "#define SAMPLER_UNIFORM uniform"
        },
        {
          "comment": "// specifically for samplers that are provided as arguments to entry functions",
          "lineNum": 262,
          "code": "#define SHADER_UNIFORM"
        },
        {
          "comment": "// specifically for samplers that are provided as arguments to entry functions",
          "lineNum": 264,
          "code": "#define SAMPLER_UNIFORM"
        },
        {
          "comment": "// variable modifiers",
          "lineNum": 269,
          "code": "#define nointerpolation nointerp"
        },
        {
          "comment": "// variable modifiers",
          "lineNum": 270,
          "code": "#define noperspective nopersp"
        },
        {
          "comment": "",
          "lineNum": 272,
          "code": "#define CBUFFER_START(name) ConstantBuffer name {"
        },
        {
          "comment": "",
          "lineNum": 273,
          "code": "#define CBUFFER_END };"
        },
        {
          "comment": "",
          "lineNum": 275,
          "code": "#define CBUFFER_START(name) cbuffer name {"
        },
        {
          "comment": "",
          "lineNum": 276,
          "code": "#define CBUFFER_END };"
        },
        {
          "comment": "// On specific platforms, like OpenGL, GLES3 and Metal, constant buffers may still be used for instancing",
          "lineNum": 279,
          "code": "#define CBUFFER_START(name)"
        },
        {
          "comment": "// On specific platforms, like OpenGL, GLES3 and Metal, constant buffers may still be used for instancing",
          "lineNum": 280,
          "code": "#define CBUFFER_END"
        },
        {
          "comment": "",
          "lineNum": 284,
          "code": "    #define GLOBAL_CBUFFER_START(name)    cbuffer name {"
        },
        {
          "comment": "",
          "lineNum": 285,
          "code": "    #define GLOBAL_CBUFFER_END            }"
        },
        {
          "comment": "",
          "lineNum": 287,
          "code": "    #define GLOBAL_CBUFFER_START(name)    CBUFFER_START(name)"
        },
        {
          "comment": "",
          "lineNum": 288,
          "code": "    #define GLOBAL_CBUFFER_END            CBUFFER_END"
        },
        {
          "comment": "// OVR_multiview\n// In order to convey this info over the DX compiler, we wrap it into a cbuffer.",
          "lineNum": 294,
          "code": "#define UNITY_DECLARE_MULTIVIEW(number_of_views) GLOBAL_CBUFFER_START(OVR_multiview) uint gl_ViewID; uint numViews_##number_of_views; GLOBAL_CBUFFER_END"
        },
        {
          "comment": "// OVR_multiview\n// In order to convey this info over the DX compiler, we wrap it into a cbuffer.",
          "lineNum": 295,
          "code": "#define UNITY_VIEWID gl_ViewID"
        },
        {
          "comment": "// Special declaration macro for requiring the extended blend functionality\n// Declare the need for the KHR_blend_equation_advanced extension plus the specific blend mode (see the extension spec for list or \"all_equations\" for all)",
          "lineNum": 301,
          "code": "#define UNITY_REQUIRE_ADVANCED_BLEND(mode) uint hlslcc_blend_support_##mode"
        },
        {
          "comment": "// Special declaration macro for requiring the extended blend functionality\n// Declare the need for the KHR_blend_equation_advanced extension plus the specific blend mode (see the extension spec for list or \"all_equations\" for all)",
          "lineNum": 303,
          "code": "#define UNITY_REQUIRE_ADVANCED_BLEND(mode)"
        },
        {
          "comment": "",
          "lineNum": 306,
          "code": "#define UNITY_PROJ_COORD(a) a"
        },
        {
          "comment": "// Deprecated; use SAMPLE_DEPTH_TEXTURE & SAMPLE_DEPTH_TEXTURE_PROJ instead",
          "lineNum": 326,
          "code": "#define UNITY_SAMPLE_DEPTH(value) (value).r"
        },
        {
          "comment": "    // all platforms except GLES2.0 have built-in shadow comparison samplers",
          "lineNum": 338,
          "code": "    #define SHADOWS_NATIVE"
        },
        {
          "comment": "    // all platforms except GLES2.0 have built-in shadow comparison samplers\n    // GLES2.0 also has built-in shadow comparison samplers, but only on platforms where we pass UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS from the editor",
          "lineNum": 341,
          "code": "    #define SHADOWS_NATIVE"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF",
          "lineNum": 346,
          "code": "    #define UNITY_DECLARE_SHADOWMAP(tex) Texture2D tex; SamplerComparisonState sampler##tex"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF",
          "lineNum": 347,
          "code": "    #define UNITY_DECLARE_TEXCUBE_SHADOWMAP(tex) TextureCube tex; SamplerComparisonState sampler##tex"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF",
          "lineNum": 348,
          "code": "    #define UNITY_SAMPLE_SHADOW(tex,coord) tex.SampleCmpLevelZero (sampler##tex,(coord).xy,(coord).z)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF",
          "lineNum": 349,
          "code": "    #define UNITY_SAMPLE_SHADOW_PROJ(tex,coord) tex.SampleCmpLevelZero (sampler##tex,(coord).xy/(coord).w,(coord).z/(coord).w)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.",
          "lineNum": 352,
          "code": "        #define UNITY_SAMPLE_TEXCUBE_SHADOW(tex,coord) tex.SampleCmp (sampler##tex,(coord).xyz,(coord).w)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.",
          "lineNum": 354,
          "code": "       #define UNITY_SAMPLE_TEXCUBE_SHADOW(tex,coord) tex.SampleCmpLevelZero (sampler##tex,(coord).xyz,(coord).w)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF",
          "lineNum": 358,
          "code": "    #define UNITY_DECLARE_SHADOWMAP(tex)        Texture2D tex; SamplerComparisonState sampler##tex"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF",
          "lineNum": 359,
          "code": "    #define UNITY_DECLARE_TEXCUBE_SHADOWMAP(tex) TextureCube tex; SamplerComparisonState sampler##tex"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF",
          "lineNum": 360,
          "code": "    #define UNITY_SAMPLE_SHADOW(tex,coord)      tex.SampleCmpLOD0(sampler##tex,(coord).xy,(coord).z)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF",
          "lineNum": 361,
          "code": "    #define UNITY_SAMPLE_SHADOW_PROJ(tex,coord) tex.SampleCmpLOD0(sampler##tex,(coord).xy/(coord).w,(coord).z/(coord).w)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF",
          "lineNum": 362,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_SHADOW(tex,coord) tex.SampleCmpLOD0(sampler##tex,(coord).xyz,(coord).w)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF\n    // Fallback / No built-in shadowmap comparison sampling: regular texture sample and do manual depth comparison",
          "lineNum": 365,
          "code": "    #define UNITY_DECLARE_SHADOWMAP(tex) sampler2D_float tex"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF\n    // Fallback / No built-in shadowmap comparison sampling: regular texture sample and do manual depth comparison",
          "lineNum": 366,
          "code": "    #define UNITY_DECLARE_TEXCUBE_SHADOWMAP(tex) samplerCUBE_float tex"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF\n    // Fallback / No built-in shadowmap comparison sampling: regular texture sample and do manual depth comparison",
          "lineNum": 367,
          "code": "    #define UNITY_SAMPLE_SHADOW(tex,coord) ((SAMPLE_DEPTH_TEXTURE(tex,(coord).xy) < (coord).z) ? 0.0 : 1.0)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF\n    // Fallback / No built-in shadowmap comparison sampling: regular texture sample and do manual depth comparison",
          "lineNum": 368,
          "code": "    #define UNITY_SAMPLE_SHADOW_PROJ(tex,coord) ((SAMPLE_DEPTH_TEXTURE_PROJ(tex,UNITY_PROJ_COORD(coord)) < ((coord).z/(coord).w)) ? 0.0 : 1.0)"
        },
        {
          "comment": "    // DX11 & hlslcc platforms: built-in PCF\n        // GLSL does not have textureLod(samplerCubeShadow, ...) support. GLES2 does not have core support for samplerCubeShadow, so we ignore it.\n    // PS4: built-in PCF\n    // Fallback / No built-in shadowmap comparison sampling: regular texture sample and do manual depth comparison",
          "lineNum": 369,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_SHADOW(tex,coord) ((SAMPLE_DEPTH_CUBE_TEXTURE(tex,(coord).xyz) < (coord).w) ? 0.0 : 1.0)"
        },
        {
          "comment": "",
          "lineNum": 389,
          "code": "    #define UNITY_SEPARATE_TEXTURE_SAMPLER"
        },
        {
          "comment": "    // 2D textures",
          "lineNum": 392,
          "code": "    #define UNITY_DECLARE_TEX2D(tex) Texture2D tex; SamplerState sampler##tex"
        },
        {
          "comment": "    // 2D textures",
          "lineNum": 393,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER(tex) Texture2D tex"
        },
        {
          "comment": "    // 2D textures",
          "lineNum": 394,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_INT(tex) Texture2D<int4> tex"
        },
        {
          "comment": "    // 2D textures",
          "lineNum": 395,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_UINT(tex) Texture2D<uint4> tex"
        },
        {
          "comment": "    // 2D textures",
          "lineNum": 396,
          "code": "    #define UNITY_SAMPLE_TEX2D(tex,coord) tex.Sample (sampler##tex,coord)"
        },
        {
          "comment": "    // 2D textures",
          "lineNum": 397,
          "code": "    #define UNITY_SAMPLE_TEX2D_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,coord)"
        },
        {
          "comment": "",
          "lineNum": 400,
          "code": "    #define UNITY_DECLARE_TEX2D_HALF(tex) Texture2D_half tex; SamplerState sampler##tex"
        },
        {
          "comment": "",
          "lineNum": 401,
          "code": "    #define UNITY_DECLARE_TEX2D_FLOAT(tex) Texture2D_float tex; SamplerState sampler##tex"
        },
        {
          "comment": "",
          "lineNum": 402,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_HALF(tex) Texture2D_half tex"
        },
        {
          "comment": "",
          "lineNum": 403,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_FLOAT(tex) Texture2D_float tex"
        },
        {
          "comment": "",
          "lineNum": 405,
          "code": "    #define UNITY_DECLARE_TEX2D_HALF(tex) Texture2D tex; SamplerState sampler##tex"
        },
        {
          "comment": "",
          "lineNum": 406,
          "code": "    #define UNITY_DECLARE_TEX2D_FLOAT(tex) Texture2D tex; SamplerState sampler##tex"
        },
        {
          "comment": "",
          "lineNum": 407,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_HALF(tex) Texture2D tex"
        },
        {
          "comment": "",
          "lineNum": 408,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_FLOAT(tex) Texture2D tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 412,
          "code": "    #define UNITY_DECLARE_TEXCUBE(tex) TextureCube tex; SamplerState sampler##tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 413,
          "code": "    #define UNITY_ARGS_TEXCUBE(tex) TextureCube tex, SamplerState sampler##tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 414,
          "code": "    #define UNITY_PASS_TEXCUBE(tex) tex, sampler##tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 415,
          "code": "    #define UNITY_PASS_TEXCUBE_SAMPLER(tex,samplertex) tex, sampler##samplertex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 416,
          "code": "    #define UNITY_PASS_TEXCUBE_SAMPLER_LOD(tex, samplertex, lod) tex, sampler##samplertex, lod"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 417,
          "code": "    #define UNITY_DECLARE_TEXCUBE_NOSAMPLER(tex) TextureCube tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 418,
          "code": "    #define UNITY_SAMPLE_TEXCUBE(tex,coord) tex.Sample (sampler##tex,coord)"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 419,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_LOD(tex,coord,lod) tex.SampleLevel (sampler##tex,coord, lod)"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 420,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,coord)"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 421,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(tex, samplertex, coord, lod) tex.SampleLevel (sampler##samplertex, coord, lod)"
        },
        {
          "comment": "    // Cubemaps\n    // 3D textures",
          "lineNum": 423,
          "code": "    #define UNITY_DECLARE_TEX3D(tex) Texture3D tex; SamplerState sampler##tex"
        },
        {
          "comment": "    // Cubemaps\n    // 3D textures",
          "lineNum": 424,
          "code": "    #define UNITY_DECLARE_TEX3D_NOSAMPLER(tex) Texture3D tex"
        },
        {
          "comment": "    // Cubemaps\n    // 3D textures",
          "lineNum": 425,
          "code": "    #define UNITY_SAMPLE_TEX3D(tex,coord) tex.Sample (sampler##tex,coord)"
        },
        {
          "comment": "    // Cubemaps\n    // 3D textures",
          "lineNum": 426,
          "code": "    #define UNITY_SAMPLE_TEX3D_LOD(tex,coord,lod) tex.SampleLevel (sampler##tex,coord, lod)"
        },
        {
          "comment": "    // Cubemaps\n    // 3D textures",
          "lineNum": 427,
          "code": "    #define UNITY_SAMPLE_TEX3D_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,coord)"
        },
        {
          "comment": "    // Cubemaps\n    // 3D textures",
          "lineNum": 428,
          "code": "    #define UNITY_SAMPLE_TEX3D_SAMPLER_LOD(tex, samplertex, coord, lod) tex.SampleLevel(sampler##samplertex, coord, lod)"
        },
        {
          "comment": "",
          "lineNum": 431,
          "code": "    #define UNITY_DECLARE_TEX3D_FLOAT(tex) Texture3D_float tex; SamplerState sampler##tex"
        },
        {
          "comment": "",
          "lineNum": 432,
          "code": "    #define UNITY_DECLARE_TEX3D_HALF(tex) Texture3D_half tex; SamplerState sampler##tex"
        },
        {
          "comment": "",
          "lineNum": 434,
          "code": "    #define UNITY_DECLARE_TEX3D_FLOAT(tex) Texture3D tex; SamplerState sampler##tex"
        },
        {
          "comment": "",
          "lineNum": 435,
          "code": "    #define UNITY_DECLARE_TEX3D_HALF(tex) Texture3D tex; SamplerState sampler##tex"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 439,
          "code": "    #define UNITY_DECLARE_TEX2DARRAY_MS(tex) Texture2DMSArray<float> tex; SamplerState sampler##tex"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 440,
          "code": "    #define UNITY_DECLARE_TEX2DARRAY_MS_NOSAMPLER(tex) Texture2DArray<float> tex"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 441,
          "code": "    #define UNITY_DECLARE_TEX2DARRAY(tex) Texture2DArray tex; SamplerState sampler##tex"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 442,
          "code": "    #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) Texture2DArray tex"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 443,
          "code": "    #define UNITY_ARGS_TEX2DARRAY(tex) Texture2DArray tex, SamplerState sampler##tex"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 444,
          "code": "    #define UNITY_PASS_TEX2DARRAY(tex) tex, sampler##tex"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 445,
          "code": "    #define UNITY_SAMPLE_TEX2DARRAY(tex,coord) tex.Sample (sampler##tex,coord)"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 446,
          "code": "    #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod) tex.SampleLevel (sampler##tex,coord, lod)"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 447,
          "code": "    #define UNITY_SAMPLE_TEX2DARRAY_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,coord)"
        },
        {
          "comment": "    // 2D arrays",
          "lineNum": 448,
          "code": "    #define UNITY_SAMPLE_TEX2DARRAY_SAMPLER_LOD(tex,samplertex,coord,lod) tex.SampleLevel (sampler##samplertex,coord,lod)"
        },
        {
          "comment": "    // Cube arrays",
          "lineNum": 451,
          "code": "    #define UNITY_DECLARE_TEXCUBEARRAY(tex) TextureCubeArray tex; SamplerState sampler##tex"
        },
        {
          "comment": "    // Cube arrays",
          "lineNum": 452,
          "code": "    #define UNITY_DECLARE_TEXCUBEARRAY_NOSAMPLER(tex) TextureCubeArray tex"
        },
        {
          "comment": "    // Cube arrays",
          "lineNum": 453,
          "code": "    #define UNITY_ARGS_TEXCUBEARRAY(tex) TextureCubeArray tex, SamplerState sampler##tex"
        },
        {
          "comment": "    // Cube arrays",
          "lineNum": 454,
          "code": "    #define UNITY_PASS_TEXCUBEARRAY(tex) tex, sampler##tex"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 457,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY(tex,coord) tex.Sample (sampler##tex,float4((coord).xyz, round((coord).w)))"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 458,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY_LOD(tex,coord,lod) tex.SampleLevel (sampler##tex,float4((coord).xyz, round((coord).w)), lod)"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 459,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,float4((coord).xyz, round((coord).w)))"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 460,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY_SAMPLER_LOD(tex,samplertex,coord,lod) tex.SampleLevel (sampler##samplertex,float4((coord).xyz, round((coord).w)), lod)"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 462,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY(tex,coord) tex.Sample (sampler##tex,coord)"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 463,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY_LOD(tex,coord,lod) tex.SampleLevel (sampler##tex,coord, lod)"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 464,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,coord)"
        },
        {
          "comment": "    // Cube arrays\n    // round the layer index to get DX11-like behaviour (otherwise fractional indices result in mixed up cubemap faces)",
          "lineNum": 465,
          "code": "    #define UNITY_SAMPLE_TEXCUBEARRAY_SAMPLER_LOD(tex,samplertex,coord,lod) tex.SampleLevel (sampler##samplertex,coord,lod)"
        },
        {
          "comment": "    // DX9 style HLSL syntax; same object for texture+sampler\n    // 2D textures",
          "lineNum": 472,
          "code": "    #define UNITY_DECLARE_TEX2D(tex) sampler2D tex"
        },
        {
          "comment": "    // DX9 style HLSL syntax; same object for texture+sampler\n    // 2D textures",
          "lineNum": 473,
          "code": "    #define UNITY_DECLARE_TEX2D_HALF(tex) sampler2D_half tex"
        },
        {
          "comment": "    // DX9 style HLSL syntax; same object for texture+sampler\n    // 2D textures",
          "lineNum": 474,
          "code": "    #define UNITY_DECLARE_TEX2D_FLOAT(tex) sampler2D_float tex"
        },
        {
          "comment": "",
          "lineNum": 476,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER(tex) sampler2D tex"
        },
        {
          "comment": "",
          "lineNum": 477,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_HALF(tex) sampler2D_half tex"
        },
        {
          "comment": "",
          "lineNum": 478,
          "code": "    #define UNITY_DECLARE_TEX2D_NOSAMPLER_FLOAT(tex) sampler2D_float tex"
        },
        {
          "comment": "",
          "lineNum": 480,
          "code": "    #define UNITY_SAMPLE_TEX2D(tex,coord) tex2D (tex,coord)"
        },
        {
          "comment": "",
          "lineNum": 481,
          "code": "    #define UNITY_SAMPLE_TEX2D_SAMPLER(tex,samplertex,coord) tex2D (tex,coord)"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 483,
          "code": "    #define UNITY_DECLARE_TEXCUBE(tex) samplerCUBE tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 484,
          "code": "    #define UNITY_ARGS_TEXCUBE(tex) samplerCUBE tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 485,
          "code": "    #define UNITY_PASS_TEXCUBE(tex) tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 486,
          "code": "    #define UNITY_PASS_TEXCUBE_SAMPLER(tex,samplertex) tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 487,
          "code": "    #define UNITY_DECLARE_TEXCUBE_NOSAMPLER(tex) samplerCUBE tex"
        },
        {
          "comment": "    // Cubemaps",
          "lineNum": 488,
          "code": "    #define UNITY_SAMPLE_TEXCUBE(tex,coord) texCUBE (tex,coord)"
        },
        {
          "comment": "",
          "lineNum": 490,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_LOD(tex,coord,lod) texCUBElod (tex, half4(coord, lod))"
        },
        {
          "comment": "",
          "lineNum": 491,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(tex,samplertex,coord,lod) UNITY_SAMPLE_TEXCUBE_LOD(tex,coord,lod)"
        },
        {
          "comment": "",
          "lineNum": 492,
          "code": "    #define UNITY_SAMPLE_TEXCUBE_SAMPLER(tex,samplertex,coord) texCUBE (tex,coord)"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 495,
          "code": "    #define UNITY_DECLARE_TEX3D(tex) sampler3D tex"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 496,
          "code": "    #define UNITY_DECLARE_TEX3D_NOSAMPLER(tex) sampler3D tex"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 497,
          "code": "    #define UNITY_DECLARE_TEX3D_FLOAT(tex) sampler3D_float tex"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 498,
          "code": "    #define UNITY_DECLARE_TEX3D_HALF(tex) sampler3D_float tex"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 499,
          "code": "    #define UNITY_SAMPLE_TEX3D(tex,coord) tex3D (tex,coord)"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 500,
          "code": "    #define UNITY_SAMPLE_TEX3D_LOD(tex,coord,lod) tex3D (tex,float4(coord,lod))"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 501,
          "code": "    #define UNITY_SAMPLE_TEX3D_SAMPLER(tex,samplertex,coord) tex3D (tex,coord)"
        },
        {
          "comment": "    // 3D textures",
          "lineNum": 502,
          "code": "    #define UNITY_SAMPLE_TEX3D_SAMPLER_LOD(tex,samplertex,coord,lod) tex3D (tex,float4(coord,lod))"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 506,
          "code": "        #define UNITY_DECLARE_TEX2DARRAY(tex) sampler2DArray tex"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 507,
          "code": "        #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) sampler2DArray tex"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 508,
          "code": "        #define UNITY_ARGS_TEX2DARRAY(tex) sampler2DArray tex"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 509,
          "code": "        #define UNITY_PASS_TEX2DARRAY(tex) tex"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 510,
          "code": "        #define UNITY_SAMPLE_TEX2DARRAY(tex,coord) tex2DArray (tex,coord)"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 511,
          "code": "        #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod) tex2DArraylod (tex, float4(coord,lod))"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 512,
          "code": "        #define UNITY_SAMPLE_TEX2DARRAY_SAMPLER(tex,samplertex,coord) tex2DArray (tex,coord)"
        },
        {
          "comment": "    // 2D array syntax for surface shader analysis",
          "lineNum": 513,
          "code": "        #define UNITY_SAMPLE_TEX2DARRAY_SAMPLER_LOD(tex,samplertex,coord,lod) tex2DArraylod (tex, float4(coord,lod))"
        },
        {
          "comment": "    // surface shader analysis; just pretend that 2D arrays are cubemaps",
          "lineNum": 518,
          "code": "        #define sampler2DArray samplerCUBE"
        },
        {
          "comment": "    // surface shader analysis; just pretend that 2D arrays are cubemaps",
          "lineNum": 519,
          "code": "        #define tex2DArray texCUBE"
        },
        {
          "comment": "    // surface shader analysis; just pretend that 2D arrays are cubemaps",
          "lineNum": 520,
          "code": "        #define tex2DArraylod texCUBElod"
        },
        {
          "comment": "// For backwards compatibility, so we won't accidentally break shaders written by user",
          "lineNum": 526,
          "code": "#define SampleCubeReflection(env, dir, lod) UNITY_SAMPLE_TEXCUBE_LOD(env, dir, lod)"
        },
        {
          "comment": "",
          "lineNum": 529,
          "code": "#define samplerRECT sampler2D"
        },
        {
          "comment": "",
          "lineNum": 530,
          "code": "#define texRECT tex2D"
        },
        {
          "comment": "",
          "lineNum": 531,
          "code": "#define texRECTlod tex2Dlod"
        },
        {
          "comment": "",
          "lineNum": 532,
          "code": "#define texRECTbias tex2Dbias"
        },
        {
          "comment": "",
          "lineNum": 533,
          "code": "#define texRECTproj tex2Dproj"
        },
        {
          "comment": "",
          "lineNum": 536,
          "code": "#define VPOS            S_POSITION"
        },
        {
          "comment": "// Cg seems to use WPOS instead of VPOS semantic?",
          "lineNum": 539,
          "code": "#define VPOS WPOS"
        },
        {
          "comment": "// Cg seems to use WPOS instead of VPOS semantic?\n// Cg does not have tex2Dgrad and friends, but has tex2D overload that\n// can take the derivatives",
          "lineNum": 542,
          "code": "#define tex2Dgrad tex2D"
        },
        {
          "comment": "// Cg seems to use WPOS instead of VPOS semantic?\n// Cg does not have tex2Dgrad and friends, but has tex2D overload that\n// can take the derivatives",
          "lineNum": 543,
          "code": "#define texCUBEgrad texCUBE"
        },
        {
          "comment": "// Cg seems to use WPOS instead of VPOS semantic?\n// Cg does not have tex2Dgrad and friends, but has tex2D overload that\n// can take the derivatives",
          "lineNum": 544,
          "code": "#define tex3Dgrad tex3D"
        },
        {
          "comment": "// Data type to be used for \"screen space position\" pixel shader input semantic; just a float4 now (used to be float2 when on D3D9)",
          "lineNum": 549,
          "code": "#define UNITY_VPOS_TYPE float4"
        },
        {
          "comment": "",
          "lineNum": 554,
          "code": "#define FOGC FOG"
        },
        {
          "comment": "// Use VFACE pixel shader input semantic in your shaders to get front-facing scalar value.\n// Requires shader model 3.0 or higher.\n// Back when D3D9 existed UNITY_VFACE_AFFECTED_BY_PROJECTION macro used to be defined there too.",
          "lineNum": 561,
          "code": "#define VFACE FACE"
        },
        {
          "comment": "// Use VFACE pixel shader input semantic in your shaders to get front-facing scalar value.\n// Requires shader model 3.0 or higher.\n// Back when D3D9 existed UNITY_VFACE_AFFECTED_BY_PROJECTION macro used to be defined there too.",
          "lineNum": 564,
          "code": "#define VFACE S_FRONT_FACE"
        },
        {
          "comment": "",
          "lineNum": 569,
          "code": "#define SV_POSITION POSITION"
        },
        {
          "comment": "// On D3D reading screen space coordinates from fragment shader requires SM3.0",
          "lineNum": 574,
          "code": "#define UNITY_POSITION(pos) float4 pos : SV_POSITION"
        },
        {
          "comment": "// Kept for backwards-compatibility",
          "lineNum": 577,
          "code": "#define UNITY_ATTEN_CHANNEL r"
        },
        {
          "comment": "",
          "lineNum": 580,
          "code": "#define UNITY_UV_STARTS_AT_TOP 1"
        },
        {
          "comment": "// D3D style platforms where clip space z is [0, 1].",
          "lineNum": 585,
          "code": "#define UNITY_REVERSED_Z 1"
        },
        {
          "comment": "",
          "lineNum": 589,
          "code": "#define UNITY_NEAR_CLIP_VALUE (1.0)"
        },
        {
          "comment": "",
          "lineNum": 591,
          "code": "#define UNITY_NEAR_CLIP_VALUE (-1.0)"
        },
        {
          "comment": "// On most platforms, use floating point render targets to store depth of point\n// light shadowmaps. However, on some others they either have issues, or aren't widely\n// supported; in which case fallback to encoding depth into RGBA channels.\n// Make sure this define matches GraphicsCaps.useRGBAForPointShadows.",
          "lineNum": 607,
          "code": "#define UNITY_USE_RGBA_FOR_POINT_SHADOWS"
        },
        {
          "comment": "// Initialize arbitrary structure with zero values.\n// Not supported on some backends (e.g. Cg-based particularly with nested structs).",
          "lineNum": 614,
          "code": "#define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;"
        },
        {
          "comment": "// Initialize arbitrary structure with zero values.\n// Not supported on some backends (e.g. Cg-based particularly with nested structs).",
          "lineNum": 616,
          "code": "#define UNITY_INITIALIZE_OUTPUT(type,name)"
        },
        {
          "comment": "",
          "lineNum": 620,
          "code": "#define UNITY_CAN_COMPILE_TESSELLATION 1"
        },
        {
          "comment": "// Not really needed anymore, but did ship in Unity 4.0; with D3D11_9X remapping them to .r channel.\n// Now that's not used.",
          "lineNum": 630,
          "code": "#define UNITY_SAMPLE_1CHANNEL(x,y) tex2D(x,y).a"
        },
        {
          "comment": "// Not really needed anymore, but did ship in Unity 4.0; with D3D11_9X remapping them to .r channel.\n// Now that's not used.",
          "lineNum": 631,
          "code": "#define UNITY_ALPHA_CHANNEL a"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 636,
          "code": "    #define UNITY_BRANCH    [branch]"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 637,
          "code": "    #define UNITY_FLATTEN   [flatten]"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 638,
          "code": "    #define UNITY_UNROLL    [unroll]"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 639,
          "code": "    #define UNITY_LOOP      [loop]"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 640,
          "code": "    #define UNITY_FASTOPT   [fastopt]"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 642,
          "code": "    #define UNITY_BRANCH"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 643,
          "code": "    #define UNITY_FLATTEN"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 644,
          "code": "    #define UNITY_UNROLL"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 645,
          "code": "    #define UNITY_LOOP"
        },
        {
          "comment": "// HLSL attributes",
          "lineNum": 646,
          "code": "    #define UNITY_FASTOPT"
        },
        {
          "comment": "// Unity 4.x shaders used to mostly work if someone used WPOS semantic,\n// which was accepted by Cg. The correct semantic to use is \"VPOS\",\n// so define that so that old shaders keep on working.",
          "lineNum": 654,
          "code": "#define WPOS VPOS"
        },
        {
          "comment": "// define use to identify platform with modern feature like texture 3D with filtering, texture array etc...",
          "lineNum": 658,
          "code": "#define UNITY_SM40_PLUS_PLATFORM (!((SHADER_TARGET < 30) || defined (SHADER_API_MOBILE) || defined(SHADER_API_GLES)))"
        },
        {
          "comment": "// Ability to manually set descriptor set and binding numbers (Vulkan only)",
          "lineNum": 662,
          "code": "    #define CBUFFER_START_WITH_BINDING(Name, Set, Binding) CBUFFER_START(Name##Xhlslcc_set_##Set##_bind_##Binding##X)"
        },
        {
          "comment": "// Ability to manually set descriptor set and binding numbers (Vulkan only)\n    // Sampler / image declaration with set/binding decoration",
          "lineNum": 664,
          "code": "    #define DECL_WITH_BINDING(Type, Name, Set, Binding) Type Name##hlslcc_set_##Set##_bind_##Binding"
        },
        {
          "comment": "// Ability to manually set descriptor set and binding numbers (Vulkan only)\n    // Sampler / image declaration with set/binding decoration",
          "lineNum": 666,
          "code": "    #define CBUFFER_START_WITH_BINDING(Name, Set, Binding) CBUFFER_START(Name)"
        },
        {
          "comment": "// Ability to manually set descriptor set and binding numbers (Vulkan only)\n    // Sampler / image declaration with set/binding decoration",
          "lineNum": 667,
          "code": "    #define DECL_WITH_BINDING(Type, Name, Set, Binding) Type Name"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input",
          "lineNum": 673,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_FLOAT(idx) cbuffer hlslcc_SubpassInput_f_##idx { float4 hlslcc_fbinput_##idx; }"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input",
          "lineNum": 674,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_FLOAT_MS(idx) cbuffer hlslcc_SubpassInput_F_##idx { float4 hlslcc_fbinput_##idx[8]; }"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input\n// For halfs",
          "lineNum": 676,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_HALF(idx) cbuffer hlslcc_SubpassInput_h_##idx { half4 hlslcc_fbinput_##idx; }"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input\n// For halfs",
          "lineNum": 677,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_HALF_MS(idx) cbuffer hlslcc_SubpassInput_H_##idx { half4 hlslcc_fbinput_##idx[8]; }"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input\n// For halfs\n// For ints",
          "lineNum": 679,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_INT(idx) cbuffer hlslcc_SubpassInput_i_##idx { int4 hlslcc_fbinput_##idx; }"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input\n// For halfs\n// For ints",
          "lineNum": 680,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_INT_MS(idx) cbuffer hlslcc_SubpassInput_I_##idx { int4 hlslcc_fbinput_##idx[8]; }"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input\n// For halfs\n// For ints\n// For uints",
          "lineNum": 682,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_UINT(idx) cbuffer hlslcc_SubpassInput_u_##idx { uint4 hlslcc_fbinput_##idx; }"
        },
        {
          "comment": "// TODO: Really need a better define for iOS Metal than the framebuffer fetch one, that's also enabled on android and webgl (???)\n// Renderpass inputs: Vulkan/Metal subpass input\n// For halfs\n// For ints\n// For uints",
          "lineNum": 683,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_UINT_MS(idx) cbuffer hlslcc_SubpassInput_U_##idx { uint4 hlslcc_fbinput_##idx[8]; }"
        },
        {
          "comment": "",
          "lineNum": 685,
          "code": "#define UNITY_READ_FRAMEBUFFER_INPUT(idx, v2fname) hlslcc_fbinput_##idx"
        },
        {
          "comment": "",
          "lineNum": 686,
          "code": "#define UNITY_READ_FRAMEBUFFER_INPUT_MS(idx, sampleIdx, v2fname) hlslcc_fbinput_##idx[sampleIdx]"
        },
        {
          "comment": "// Renderpass inputs: General fallback path",
          "lineNum": 691,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_FLOAT(idx) UNITY_DECLARE_TEX2D_NOSAMPLER_FLOAT(_UnityFBInput##idx); float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "// Renderpass inputs: General fallback path",
          "lineNum": 692,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_HALF(idx) UNITY_DECLARE_TEX2D_NOSAMPLER_HALF(_UnityFBInput##idx); float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "// Renderpass inputs: General fallback path",
          "lineNum": 693,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_INT(idx) UNITY_DECLARE_TEX2D_NOSAMPLER_INT(_UnityFBInput##idx); float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "// Renderpass inputs: General fallback path",
          "lineNum": 694,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_UINT(idx) UNITY_DECLARE_TEX2D_NOSAMPLER_UINT(_UnityFBInput##idx); float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "",
          "lineNum": 696,
          "code": "#define UNITY_READ_FRAMEBUFFER_INPUT(idx, v2fvertexname) _UnityFBInput##idx.Load(uint3(v2fvertexname.xy, 0))"
        },
        {
          "comment": "",
          "lineNum": 700,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_FLOAT_MS(idx) Texture2DMS<float4> _UnityFBInput##idx; float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "",
          "lineNum": 701,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_HALF_MS(idx) Texture2DMS<float4> _UnityFBInput##idx; float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "",
          "lineNum": 702,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_INT_MS(idx) Texture2DMS<int4> _UnityFBInput##idx; float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "",
          "lineNum": 703,
          "code": "#define UNITY_DECLARE_FRAMEBUFFER_INPUT_UINT_MS(idx) Texture2DMS<uint4> _UnityFBInput##idx; float4 _UnityFBInput##idx##_TexelSize"
        },
        {
          "comment": "",
          "lineNum": 705,
          "code": "#define UNITY_READ_FRAMEBUFFER_INPUT_MS(idx, sampleIdx, v2fvertexname) _UnityFBInput##idx.Load(uint2(v2fvertexname.xy), sampleIdx)"
        },
        {
          "comment": "// Unity 5.0 renamed HDR_LIGHT_PREPASS_ON to UNITY_HDR_ON",
          "lineNum": 716,
          "code": "#define HDR_LIGHT_PREPASS_ON 1"
        },
        {
          "comment": "// UNITY_NO_LINEAR_COLORSPACE was removed in 5.4 when UNITY_COLORSPACE_GAMMA was introduced as a platform keyword and runtime gamma fallback removed.",
          "lineNum": 721,
          "code": "#define UNITY_NO_LINEAR_COLORSPACE 1"
        },
        {
          "comment": "",
          "lineNum": 725,
          "code": "#define DIRLIGHTMAP_OFF 1"
        },
        {
          "comment": "",
          "lineNum": 729,
          "code": "#define LIGHTMAP_OFF 1"
        },
        {
          "comment": "",
          "lineNum": 733,
          "code": "#define DYNAMICLIGHTMAP_OFF 1"
        },
        {
          "comment": "",
          "lineNum": 740,
          "code": "    #define UNITY_DECLARE_DEPTH_TEXTURE_MS(tex)  UNITY_DECLARE_TEX2DARRAY_MS (tex)"
        },
        {
          "comment": "",
          "lineNum": 743,
          "code": "    #define UNITY_DECLARE_DEPTH_TEXTURE(tex) UNITY_DECLARE_TEX2DARRAY (tex)"
        },
        {
          "comment": "",
          "lineNum": 746,
          "code": "    #define SAMPLE_DEPTH_TEXTURE(sampler, uv) UNITY_SAMPLE_TEX2DARRAY(sampler, float3((uv).x, (uv).y, (float)unity_StereoEyeIndex)).r"
        },
        {
          "comment": "",
          "lineNum": 749,
          "code": "    #define SAMPLE_DEPTH_TEXTURE_PROJ(sampler, uv) UNITY_SAMPLE_TEX2DARRAY(sampler, float3((uv).x/(uv).w, (uv).y/(uv).w, (float)unity_StereoEyeIndex)).r"
        },
        {
          "comment": "",
          "lineNum": 752,
          "code": "    #define SAMPLE_DEPTH_TEXTURE_LOD(sampler, uv) UNITY_SAMPLE_TEX2DARRAY_LOD(sampler, float3((uv).xy, (float)unity_StereoEyeIndex), (uv).w).r"
        },
        {
          "comment": "",
          "lineNum": 755,
          "code": "    #define SAMPLE_RAW_DEPTH_TEXTURE(tex, uv) UNITY_SAMPLE_TEX2DARRAY(tex, float3((uv).xy, (float)unity_StereoEyeIndex))"
        },
        {
          "comment": "",
          "lineNum": 758,
          "code": "    #define SAMPLE_RAW_DEPTH_TEXTURE_PROJ(sampler, uv) UNITY_SAMPLE_TEX2DARRAY(sampler, float3((uv).x/(uv).w, (uv).y/(uv).w, (float)unity_StereoEyeIndex))"
        },
        {
          "comment": "",
          "lineNum": 761,
          "code": "    #define SAMPLE_RAW_DEPTH_TEXTURE_LOD(sampler, uv) UNITY_SAMPLE_TEX2DARRAY_LOD(sampler, float3((uv).xy, (float)unity_StereoEyeIndex), (uv).w)"
        },
        {
          "comment": "",
          "lineNum": 763,
          "code": "    #define UNITY_DECLARE_SCREENSPACE_SHADOWMAP UNITY_DECLARE_TEX2DARRAY"
        },
        {
          "comment": "",
          "lineNum": 764,
          "code": "    #define UNITY_SAMPLE_SCREEN_SHADOW(tex, uv) UNITY_SAMPLE_TEX2DARRAY( tex, float3((uv).x/(uv).w, (uv).y/(uv).w, (float)unity_StereoEyeIndex) ).r"
        },
        {
          "comment": "",
          "lineNum": 766,
          "code": "    #define UNITY_DECLARE_SCREENSPACE_TEXTURE UNITY_DECLARE_TEX2DARRAY"
        },
        {
          "comment": "",
          "lineNum": 767,
          "code": "    #define UNITY_SAMPLE_SCREENSPACE_TEXTURE(tex, uv) UNITY_SAMPLE_TEX2DARRAY(tex, float3((uv).xy, (float)unity_StereoEyeIndex))"
        },
        {
          "comment": "",
          "lineNum": 769,
          "code": "    #define UNITY_DECLARE_DEPTH_TEXTURE_MS(tex)  Texture2DMS<float> tex;"
        },
        {
          "comment": "",
          "lineNum": 770,
          "code": "    #define UNITY_DECLARE_DEPTH_TEXTURE(tex) sampler2D_float tex"
        },
        {
          "comment": "",
          "lineNum": 771,
          "code": "    #define UNITY_DECLARE_SCREENSPACE_SHADOWMAP(tex) sampler2D tex"
        },
        {
          "comment": "",
          "lineNum": 772,
          "code": "    #define UNITY_SAMPLE_SCREEN_SHADOW(tex, uv) tex2Dproj( tex, UNITY_PROJ_COORD(uv) ).r"
        },
        {
          "comment": "",
          "lineNum": 773,
          "code": "    #define UNITY_DECLARE_SCREENSPACE_TEXTURE(tex) sampler2D tex;"
        },
        {
          "comment": "",
          "lineNum": 774,
          "code": "    #define UNITY_SAMPLE_SCREENSPACE_TEXTURE(tex, uv) tex2D(tex, uv)"
        }
      ],
      "functions": [],
      "structs": [],
      "variables": []
    }
  ]
}